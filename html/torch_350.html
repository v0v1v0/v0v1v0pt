<div class="container">

<table style="width: 100%;"><tr>
<td>optim_rmsprop</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>RMSprop optimizer</h2>

<h3>Description</h3>

<p>Proposed by G. Hinton in his course.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optim_rmsprop(
  params,
  lr = 0.01,
  alpha = 0.99,
  eps = 1e-08,
  weight_decay = 0,
  momentum = 0,
  centered = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>(iterable): iterable of parameters to optimize or list defining parameter groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lr</code></td>
<td>
<p>(float, optional): learning rate (default: 1e-2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>(float, optional): smoothing constant (default: 0.99)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>(float, optional): term added to the denominator to improve
numerical stability (default: 1e-8)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_decay</code></td>
<td>
<p>optional weight decay penalty. (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momentum</code></td>
<td>
<p>(float, optional): momentum factor (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centered</code></td>
<td>
<p>(bool, optional) : if <code>TRUE</code>, compute the centered RMSProp,
the gradient is normalized by an estimation of its variance
weight_decay (float, optional): weight decay (L2 penalty) (default: 0)</p>
</td>
</tr>
</table>
<h3>Warning</h3>

<p>If you need to move a model to GPU via <code style="white-space: pre;">⁠$cuda()⁠</code>, please do so before
constructing optimizers for it. Parameters of a model after <code style="white-space: pre;">⁠$cuda()⁠</code>
will be different objects from those before the call. In general, you
should make sure that the objects pointed to by model parameters subject
to optimization remain the same over the whole lifecycle of optimizer
creation and usage.
</p>


<h3>Note</h3>

<p>The centered version first appears in
<a href="https://arxiv.org/pdf/1308.0850v5">Generating Sequences With Recurrent Neural Networks</a>.
The implementation here takes the square root of the gradient average before
adding epsilon (note that TensorFlow interchanges these two operations). The effective
learning rate is thus <code class="reqn">\alpha/(\sqrt{v} + \epsilon)</code> where <code class="reqn">\alpha</code>
is the scheduled learning rate and <code class="reqn">v</code> is the weighted moving average
of the squared gradient.
</p>
<p>Update rule:
</p>
<p style="text-align: center;"><code class="reqn">
\theta_{t+1} = \theta_{t} - \frac{\eta }{\sqrt{{E[g^2]}_{t} + \epsilon}} * g_{t}
</code>
</p>



</div>