<div class="container">

<table style="width: 100%;"><tr>
<td>evm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extreme value modelling</h2>

<h3>Description</h3>

<p>Likelihood based modelling and inference for extreme value models, possibly
with explanatory variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">evm(y, data = NULL, ...)

evmReal(y, data)

evm.default(
  y,
  data = NULL,
  family = gpd,
  th = -Inf,
  qu,
  ...,
  penalty = NULL,
  prior = "gaussian",
  method = "optimize",
  cov = "observed",
  start = NULL,
  priorParameters = NULL,
  maxit = 10000,
  trace = NULL,
  iter = 40500,
  burn = 500,
  thin = 4,
  chains = 1,
  proposal.dist = c("gaussian", "cauchy"),
  jump.cov,
  jump.const = NULL,
  R = 1000,
  cores = NULL,
  export = NULL,
  verbose = TRUE,
  call = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Either a numeric vector, the name of a variable in <code>data</code>
or a string representing the name of a
variable in <code>data</code>. NOTE THAT the use of non-standard evaluation is
likely to be removed from future versions of texmex.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame containing <code>y</code> and any covariates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>In <code>evm</code>, formulae for the parameters in the family, e.g.
<code>phi = ~ x</code>. If none are specified, they all default to <code>~1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>An object of class 'texmexFamily'. Defaults to
<code>family=gpd</code> and a generalized Pareto distribution (GPD) is fit to the data.
Alternatively the family could be <code>gev</code>, <code>weibull</code> or
<code>gumbel</code>, resulting in a generalized extreme value distribution, Weibull
or Gumbell distribution being fit. Family <code>cgpd</code> fits the generalized
Pareto distribution but with the shape parameter constrained to be
&gt; 0.5 by using the link function suggested by Yee and Stephenson (2007),
<code class="reqn">\eta</code> = log(<code class="reqn">\xi</code> + 0.5). Family <code>egp3</code> fits the extended
GP family 3 of Papastathopoulos and Tawn (2013). No other families are currently
available in texmex, but users may write their own.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>th</code></td>
<td>
<p>For threshold excess models (such as when <code>family=gpd</code>), the
threshold for <code>y</code>, exceedances above which will be used to fit the
upper tail model. Note that if you have already thresholded your data and
want to model all of <code>y</code>, you still need to specify <code>th</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qu</code></td>
<td>
<p>An alternative to <code>th</code>, a probability defined such that
<code>quantile(y,qu)</code> equals <code>th</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>How to penalize the likelhood. Currently, either "none"",
"gaussian"" or "lasso"" are the only allowed values. If <code>penalty</code> is
"gaussian" or "lasso" then the parameters for the penalization are specified
through the <code>priorParameters</code> argument. See below. Defaults to
<code>penalty=NULL</code> and applies maximum likelihood estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>If <code>method = "optimize"</code>, just an alternative way of
specifying the penalty, and only one or neither of <code>penalty</code> and
<code>prior</code> should be given. If <code>method = "simulate"</code>, prior must be
"gaussian" because no other prior distributions have been implemented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Should be either "optimize" (the default), "simulate" or
"bootstrap".  The first letter or various abbreviations will do. If
'optimize' is used, the (penalized) likelihood is directly optimized using
<code>optim</code> and point estimates (either ML or MAP estimates) are returned
with other information. If "simulate", a Metropolis algorithm is used to
simulate from the joint posterior distribution of the parameters. If
"bootstrap", a parametric boostrap is performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>How to compute the covariance matrix of the parameters. Defaults
to <code>cov = "observed"</code> in which case the observed information matrix is
used, if the <code>info</code> element of the <code>texmexFamily</code> object is
present. Note that currently, this is not implemented for <code>gev</code>.
Alternatives are <code>cov = "numeric"</code> in which case a numerical
approximation of the Hessian is used (see the help for <code>optim</code>), or
<code>cov = "sandwich"</code> if the <code>sandwich</code> element of the
<code>texmexFamily</code> object is implemented.  The <code>cov = "sandwich"</code>
method implements the Huber sandwich correction to the covariance matrix for
data which are not independent and in which case the likelihood function no
longer has the interpretation of a joint likelihood, but instead should be
interpreted as a pseudo-likelihod.
</p>
<p>In some cases, particularly with small samples, the numerical approximation
can be quite different from the closed form (<code>cov="observed"</code>) result,
and the value derived from the observed information should be preferred.
However, in either case, since the underlying log-likelihood may be far from
quadratic for small samples, the resulting estimates of standard errors are
liable to approximate poorly the true standard errors. Also see the comments
in the Details section, below.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Starting values for the parameters, to be passed to
<code>optim</code>.  If not provided, the function will use the <code>start</code>
element of the <code>texmexFamily</code> object if it exists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorParameters</code></td>
<td>
<p>A list with two components. The first should be a
vector of means, the second should be a covariance matrix if the
penalty/prior is "gaussian" or "quadratic" and a diagonal precision matrix
if the penalty/prior is "lasso", "L1" or "Laplace".  If <code>method =
"simulate"</code> then these represent the parameters in the Gaussian prior
distribution.  If <code>method = 'optimize'</code> then these represent the
parameters in the penalty function.  If not supplied: all default prior
means are zero; all default prior variances are <code class="reqn">10^4</code>; all covariances
are zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>
<p>The number of iterations allowed in <code>optim</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
<p>Whether or not to print progress to screen. If <code>method =
"optimize"</code>, the argument is passed into <code>optim</code> – see the help for
that function. If <code>method = "simulate"</code>, the argument determines at how
many steps of the Markov chain the function should tell the user, and in
this case it defaults to <code>trace = 10000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter</code></td>
<td>
<p>Number of simulations to generate under <code>method =
"simulate"</code>.  Defaults to 40500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>The number of initial steps to be discarded. Defaults to 500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The degree of thinning of the resulting Markov chains. Defaults
to 4 (one in every 4 steps is retained).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chains</code></td>
<td>
<p>The number of Markov chains to run. Defaults to 1. If you run
more than 1, the function tries to figure out how to do it in parallel
using as many cores as there are chains.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>proposal.dist</code></td>
<td>
<p>The proposal distribution to use, either multivariate
gaussian or a multivariate Cauchy.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jump.cov</code></td>
<td>
<p>Covariance matrix for proposal distribution of Metropolis
algorithm.  This is scaled by <code>jump.const</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jump.const</code></td>
<td>
<p>Control parameter for the Metropolis algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>The number of parametric bootstrap samples to run when <code>method
= "bootstrap"</code> is requested. Defaults to 1000.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>The number of cores to use when bootstrapping. Defaults to
<code>cores=NULL</code> and the function guesses how many cores are available and
uses them all.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>export</code></td>
<td>
<p>Character vector of names of objects to export if parallel
processing is being used and you are using objects from outside of
texmex. It it passed to <code>parallel::clusterExport</code> and used by
<code>texmex::evmBoot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Whether or not to print progress to screen. Defaults to
<code>verbose=TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>Used internally, defaults to <code>call = NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The main modelling function is <code>evm</code> (extreme value model) and the
distribution to be used is specified by passing an object of class
<code>texmexFamily</code> to the <code>family</code> argument.
</p>
<p>The default <code>texmexFamily</code> object used by <code>evm</code> is <code>gpd</code>.
Currently, the other <code>texmexFamily</code> objects available are <code>gev</code>
which results in fitting a generalized extreme value (GEV) distribution to
the data, <code>gpdIntCensored</code> which can be used to fit the GPD to data which has
been rounded to a given number of decimal places by recognisiing the data as
interval censored, and <code>egp3</code> which fits the extended generalized Pareto
distribution version 3 of Papastathopoulos and Tawn (2013).
</p>
<p>See Coles (2001) for an introduction to extreme value modelling and the GPD
and GEV models.
</p>
<p>For the GPD model, we use the following parameterisation of evm:
</p>
<p style="text-align: center;"><code class="reqn">P(Y \le y) = 1 - (1 + \xi y / \sigma)^{-1/\xi}</code>
</p>

<p>for <code class="reqn">y \ge 0</code> and <code class="reqn">1 + \xi y / \sigma \ge 0.</code>
</p>
<p>For the GEV model, we use:
</p>
<p style="text-align: center;"><code class="reqn">P(Y \le y) = exp (-(1 + \xi (y - \mu) / \sigma) ^{-1/\xi})</code>
</p>

<p>In each case, the scale parameter is sigma (<code class="reqn">\sigma</code>) and the shape
parameter is xi (<code class="reqn">\xi</code>). The GEV distribution also has location
parameter mu (<code class="reqn">\mu</code>). See Papastathopoulos and Tawn (2013) for
specification of the EGP3 model.
</p>
<p>Working with the log of the scale parameter improves the stability of
computations, makes a quadratic penalty more appropriate and enables the
inclusion of covariates in the model for the scale parameter, which must
remain positive.  We therefore work with <code class="reqn">\phi</code>=log(<code class="reqn">\sigma</code>).  All
specification of priors or penalty functions refer to <code class="reqn">\phi</code> rather than
<code class="reqn">\sigma</code>.  A quadratic penalty can be thought of as a Gaussian prior
distribution, whence the terminology of the function.
</p>
<p>Parameters of the evm are estimated by using maximum (penalized) likelihood
(<code>method = "optimize"</code>), or by simulating from the posterior
distribution of the model parameters using a Metropolis algorithm
(<code>method = "simulate"</code>).  In the latter case, <code>start</code> is used as a
starting value for the Metropolis algorithm; in its absence, the maximum
penalized likelhood point estimates are computed and used.
</p>
<p>A boostrap approach is also available (<code>method = "bootstrap"</code>).  This
runs a parametric bootstrap, simulating from the model fit by optimization.
</p>
<p>When <code>method = "simulate"</code> the <code>print</code> and <code>summary</code>
functions give posterior means and standard deviations. Posterior means are
also returned by the <code>coef</code> method. Depending on what you want to do
and what the posterior distributions look like (use <code>plot</code> method) you
might want to work with quantiles of the posterior distributions instead of
relying on standard errors.
</p>
<p>When <code>method = "bootstrap"</code>, summaries of the bootstrap distribution
and the bootstrap estimate of bias are displayed.
</p>


<h3>Value</h3>

<p>If <code>method = "optimize"</code>, an object of class <code>evmOpt</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call to <code>evmSim</code> that produced the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>The original data (above and below the threshold for fitting if
a distribution for threshold excesses has been used). In detail, <code>data</code>
is a list with elements <code>y</code> and <code>D</code>. <code>y</code> is the response
variable and <code>D</code> is a list containing the design matrices implied by
any formlae used in the call to <code>evm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>Output from
<code>optim</code> relating to whether or not the optimizer converged.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A message telling the user whether or not convergence was
achieved.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The threshold of the data above which the evmSim
model was fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>penalty</code></td>
<td>
<p>The type of penalty function used, if any.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coefficients</code></td>
<td>
<p>The parameter estimates as computed under maximum
likelihood or maximum penalized likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rate</code></td>
<td>
<p>The proportion of
observations above the threshold. If the model is not a threshold exceedance
model (e.g. the GEV model), the rate will be 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priorParameters</code></td>
<td>
<p>See above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>Residuals computed using the residual function in the
<code>texmexFamily</code> object, if any. These are used primarly for producing
QQ and PP plots via <code>plot.evmOpt</code> or <code>ggplot.evmOpt</code>.
The residuals are transformed values of the raw data, accounting for the
parameter estimates: see the <code>residuals</code> component of the
<code>texmexFamily</code> object for the calculations. For the generalized
Pareto family, they are (if the model fits well) standard exponential variates;
for the GEV family, standard Gumbel variates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ploglik</code></td>
<td>
<p>The value of the
optimized penalized log-likelihood.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglik</code></td>
<td>
<p>The value of the
optimized (unpenalized) log-likelihood. If <code>penalty='none'</code> is used,
this will be identical to <code>ploglik</code>, above.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cov</code></td>
<td>
<p>The estimated
covariance of the parameters in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>The estimated standard
errors of the parameters in the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xlevels</code></td>
<td>
<p>A named list
containing a named list for each design matrix (main parameter) in the
model. Each list contians an element named after each factor in the linear
predictor for the respective design matrix. These are used by the
<code>predict</code> method to ensure all factor levels are known, even if they
don't appear in <code>newdata</code>.</p>
</td>
</tr>
</table>
<p>If <code>method = "simulate"</code>, an object of class <code>evmSim</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call to <code>evmSim</code> that produced the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>The threshold above which the model was fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>The point estimates found by maximum penalized likelihood and
which were used as the starting point for the Markov chain.  This is of
class <code>evmOpt</code> and methods for this class (such as resid and plot) may
be useful.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burn</code></td>
<td>
<p>The number of steps of the Markov chain that are to
be treated as the burn-in and not used in inferences.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thin</code></td>
<td>
<p>The
degree of thinning used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chains</code></td>
<td>
<p>The entire Markov chain generated by
the Metropolis algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>The response data above the threshold
for fitting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>The seed used by the random number generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>The remainder of the chain after deleting the burn-in and
applying any thinning.</p>
</td>
</tr>
</table>
<p>If <code>method = "bootstrap"</code>, an object of class <code>evmBoot</code>:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call to <code>evmBoot</code> that produced the object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replicates</code></td>
<td>
<p>The parameter estimates from the bootstrap fits.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>map</code></td>
<td>
<p>The fit by by maximum penalized likelihood to the orginal data.
This is of class <code>evmOpt</code> and methods for this class (such as resid and
plot) may be useful.</p>
</td>
</tr>
</table>
<p>There are summary, plot, print, residuals and coefficients methods available for these
classes.
</p>


<h3>Note</h3>

<p>For both GPD and GEV models, when there are estimated values of
<code class="reqn">\xi \le -0.5</code>, the regularity conditions of the likelihood break down
and inference based on approximate standard errors cannot be performed. In
this case, the most fruitful approach to inference appears to be by the
bootstrap. It might be possible to simulate from the posterior, but finding
a good proposal distribution might be difficult and you should take care to
get an acceptance rate that is reasonably high (around 40% when there are
no covariates, lower otherwise). To constrain the parameter space of the GP
shape parameter, use <code>family = cgpd</code> in the call to <code>evm</code> and
the transformation <code class="reqn">\eta</code> = log(<code class="reqn">\xi</code> + 0.5) is used, as suggested
by Yee and Stephenson (2007).
</p>


<h3>Author(s)</h3>

<p>Janet E. Heffernan, Harry Southworth. Some of the internal code is
based on the <code>gpd.fit</code> function in the <code>ismev</code> package and is due
to Stuart Coles.
</p>


<h3>References</h3>

<p>S. Coles. An Introduction to Statistical Modelling of Extreme
Values. Springer, 2001.
</p>
<p>I. Papastathopoulos and J. A. Tawn, Extended generalised Pareto models for
tail estimation, Journal of Statistical Planning and Inference, 143, 131 -
143, 2013.
</p>
<p>T. W. Yee and A. G. Stephenson, Vector generalized linear and additive
extreme value models, Extremes, 10, 1 – 19, 2007.
</p>


<h3>See Also</h3>

<p><code>plot.evmOpt</code> <code>ggplot.evmOpt</code> <code>rl.evmOpt</code>, <code>predict.evmOpt</code>,
<code>evm.declustered</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  
  #mod &lt;- evm(rain, th=30)
  #mod
  #par(mfrow=c(2, 2))
  #plot(mod)
  

  
  mod &lt;- evm(rain, th=30, method="sim")
  par(mfrow=c(3, 2))
  plot(mod)
  

  
  mod &lt;- evm(SeaLevel, data=portpirie, family=gev)
  mod
  plot(mod)
  

  
  mod &lt;- evm(SeaLevel, data=portpirie, family=gev, method="sim")
  par(mfrow=c(3, 3))
  plot(mod)
  


</code></pre>


</div>