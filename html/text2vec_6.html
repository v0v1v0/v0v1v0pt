<div class="container">

<table style="width: 100%;"><tr>
<td>coherence</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Coherence metrics for topic models</h2>

<h3>Description</h3>

<p>Given a topic model with topics represented as ordered term lists, the coherence may be used to assess the quality of individual topics.
This function is an implementation of several of the numerous possible metrics for such kind of assessments.
Coherence calculation is sensitive to the content of the reference <code>tcm</code> that is used for evaluation
and that may be created with different parameter settings. Please refer to the details section (or reference section) for information
on typical combinations of metric and type of <code>tcm</code>. For more general information on measuring coherence
a starting point is given in the reference section.
</p>


<h3>Usage</h3>

<pre><code class="language-R">coherence(x, tcm, metrics = c("mean_logratio", "mean_pmi", "mean_npmi",
  "mean_difference", "mean_npmi_cosim", "mean_npmi_cosim2"),
  smooth = 1e-12, n_doc_tcm = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>character matrix</code> with the top terms per topic (each column represents one topic),
e.g., as created by <code>get_top_words()</code>.
Terms of <code>x</code> have to be ranked per topic starting with rank 1 in row 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tcm</code></td>
<td>
<p>The term co-occurrence matrix, e.g, a <code>Matrix::sparseMatrix</code> or <code>base::matrix</code>,
serving as the reference to calculate coherence metrics.
Please note that a memory efficient version of the <code>tcm</code> is assumed as input
with all entries in the lower triangle (excluding diagonal) set to zero (see, e.g., <code>create_tcm</code>).
Please also note that some efforts during any pre-processing steps might be skipped since the <code>tcm</code>
is internally reduced to the top word space, i.e., all unique terms of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metrics</code></td>
<td>
<p>Character vector specifying the metrics to be calculated. Currently the following metrics are implemented:
<code>c("mean_logratio", "mean_pmi", "mean_npmi", "mean_difference", "mean_npmi_cosim", "mean_npmi_cosim2")</code>.
Please refer to the details section for more information on the metrics.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>Numeric smoothing constant to avoid logarithm of zero. By default, set to <code>1e-12</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_doc_tcm</code></td>
<td>
<p>The <code>integer</code> number of documents or text windows that was used to create the <code>tcm</code>.
<code>n_doc_tcm</code> is used to calculate term probabilities from term counts as required for several metrics.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The currently implemented coherence <code>metrics</code> are described below including a description of the
content type of the <code>tcm</code> that showed good performance in combination with a specific metric.  <br>
For details on how to create <code>tcm</code> see the example section.  <br>
For details on performance of metrics see the resources in the reference section
that served for definition of standard settings for individual metrics.  <br>
Note that depending on the use case, still, different settings than the standard settings for creation of <code>tcm</code> may be reasonable.  <br>
Note that for all currently implemented metrics the <code>tcm</code> is reduced to the top word space on basis of the terms in <code>x</code>.
</p>
<p>Considering the use case of finding the optimum number of topics among several models with different metrics,
calculating the mean score over all topics and normalizing this mean coherence scores from different metrics
might be considered for direct comparison.
</p>
<p>Each metric usually opts for a different optimum number of topics. From initial experience it may be assumed
that logratio, pmi and nmpi usually opt for smaller numbers, whereas the other metrics rather tend to propose higher numbers.
</p>
<p>Implemented metrics:
</p>

<ul>
<li>
<p> "mean_logratio"  <br>
The logarithmic ratio is calculated as <br><code>log(smooth + tcm[x,y]) - log(tcm[y,y])</code>,  <br>
where x and y are term index pairs from a "preceding" term index combination.  <br>
Given the indices c(1,2,3), combinations are <code>list(c(2,1), c(3,1), c(3,2))</code>.  <br><br>
The <code>tcm</code> should represent the boolean term co-occurrence (internally the actual counts are used)
in the original documents and, therefore, is an intrinsic metric in the standard use case.  <br><br>
This metric is similar to the UMass metric, however, with a smaller smoothing constant by default
and using the mean for aggregation instead of the sum.  <br></p>
</li>
<li>
<p> "mean_pmi" <br>
The pointwise mutual information is calculated as  <br><code>log2((tcm[x,y]/n_doc_tcm) + smooth) - log2(tcm[x,x]/n_doc_tcm) - log2(tcm[y,y]/n_doc_tcm)</code>,  <br>
where x and y are term index pairs from an arbitrary term index combination  <br>
that subsets the lower or upper triangle of <code>tcm</code>, e.g. "preceding".  <br><br>
The <code>tcm</code> should represent term co-occurrences within a boolean sliding window of size <code>10</code> (internally probabilities are used)
in an external reference corpus and, therefore, is an extrinsic metric in the standard use case.  <br><br>
This metric is similar to the UCI metric, however, with a smaller smoothing constant by default
and using the mean for aggregation instead of the sum.
</p>
</li>
<li>
<p> "mean_npmi" <br>
Similar (in terms of all parameter settings, etc.) to "mean_pmi" metric
but using the normalized pmi instead, which is calculated as <br><code>(log2((tcm[x,y]/n_doc_tcm) + smooth) - log2(tcm[x,x]/n_doc_tcm) - log2(tcm[y,y]/n_doc_tcm)) / -log2((tcm[x,y]/n_doc_tcm) + smooth)</code>,  <br><br>
This metric may perform better than the simpler pmi metric.
</p>
</li>
<li>
<p> "mean_difference" <br>
The difference is calculated as  <br><code>tcm[x,y]/tcm[x,x] - (tcm[y,y]/n_tcm_windows)</code>,  <br>
where x and y are term index pairs from a "preceding" term index combination.  <br>
Given the indices c(1,2,3), combinations are <code>list(c(1,2), c(1,3), c(2,3))</code>.  <br><br>
The <code>tcm</code> should represent the boolean term co-occurrence (internally probabilities are used)
in the original documents and, therefore, is an intrinsic metric in the standard use case.
</p>
</li>
<li>
<p> "mean_npmi_cosim" <br>
First, the npmi of an individual top word with each of the top words is calculated as in "mean_npmi". <br>
This result in a vector of npmi values for each top word. <br>
On this basis, the cosine similarity between each pair of vectors is calculated. <br><br>
The <code>tcm</code> should represent term co-occurrences within a boolean sliding window of size <code>5</code> (internally probabilities are used)
in an external reference corpus and, therefore, is an extrinsic metric in the standard use case.  <br></p>
</li>
<li>
<p> "mean_npmi_cosim2" <br>
First, a vector of npmi values for each top word is calculated as in "mean_npmi_cosim". <br>
On this basis, the cosine similarity between each vector and the sum of all vectors is calculated
(instead of the similarity between each pair). <br><br>
The <code>tcm</code> should represent term co-occurrences within a boolean sliding window of size <code>110</code> (internally probabilities are used)
in an external reference corpus and, therefore, is an extrinsic metric in the standard use case.  <br></p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>numeric matrix</code> with the coherence scores of the specified <code>metrics</code> per topic.
</p>


<h3>References</h3>

<p>Below mentioned paper is the main theoretical basis for this code. <br>
Currently only a selection of metrics stated in this paper is included in this R implementation. <br>
Authors: Roeder, Michael; Both, Andreas; Hinneburg, Alexander (2015) <br>
Title: Exploring the Space of Topic Coherence Measures. <br>
In: Xueqi Cheng, Hang Li, Evgeniy Gabrilovich und Jie Tang (Eds.): <br>
Proceedings of the Eighth ACM International Conference on Web Search and Data Mining - WSDM '15. <br>
the Eighth ACM International Conference. Shanghai, China, 02.02.2015 - 06.02.2015. <br>
New York, USA: ACM Press, p. 399-408. <br>
https://dl.acm.org/citation.cfm?id=2685324 <br>
This paper has been implemented by above listed authors as the Java program "palmetto". <br>
See https://github.com/dice-group/Palmetto or http://aksw.org/Projects/Palmetto.html.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(data.table)
library(text2vec)
library(Matrix)
data("movie_review")
N = 500
tokens = word_tokenizer(tolower(movie_review$review[1:N]))
it = itoken(tokens, progressbar = FALSE)
v = create_vocabulary(it)
v = prune_vocabulary(v, term_count_min = 5, doc_proportion_max = 0.2)
dtm = create_dtm(it, vocab_vectorizer(v))

n_topics = 10
lda_model = LDA$new(n_topics)
fitted = lda_model$fit_transform(dtm, n_iter = 20)
tw = lda_model$get_top_words(n = 10, lambda = 1)

# for demonstration purposes create intrinsic TCM from original documents
# scores might not make sense for metrics that are designed for extrinsic TCM
tcm = crossprod(sign(dtm))

# check coherence
logger = lgr::get_logger('text2vec')
logger$set_threshold('debug')
res = coherence(tw, tcm, n_doc_tcm = N)
res

# example how to create TCM for extrinsic measures from an external corpus
external_reference_corpus = tolower(movie_review$review[501:1000])
tokens_ext = word_tokenizer(external_reference_corpus)
iterator_ext = itoken(tokens_ext, progressbar = FALSE)
v_ext = create_vocabulary(iterator_ext)
# for reasons of efficiency vocabulary may be reduced to the terms matched in the original corpus
v_ext= v_ext[v_ext$term %in% v$term, ]
# external vocabulary may be pruned depending on the use case
v_ext = prune_vocabulary(v_ext, term_count_min = 5, doc_proportion_max = 0.2)
vectorizer_ext = vocab_vectorizer(v_ext)

# for demonstration purposes a boolean co-occurrence within sliding window of size 10 is used
# 10 represents sentence co-occurrence, a size of 110 would, e.g., be paragraph co-occurrence
window_size = 5

tcm_ext = create_tcm(iterator_ext, vectorizer_ext
                      ,skip_grams_window = window_size
                      ,weights = rep(1, window_size)
                      ,binary_cooccurence = TRUE
                     )
#add marginal probabilities in diagonal (by default only upper triangle of tcm is created)
diag(tcm_ext) = attributes(tcm_ext)$word_count

# get number of sliding windows that serve as virtual documents, i.e. n_doc_tcm argument
n_skip_gram_windows = sum(sapply(tokens_ext, function(x) {length(x)}))

## End(Not run)
</code></pre>


</div>