<div class="container">

<table style="width: 100%;"><tr>
<td>morphers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions to generate alternate representations of graphs</h2>

<h3>Description</h3>

<p>These functions are meant to be passed into <code>morph()</code> to create a temporary
alternate representation of the input graph. They are thus not meant to be
called directly. See below for detail of each morpher.
</p>


<h3>Usage</h3>

<pre><code class="language-R">to_linegraph(graph)

to_subgraph(graph, ..., subset_by = NULL)

to_subcomponent(graph, node)

to_split(graph, ..., split_by = NULL)

to_components(graph, type = "weak", min_order = 1)

to_largest_component(graph, type = "weak")

to_complement(graph, loops = FALSE)

to_local_neighborhood(graph, node, order = 1, mode = "all")

to_dominator_tree(graph, root, mode = "out")

to_minimum_spanning_tree(graph, weights = NULL)

to_random_spanning_tree(graph)

to_shortest_path(graph, from, to, mode = "out", weights = NULL)

to_bfs_tree(graph, root, mode = "out", unreachable = FALSE)

to_dfs_tree(graph, root, mode = "out", unreachable = FALSE)

to_simple(graph, remove_multiples = TRUE, remove_loops = TRUE)

to_contracted(graph, ..., simplify = TRUE)

to_unfolded_tree(graph, root, mode = "out")

to_directed(graph)

to_undirected(graph)

to_hierarchical_clusters(graph, method = "walktrap", weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>A <code>tbl_graph</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments to pass on to <code>filter()</code>, <code>group_by()</code>, or the cluster
algorithm (see <code>igraph::cluster_walktrap()</code>, <code>igraph::cluster_leading_eigen()</code>,
and <code>igraph::cluster_edge_betweenness()</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset_by, split_by</code></td>
<td>
<p>Whether to create subgraphs based on nodes or edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>node</code></td>
<td>
<p>The center of the neighborhood for <code>to_local_neighborhood()</code> and
the node to that should be included in the component for <code>to_subcomponent()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of component to split into. Either <code>'weak'</code> or <code>'strong'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_order</code></td>
<td>
<p>The minimum order (number of vertices) of the component.
Components below this will not be created</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loops</code></td>
<td>
<p>Should loops be included. Defaults to <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>The radius of the neighborhood</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>How should edges be followed? <code>'out'</code> only follows outbound
edges, <code>'in'</code> only follows inbound edges, and <code>'all'</code> follows all edges. This
parameter is ignored for undirected graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>The root of the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional edge weights for the calculations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from, to</code></td>
<td>
<p>The start and end node of the path</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unreachable</code></td>
<td>
<p>Should the search jump to a node in a new component when
stuck.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_multiples</code></td>
<td>
<p>Should edges that run between the same nodes be
reduced to one</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_loops</code></td>
<td>
<p>Should edges that start and end at the same node be removed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simplify</code></td>
<td>
<p>Should edges in the contracted graph be simplified? Defaults
to <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The clustering method to use. Either <code>'walktrap'</code>, <code>'leading_eigen'</code>, or <code>'edge_betweenness'</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list of <code>tbl_graph</code>s
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>to_linegraph()</code>: Convert a graph to its line graph. When unmorphing node
data will be merged back into the original edge data. Edge data will be
ignored.
</p>
</li>
<li> <p><code>to_subgraph()</code>: Convert a graph to a single subgraph. <code>...</code> is evaluated
in the same manner as <code>filter</code>. When unmorphing all data in the subgraph
will get merged back.
</p>
</li>
<li> <p><code>to_subcomponent()</code>: Convert a graph to a single component containing the specified node
</p>
</li>
<li> <p><code>to_split()</code>: Convert a graph into a list of separate subgraphs. <code>...</code>
is evaluated in the same manner as <code>group_by</code>. When unmorphing all data in
the subgraphs will get merged back, but in the case of <code>split_by = 'edges'</code>
only the first instance of node data will be used (as the same node can be
present in multiple subgraphs).
</p>
</li>
<li> <p><code>to_components()</code>: Split a graph into its separate components. When
unmorphing all data in the subgraphs will get merged back.
</p>
</li>
<li> <p><code>to_largest_component()</code>: Create a new graph only consisting of it's largest
component. If multiple largest components exists, the one with containing the
node with the lowest index is chosen.
</p>
</li>
<li> <p><code>to_complement()</code>: Convert a graph into its complement. When unmorphing
only node data will get merged back.
</p>
</li>
<li> <p><code>to_local_neighborhood()</code>: Convert a graph into the local neighborhood around a
single node. When unmorphing all data will be merged back.
</p>
</li>
<li> <p><code>to_dominator_tree()</code>: Convert a graph into its dominator tree based on a
specific root. When unmorphing only node data will get merged back.
</p>
</li>
<li> <p><code>to_minimum_spanning_tree()</code>: Convert a graph into its minimum spanning tree/forest.
When unmorphing all data will get merged back.
</p>
</li>
<li> <p><code>to_random_spanning_tree()</code>: Convert a graph into a random spanning tree/forest. When
unmorphing all data will get merged back
</p>
</li>
<li> <p><code>to_shortest_path()</code>: Limit a graph to the shortest path between two nodes.
When unmorphing all data is merged back.
</p>
</li>
<li> <p><code>to_bfs_tree()</code>: Convert a graph into a breath-first search tree based on
a specific root. When unmorphing only node data is merged back.
</p>
</li>
<li> <p><code>to_dfs_tree()</code>: Convert a graph into a depth-first search tree based on
a specific root. When unmorphing only node data is merged back.
</p>
</li>
<li> <p><code>to_simple()</code>: Collapse parallel edges and remove loops in a graph.
When unmorphing all data will get merged back
</p>
</li>
<li> <p><code>to_contracted()</code>: Combine multiple nodes into one. <code>...</code>
is evaluated in the same manner as <code>group_by</code>. When unmorphing all
data will get merged back.
</p>
</li>
<li> <p><code>to_unfolded_tree()</code>: Unfold a graph to a tree or forest starting from
multiple roots (or one), potentially duplicating nodes and edges.
</p>
</li>
<li> <p><code>to_directed()</code>: Make a graph directed in the direction given by from and
to
</p>
</li>
<li> <p><code>to_undirected()</code>: Make a graph undirected
</p>
</li>
<li> <p><code>to_hierarchical_clusters()</code>: Convert a graph into a hierarchical clustering based on a grouping
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Compute only on a subgraph of every even node
create_notable('meredith') %&gt;%
  morph(to_subgraph, seq_len(graph_order()) %% 2 == 0) %&gt;%
  mutate(neighbour_count = centrality_degree()) %&gt;%
  unmorph()
</code></pre>


</div>