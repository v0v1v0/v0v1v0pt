<div class="container">

<table style="width: 100%;"><tr>
<td>diagram_mds</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dimension reduction of a group of persistence diagrams via metric multidimensional scaling.</h2>

<h3>Description</h3>

<p>Projects a group of persistence diagrams (or a precomputed distance matrix of diagrams) into a low-dimensional 
embedding space via metric multidimensional scaling. Such a projection can be used for visualization of data, 
or a static analysis of the embedding dimensions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">diagram_mds(
  diagrams,
  D = NULL,
  k = 2,
  distance = "wasserstein",
  dim = 0,
  p = 2,
  sigma = NULL,
  rho = NULL,
  eig = FALSE,
  add = FALSE,
  x.ret = FALSE,
  list. = eig || add || x.ret,
  num_workers = parallelly::availableCores(omit = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>diagrams</code></td>
<td>
<p>a list of n&gt;=2 persistence diagrams which are either the output of a persistent homology calculation like ripsDiag/<code>calculate_homology</code>/<code>PyH</code>, or <code>diagram_to_df</code>. Only one of 'diagrams' and 'D' need to be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>an optional precomputed distance matrix of persistence diagrams, default NULL. If not NULL then 'diagrams' parameter does not need to be supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>the dimension of the space which the data are to be represented in; must be in {1,2,...,n-1}.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance</code></td>
<td>
<p>a string representing the desired distance metric to be used, either 'wasserstein' (default) or 'fisher'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>the non-negative integer homological dimension in which the distance is to be computed, default 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>a positive number representing the wasserstein power, a number at least 1 (infinity for the bottleneck distance), default 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>a positive number representing the bandwidth for the Fisher information metric, default NULL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>an optional positive number representing the heuristic for Fisher information metric approximation, see <code>diagram_distance</code>. Default NULL. If supplied, distance matrix calculation is sequential.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eig</code></td>
<td>
<p>a boolean indicating whether the eigenvalues should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add</code></td>
<td>
<p>a boolean indicating if an additive constant c* should be computed, and added to the non-diagonal dissimilarities such that the modified dissimilarities are Euclidean.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x.ret</code></td>
<td>
<p>a boolean indicating whether the doubly centered symmetric distance matrix should be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list.</code></td>
<td>
<p>a boolean indicating if a list should be returned or just the n*k matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_workers</code></td>
<td>
<p>the number of cores used for parallel computation, default is one less than the number of cores on the machine.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Returns the output of <code>cmdscale</code> on the desired distance matrix of a group of persistence diagrams
in a particular dimension. If 'distance' is "fisher" then 'sigma' must not be NULL.
</p>


<h3>Value</h3>

<p>the output of <code>cmdscale</code> on the diagram distance matrix. If 'list.' is false (as per default),
a matrix with 'k' columns whose rows give the coordinates of the points chosen to represent the dissimilarities.
</p>
<p>Otherwise, a list containing the following components.
</p>

<dl>
<dt>points</dt>
<dd>
<p>a matrix with 'k' columns whose rows give the coordinates of the points chosen to represent the dissimilarities.</p>
</dd>
<dt>eig</dt>
<dd>
<p>the <code class="reqn">n</code> eigenvalues computed during the scaling process if 'eig' is true.</p>
</dd>
<dt>x</dt>
<dd>
<p>the doubly centered distance matrix if 'x.ret' is true.</p>
</dd>
<dt>ac</dt>
<dd>
<p>the additive constant <code class="reqn">c*</code>, 0 if 'add' = FALSE.</p>
</dd>
<dt>GOF</dt>
<dd>
<p>the numeric vector of length 2, representing the sum of all the eigenvalues divided by the sum of their absolute values (first vector element) or by the sum of the max of each eigenvalue and 0 (second vector element).</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>References</h3>

<p>Cox M and Cox F (2008). "Multidimensional Scaling." doi: <a href="https://doi.org/10.1007/978-3-540-33037-0_14">10.1007/978-3-540-33037-0_14</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
if(require("TDAstats"))
{
  # create two diagrams
  D1 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                      dim = 1,threshold = 2)
  D2 &lt;- TDAstats::calculate_homology(TDAstats::circle2d[sample(1:100,10),],
                      dim = 1,threshold = 2)
  g &lt;- list(D1,D2)

  # calculate their 1D MDS embedding in dimension 0 with the bottleneck distance
  mds &lt;- diagram_mds(diagrams = g,k = 1,dim = 0,p = Inf,num_workers = 2)
  
  # repeat but with a precomputed distance matrix, gives same result just much faster
  Dmat &lt;- distance_matrix(diagrams = list(D1,D2),dim = 0,p = Inf,num_workers = 2)
  mds &lt;- diagram_mds(D = Dmat,k = 1)
  
}
</code></pre>


</div>