<div class="container">

<table style="width: 100%;"><tr>
<td>sparse_term_matrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Term matrices and statistics ( document-term-matrix, term-document-matrix)</h2>

<h3>Description</h3>

<p>Term matrices and statistics ( document-term-matrix, term-document-matrix)
</p>
<p>Term matrices and statistics ( document-term-matrix, term-document-matrix)
</p>


<h3>Usage</h3>

<pre><code class="language-R"># utl &lt;- sparse_term_matrix$new(vector_data = NULL, file_data = NULL,

#                                      document_term_matrix = TRUE)
</code></pre>


<h3>Details</h3>

<p>the <em>Term_Matrix</em> function takes either a character vector of strings or a text file and after tokenization and transformation returns either a document-term-matrix or a term-document-matrix
</p>
<p>the <em>triplet_data</em> function returns the triplet data, which is used internally (in c++), to construct the Term Matrix. The triplet data could be usefull for secondary purposes, such as in word vector representations.
</p>
<p>the <em>global_term_weights</em> function returns a list of length two. The first sublist includes the <em>terms</em> and the second sublist the <em>global-term-weights</em>. The <em>tf_idf</em> parameter should be set to FALSE and the <em>normalize</em> parameter to NULL. This function is normally used in conjuction with word-vector-embeddings.
</p>
<p>the <em>Term_Matrix_Adjust</em> function removes sparse terms from a sparse matrix using a sparsity threshold
</p>
<p>the <em>term_associations</em> function finds the associations between the given terms (Terms argument) and all the other terms in the corpus by calculating their correlation. There is also the option to keep a specific number of terms from the output table using the <em>keep_terms</em> parameter.
</p>
<p>the <em>most_frequent_terms</em> function returns the most frequent terms of the corpus using the output of the sparse matrix. The user has the option to keep a specific number of terms from the output table using the <em>keep_terms</em> parameter.
</p>
<p>Stemming of the english language is done using the porter2-stemmer, for details see <a href="https://github.com/smassung/porter2_stemmer">https://github.com/smassung/porter2_stemmer</a>
</p>


<h3>Methods</h3>


<dl>
<dt><code>sparse_term_matrix$new(vector_data = NULL, file_data = NULL, document_term_matrix = TRUE)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>Term_Matrix(sort_terms = FALSE, to_lower = FALSE, to_upper = FALSE, utf_locale = "", remove_char = "", remove_punctuation_string = FALSE, remove_punctuation_vector = FALSE, remove_numbers = FALSE, trim_token = FALSE, split_string = FALSE, split_separator = " .,;:()?!", remove_stopwords = FALSE, language = "english", min_num_char = 1, max_num_char = Inf, stemmer = NULL, min_n_gram = 1, max_n_gram = 1, skip_n_gram = 1, skip_distance = 0, n_gram_delimiter = " ", print_every_rows = 1000, normalize = NULL, tf_idf = FALSE, threads = 1, verbose = FALSE)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>triplet_data()</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>global_term_weights()</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>Term_Matrix_Adjust(sparsity_thresh = 1.0)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>term_associations(Terms = NULL, keep_terms = NULL, verbose = FALSE)</code></dt>
<dd></dd>
<dt><code>--------------</code></dt>
<dd></dd>
<dt><code>most_frequent_terms(keep_terms = NULL, threads = 1, verbose = FALSE)</code></dt>
<dd></dd>
</dl>
<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-sparse_term_matrix-new"><code>sparse_term_matrix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-sparse_term_matrix-Term_Matrix"><code>sparse_term_matrix$Term_Matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-sparse_term_matrix-triplet_data"><code>sparse_term_matrix$triplet_data()</code></a>
</p>
</li>
<li> <p><a href="#method-sparse_term_matrix-global_term_weights"><code>sparse_term_matrix$global_term_weights()</code></a>
</p>
</li>
<li> <p><a href="#method-sparse_term_matrix-Term_Matrix_Adjust"><code>sparse_term_matrix$Term_Matrix_Adjust()</code></a>
</p>
</li>
<li> <p><a href="#method-sparse_term_matrix-term_associations"><code>sparse_term_matrix$term_associations()</code></a>
</p>
</li>
<li> <p><a href="#method-sparse_term_matrix-most_frequent_terms"><code>sparse_term_matrix$most_frequent_terms()</code></a>
</p>
</li>
<li> <p><a href="#method-sparse_term_matrix-clone"><code>sparse_term_matrix$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-sparse_term_matrix-new"></a>



<h4>Method <code>new()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$new(
  vector_data = NULL,
  file_data = NULL,
  document_term_matrix = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>vector_data</code></dt>
<dd>
<p>either NULL or a character vector of documents</p>
</dd>
<dt><code>file_data</code></dt>
<dd>
<p>either NULL or a valid character path to a text file</p>
</dd>
<dt><code>document_term_matrix</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then a document-term-matrix will be returned, otherwise a term-document-matrix</p>
</dd>
</dl>
</div>


<hr>
<a id="method-sparse_term_matrix-Term_Matrix"></a>



<h4>Method <code>Term_Matrix()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$Term_Matrix(
  sort_terms = FALSE,
  to_lower = FALSE,
  to_upper = FALSE,
  utf_locale = "",
  remove_char = "",
  remove_punctuation_string = FALSE,
  remove_punctuation_vector = FALSE,
  remove_numbers = FALSE,
  trim_token = FALSE,
  split_string = FALSE,
  split_separator = " \r\n\t.,;:()?!//",
  remove_stopwords = FALSE,
  language = "english",
  min_num_char = 1,
  max_num_char = Inf,
  stemmer = NULL,
  min_n_gram = 1,
  max_n_gram = 1,
  skip_n_gram = 1,
  skip_distance = 0,
  n_gram_delimiter = " ",
  print_every_rows = 1000,
  normalize = NULL,
  tf_idf = FALSE,
  threads = 1,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sort_terms</code></dt>
<dd>
<p>either TRUE or FALSE specifying if the initial terms should be sorted ( so that the output sparse matrix is sorted in alphabetical order )</p>
</dd>
<dt><code>to_lower</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE the character string will be converted to lower case</p>
</dd>
<dt><code>to_upper</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE the character string will be converted to upper case</p>
</dd>
<dt><code>utf_locale</code></dt>
<dd>
<p>the language specific locale to use in case that either the <em>to_lower</em> or the <em>to_upper</em> parameter is TRUE and the text file language is other than english. For instance if the language of a text file is greek then the <em>utf_locale</em> parameter should be <em>'el_GR.UTF-8'</em> ( <em>language_country.encoding</em> ). A wrong utf-locale does not raise an error, however the runtime of the function increases.</p>
</dd>
<dt><code>remove_char</code></dt>
<dd>
<p>a string specifying the specific characters that should be removed from a text file. If the <em>remove_char</em> is "" then no removal of characters take place</p>
</dd>
<dt><code>remove_punctuation_string</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then the punctuation of the character string will be removed (applies before the split function)</p>
</dd>
<dt><code>remove_punctuation_vector</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then the punctuation of the vector of the character strings will be removed  (after the string split has taken place)</p>
</dd>
<dt><code>remove_numbers</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then any numbers in the character string will be removed</p>
</dd>
<dt><code>trim_token</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then the string will be trimmed (left and/or right)</p>
</dd>
<dt><code>split_string</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then the character string will be split using the <em>split_separator</em> as delimiter. The user can also specify multiple delimiters.</p>
</dd>
<dt><code>split_separator</code></dt>
<dd>
<p>a character string specifying the character delimiter(s)</p>
</dd>
<dt><code>remove_stopwords</code></dt>
<dd>
<p>either TRUE, FALSE or a character vector of user defined stop words. If TRUE then by using the <em>language</em> parameter the corresponding stop words vector will be uploaded.</p>
</dd>
<dt><code>language</code></dt>
<dd>
<p>a character string which defaults to english. If the <em>remove_stopwords</em> parameter is TRUE then the corresponding stop words vector will be uploaded. Available languages
are <em>afrikaans</em>, <em>arabic</em>, <em>armenian</em>, <em>basque</em>, <em>bengali</em>, <em>breton</em>, <em>bulgarian</em>, <em>catalan</em>,
<em>croatian</em>, <em>czech</em>, <em>danish</em>, <em>dutch</em>, <em>english</em>, <em>estonian</em>,
<em>finnish</em>, <em>french</em>, <em>galician</em>, <em>german</em>, <em>greek</em>, <em>hausa</em>, <em>hebrew</em>, <em>hindi</em>, <em>hungarian</em>,
<em>indonesian</em>, <em>irish</em>, <em>italian</em>, <em>latvian</em>, <em>marathi</em>,
<em>norwegian</em>, <em>persian</em>, <em>polish</em>, <em>portuguese</em>, <em>romanian</em>, <em>russian</em>, <em>slovak</em>, <em>slovenian</em>,
<em>somalia</em>, <em>spanish</em>, <em>swahili</em>, <em>swedish</em>, <em>turkish</em>, <em>yoruba</em>, <em>zulu</em></p>
</dd>
<dt><code>min_num_char</code></dt>
<dd>
<p>an integer specifying the minimum number of characters to keep. If the <em>min_num_char</em> is greater than 1 then character strings with more than 1 characters will be returned</p>
</dd>
<dt><code>max_num_char</code></dt>
<dd>
<p>an integer specifying the maximum number of characters to keep. The <em>max_num_char</em> should be less than or equal to <em>Inf</em> (in this function the Inf value translates to a word-length of 1000000000)</p>
</dd>
<dt><code>stemmer</code></dt>
<dd>
<p>a character string specifying the stemming method. Available method is the <em>porter2_stemmer</em>. See details for more information.</p>
</dd>
<dt><code>min_n_gram</code></dt>
<dd>
<p>an integer specifying the minimum number of n-grams. The minimum number of min_n_gram is 1.</p>
</dd>
<dt><code>max_n_gram</code></dt>
<dd>
<p>an integer specifying the maximum number of n-grams. The minimum number of max_n_gram is 1.</p>
</dd>
<dt><code>skip_n_gram</code></dt>
<dd>
<p>an integer specifying the number of skip-n-grams. The minimum number of skip_n_gram is 1. The skip_n_gram gives the (max.) n-grams using the <em>skip_distance</em> parameter. If <em>skip_n_gram</em> is greater than 1 then both <em>min_n_gram</em> and <em>max_n_gram</em> should be set to 1.</p>
</dd>
<dt><code>skip_distance</code></dt>
<dd>
<p>an integer specifying the skip distance between the words. The minimum value for the skip distance is 0, in which case simple n-grams will be returned.</p>
</dd>
<dt><code>n_gram_delimiter</code></dt>
<dd>
<p>a character string specifying the n-gram delimiter (applies to both n-gram and skip-n-gram cases)</p>
</dd>
<dt><code>print_every_rows</code></dt>
<dd>
<p>a numeric value greater than 1 specifying the print intervals. Frequent output in the R session can slow down the function in case of big files.</p>
</dd>
<dt><code>normalize</code></dt>
<dd>
<p>either NULL or one of 'l1' or 'l2' normalization.</p>
</dd>
<dt><code>tf_idf</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then the term-frequency-inverse-document-frequency will be returned</p>
</dd>
<dt><code>threads</code></dt>
<dd>
<p>an integer specifying the number of cores to run in parallel</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then information will be printed out</p>
</dd>
</dl>
</div>


<hr>
<a id="method-sparse_term_matrix-triplet_data"></a>



<h4>Method <code>triplet_data()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$triplet_data()</pre></div>


<hr>
<a id="method-sparse_term_matrix-global_term_weights"></a>



<h4>Method <code>global_term_weights()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$global_term_weights()</pre></div>


<hr>
<a id="method-sparse_term_matrix-Term_Matrix_Adjust"></a>



<h4>Method <code>Term_Matrix_Adjust()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$Term_Matrix_Adjust(sparsity_thresh = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sparsity_thresh</code></dt>
<dd>
<p>a float number between 0.0 and 1.0 specifying the sparsity threshold in the <em>Term_Matrix_Adjust</em> function</p>
</dd>
</dl>
</div>


<hr>
<a id="method-sparse_term_matrix-term_associations"></a>



<h4>Method <code>term_associations()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$term_associations(
  Terms = NULL,
  keep_terms = NULL,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Terms</code></dt>
<dd>
<p>a character vector specifying the character strings for which the associations will be calculated ( <em>term_associations</em> function )</p>
</dd>
<dt><code>keep_terms</code></dt>
<dd>
<p>either NULL or a numeric value specifying the number of terms to keep ( both in <em>term_associations</em> and <em>most_frequent_terms</em> functions )</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then information will be printed out</p>
</dd>
</dl>
</div>


<hr>
<a id="method-sparse_term_matrix-most_frequent_terms"></a>



<h4>Method <code>most_frequent_terms()</code>
</h4>



<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$most_frequent_terms(
  keep_terms = NULL,
  threads = 1,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_terms</code></dt>
<dd>
<p>either NULL or a numeric value specifying the number of terms to keep ( both in <em>term_associations</em> and <em>most_frequent_terms</em> functions )</p>
</dd>
<dt><code>threads</code></dt>
<dd>
<p>an integer specifying the number of cores to run in parallel</p>
</dd>
<dt><code>verbose</code></dt>
<dd>
<p>either TRUE or FALSE. If TRUE then information will be printed out</p>
</dd>
</dl>
</div>


<hr>
<a id="method-sparse_term_matrix-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>sparse_term_matrix$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

library(textTinyR)


sm &lt;- sparse_term_matrix$new(file_data = "/folder/my_data.txt",
                              document_term_matrix = TRUE)

#--------------
# term matrix :
#--------------

sm$Term_Matrix(sort_terms = TRUE, to_lower = TRUE,
                trim_token = TRUE, split_string = TRUE,
                remove_stopwords = TRUE, normalize = 'l1',
                stemmer = 'porter2_stemmer', threads = 1 )

#---------------
# triplet data :
#---------------

sm$triplet_data()


#----------------------
# global-term-weights :
#----------------------

sm$global_term_weights()


#-------------------------
# removal of sparse terms:
#-------------------------

sm$Term_Matrix_Adjust(sparsity_thresh = 0.995)


#-----------------------------------------------
# associations between terms of a sparse matrix:
#-----------------------------------------------

sm$term_associations(Terms = c("word", "sentence"), keep_terms = 10)


#---------------------------------------------
# most frequent terms using the sparse matrix:
#---------------------------------------------

sm$most_frequent_terms(keep_terms = 10, threads = 1)


## End(Not run)
</code></pre>


</div>