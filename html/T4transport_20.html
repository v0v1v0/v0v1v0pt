<div class="container">

<table style="width: 100%;"><tr>
<td>ipot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wasserstein Distance by Inexact Proximal Point Method</h2>

<h3>Description</h3>

<p>Due to high computational cost for linear programming approaches to compute
Wasserstein distance, Cuturi (2013) proposed an entropic regularization
scheme as an efficient approximation to the original problem. This comes with
a regularization parameter <code class="reqn">\lambda &gt; 0</code> in the term
</p>
<p style="text-align: center;"><code class="reqn">\lambda h(\Gamma) = \lambda \sum_{m,n} \Gamma_{m,n} \log (\Gamma_{m,n}).</code>
</p>

<p>IPOT algorithm is known to be relatively robust to the choice of
regularization parameter <code class="reqn">\lambda</code>. Empirical observation says that
very small number of inner loop iteration like <code>L=1</code> is sufficient.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ipot(X, Y, p = 2, wx = NULL, wy = NULL, lambda = 1, ...)

ipotD(D, p = 2, wx = NULL, wy = NULL, lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">(M\times P)</code> matrix of row observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of row observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wx</code></td>
<td>
<p>a length-<code class="reqn">M</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wy</code></td>
<td>
<p>a length-<code class="reqn">N</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a regularization parameter (default: 0.1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>maxiter</dt>
<dd>
<p>maximum number of iterations (default: 496).</p>
</dd>
<dt>abstol</dt>
<dd>
<p>stopping criterion for iterations (default: 1e-10).</p>
</dd>
<dt>L</dt>
<dd>
<p>small number of inner loop iterations (default: 1).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>an <code class="reqn">(M\times N)</code> distance matrix <code class="reqn">d(x_m, y_n)</code> between two sets of observations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a named list containing</p>

<dl>
<dt>distance</dt>
<dd>
<p><code class="reqn">\mathcal{W}_p</code> distance value</p>
</dd>
<dt>iteration</dt>
<dd>
<p>the number of iterations it took to converge.</p>
</dd>
<dt>plan</dt>
<dd>
<p>an <code class="reqn">(M\times N)</code> nonnegative matrix for the optimal transport plan.</p>
</dd>
</dl>
<h3>References</h3>

<p>Xie Y, Wang X, Wang R, Zha H (2020).
“A fast proximal point method for computing exact wasserstein distance.”
In Adams RP, Gogate V (eds.), <em>Proceedings of The 35th Uncertainty in Artificial Intelligence Conference</em>, volume 115 of <em>Proceedings of machine learning research</em>, 433–453.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#-------------------------------------------------------------------
#  Wasserstein Distance between Samples from Two Bivariate Normal
#
# * class 1 : samples from Gaussian with mean=(-1, -1)
# * class 2 : samples from Gaussian with mean=(+1, +1)
#-------------------------------------------------------------------
## SMALL EXAMPLE
set.seed(100)
m = 20
n = 30
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y

## COMPARE WITH WASSERSTEIN 
outw = wasserstein(X, Y)
ipt1 = ipot(X, Y, lambda=1)
ipt2 = ipot(X, Y, lambda=10)

## VISUALIZE : SHOW THE PLAN AND DISTANCE
pmw = paste0("wasserstein plan ; dist=",round(outw$distance,2))
pm1 = paste0("ipot lbd=1 ; dist=",round(ipt1$distance,2))
pm2 = paste0("ipot lbd=10; dist=",round(ipt2$distance,2))

opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(outw$plan, axes=FALSE, main=pmw)
image(ipt1$plan, axes=FALSE, main=pm1)
image(ipt2$plan, axes=FALSE, main=pm2)
par(opar)


</code></pre>


</div>