<div class="container">

<table style="width: 100%;"><tr>
<td>sinkhorn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wasserstein Distance by Entropic Regularization</h2>

<h3>Description</h3>

<p>Due to high computational cost for linear programming approaches to compute
Wasserstein distance, Cuturi (2013) proposed an entropic regularization
scheme as an efficient approximation to the original problem. This comes with
a regularization parameter <code class="reqn">\lambda &gt; 0</code> in the term
</p>
<p style="text-align: center;"><code class="reqn">\lambda h(\Gamma) = \lambda \sum_{m,n} \Gamma_{m,n} \log (\Gamma_{m,n}).</code>
</p>

<p>As <code class="reqn">\lambda\rightarrow 0</code>,
the solution to an approximation problem approaches to the solution of a
true problem. However, we have an issue with numerical underflow. Our
implementation returns an error when it happens, so please use a larger number
when necessary.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sinkhorn(X, Y, p = 2, wx = NULL, wy = NULL, lambda = 0.1, ...)

sinkhornD(D, p = 2, wx = NULL, wy = NULL, lambda = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>an <code class="reqn">(M\times P)</code> matrix of row observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>an <code class="reqn">(N\times P)</code> matrix of row observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>an exponent for the order of the distance (default: 2).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wx</code></td>
<td>
<p>a length-<code class="reqn">M</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wy</code></td>
<td>
<p>a length-<code class="reqn">N</code> marginal density that sums to <code class="reqn">1</code>. If <code>NULL</code> (default), uniform weight is set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>a regularization parameter (default: 0.1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>extra parameters including </p>

<dl>
<dt>maxiter</dt>
<dd>
<p>maximum number of iterations (default: 496).</p>
</dd>
<dt>abstol</dt>
<dd>
<p>stopping criterion for iterations (default: 1e-10).</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>an <code class="reqn">(M\times N)</code> distance matrix <code class="reqn">d(x_m, y_n)</code> between two sets of observations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a named list containing</p>

<dl>
<dt>distance</dt>
<dd>
<p><code class="reqn">\mathcal{W}_p</code> distance value.</p>
</dd>
<dt>iteration</dt>
<dd>
<p>the number of iterations it took to converge.</p>
</dd>
<dt>plan</dt>
<dd>
<p>an <code class="reqn">(M\times N)</code> nonnegative matrix for the optimal transport plan.</p>
</dd>
</dl>
<h3>References</h3>

<p>Cuturi M (2013).
“Sinkhorn distances: Lightspeed computation of optimal transport.”
In <em>Proceedings of the 26th international conference on neural information processing systems - volume 2</em>,  NIPS'13, 2292–2300.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
#-------------------------------------------------------------------
#  Wasserstein Distance between Samples from Two Bivariate Normal
#
# * class 1 : samples from Gaussian with mean=(-1, -1)
# * class 2 : samples from Gaussian with mean=(+1, +1)
#-------------------------------------------------------------------
## SMALL EXAMPLE
set.seed(100)
m = 20
n = 10
X = matrix(rnorm(m*2, mean=-1),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2, mean=+1),ncol=2) # n obs. for Y

## COMPARE WITH WASSERSTEIN 
outw = wasserstein(X, Y)
skh1 = sinkhorn(X, Y, lambda=0.05)
skh2 = sinkhorn(X, Y, lambda=0.10)

## VISUALIZE : SHOW THE PLAN AND DISTANCE
pm1 = paste0("wasserstein plan ; distance=",round(outw$distance,2))
pm2 = paste0("sinkhorn lbd=0.05; distance=",round(skh1$distance,2))
pm5 = paste0("sinkhorn lbd=0.1 ; distance=",round(skh2$distance,2))

opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(outw$plan, axes=FALSE, main=pm1)
image(skh1$plan, axes=FALSE, main=pm2)
image(skh2$plan, axes=FALSE, main=pm5)
par(opar)


</code></pre>


</div>