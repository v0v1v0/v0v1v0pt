<div class="container">

<table style="width: 100%;"><tr>
<td>LAPJV</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Solve linear assignment problem using LAPJV</h2>

<h3>Description</h3>

<p>Use the algorithm of Jonker and Volgenant (1987) to solve the
Linear Sum Assignment Problem (LSAP).
</p>


<h3>Usage</h3>

<pre><code class="language-R">LAPJV(x)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Matrix of costs.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>The Linear Assignment Problem seeks to match each row of a matrix with a
column, such that the cost of the matching is minimized.
</p>
<p>The Jonker &amp; Volgenant approach is a faster alternative to the Hungarian
algorithm (Munkres 1957), which is implemented in
<code>clue::solve_LSAP()</code>.
</p>
<p>Note: the JV algorithm expects integers. In order to apply the function
to a non-integer <em>n</em>, as in the tree distance calculations in this package,
each <em>n</em> is multiplied by the largest available integer before applying
the JV algorithm.  If two values of <em>n</em> exhibit a trivial difference –
e.g. due to floating point errors – then this can lead to interminable
run times.  (If numbers of the magnitude of billions differ only in their
last significant digit, then the JV algorithm may undergo billions of
iterations.)  To avoid this, integers over 2^22 that differ by a value of
8 or less are treated as equal.
</p>


<h3>Value</h3>

<p><code>LAPJV()</code> returns a list with two entries: <code>score</code>, the score of the
optimal matching;
and <code>matching</code>, the columns matched to each row of the matrix in turn.
</p>


<h3>Author(s)</h3>

<p><a href="https://github.com/yongyanghz/LAPJV-algorithm-c/blob/master/src/lap.cpp">C++ code</a>
by Roy Jonker, MagicLogic Optimization Inc. <a href="mailto:roy_jonker@magiclogic.com">roy_jonker@magiclogic.com</a>,
with contributions from Yong Yang <a href="mailto:yongyanglink@gmail.com">yongyanglink@gmail.com</a>, after
<a href="https://uk.mathworks.com/matlabcentral/profile/authors/69713-yi-cao">Yi Cao</a>
</p>


<h3>References</h3>

<p>Jonker R, Volgenant A (1987).
“A shortest augmenting path algorithm for dense and sparse linear assignment problems.”
<em>Computing</em>, <b>38</b>, 325–340.
<a href="https://doi.org/10.1007/BF02278710">doi:10.1007/BF02278710</a>.<br><br> Munkres J (1957).
“Algorithms for the assignment and transportation problems.”
<em>Journal of the Society for Industrial and Applied Mathematics</em>, <b>5</b>(1), 32–38.
<a href="https://doi.org/10.1137/0105003">doi:10.1137/0105003</a>.
</p>


<h3>See Also</h3>

<p>Implementations of the Hungarian algorithm exist in <span class="pkg">adagio</span>,
<span class="pkg">RcppHungarian</span>, and <span class="pkg">clue</span> and <span class="pkg">lpSolve</span>; for larger matrices,
these are substantially slower. (See discussion at <a href="https://stackoverflow.com/questions/72806265/">Stack Overflow</a>.)
</p>
<p>The JV algorithm is implemented for square matrices in the Bioconductor
package <a href="https://www.bioconductor.org/packages/release/bioc/html/GraphAlignment.html"><code>GraphAlignment::LinearAssignment()</code></a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">problem &lt;- matrix(c(7, 9, 8, 9, 9,
                    2, 8, 5, 7, 9,
                    1, 6, 6, 9, 9,
                    3, 6, 2, 2, 9), 4, 5, byrow = TRUE)

LAPJV(problem)
</code></pre>


</div>