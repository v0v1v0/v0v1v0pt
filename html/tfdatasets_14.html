<div class="container">

<table style="width: 100%;"><tr>
<td>dataset_batch</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Combines consecutive elements of this dataset into batches.</h2>

<h3>Description</h3>

<p>The components of the resulting element will have an additional outer
dimension, which will be <code>batch_size</code> (or <code>N %% batch_size</code> for the last
element if <code>batch_size</code> does not divide the number of input elements <code>N</code>
evenly and <code>drop_remainder</code> is <code>FALSE</code>). If your program depends on the
batches having the same outer dimension, you should set the <code>drop_remainder</code>
argument to <code>TRUE</code> to prevent the smaller batch from being produced.
</p>


<h3>Usage</h3>

<pre><code class="language-R">dataset_batch(
  dataset,
  batch_size,
  drop_remainder = FALSE,
  num_parallel_calls = NULL,
  deterministic = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>dataset</code></td>
<td>
<p>A dataset</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>batch_size</code></td>
<td>
<p>An integer, representing the number of consecutive elements
of this dataset to combine in a single batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_remainder</code></td>
<td>
<p>(Optional.) A boolean, representing whether the last
batch should be dropped in the case it has fewer than <code>batch_size</code>
elements; the default behavior is not to drop the smaller batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_parallel_calls</code></td>
<td>
<p>(Optional.) A scalar integer, representing the
number of batches to compute asynchronously in parallel. If not specified,
batches will be computed sequentially. If the value <code>tf$data$AUTOTUNE</code> is
used, then the number of parallel calls is set dynamically based on
available resources.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deterministic</code></td>
<td>
<p>(Optional.) When <code>num_parallel_calls</code> is specified, if
this boolean is specified (<code>TRUE</code> or <code>FALSE</code>), it controls the order in
which the transformation produces elements. If set to <code>FALSE</code>, the
transformation is allowed to yield elements out of order to trade
determinism for performance. If not specified, the
<code>tf.data.Options.experimental_deterministic</code> option (<code>TRUE</code> by default)
controls the behavior. See <code>dataset_options()</code> for how to set dataset
options.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A dataset
</p>


<h3>Note</h3>

<p>If your program requires data to have a statically known shape (e.g.,
when using XLA), you should use <code>drop_remainder=TRUE</code>. Without
<code>drop_remainder=TRUE</code> the shape of the output dataset will have an unknown
leading dimension due to the possibility of a smaller final batch.
</p>


<h3>See Also</h3>

<p>Other dataset methods: 
<code>dataset_cache()</code>,
<code>dataset_collect()</code>,
<code>dataset_concatenate()</code>,
<code>dataset_decode_delim()</code>,
<code>dataset_filter()</code>,
<code>dataset_interleave()</code>,
<code>dataset_map()</code>,
<code>dataset_map_and_batch()</code>,
<code>dataset_padded_batch()</code>,
<code>dataset_prefetch()</code>,
<code>dataset_prefetch_to_device()</code>,
<code>dataset_reduce()</code>,
<code>dataset_repeat()</code>,
<code>dataset_shuffle()</code>,
<code>dataset_shuffle_and_repeat()</code>,
<code>dataset_skip()</code>,
<code>dataset_take()</code>,
<code>dataset_take_while()</code>,
<code>dataset_window()</code>
</p>


</div>