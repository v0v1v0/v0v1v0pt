<div class="container">

<table style="width: 100%;"><tr>
<td>TVECM.sim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulation and bootstrap a VECM or bivariate TVECM</h2>

<h3>Description</h3>

<p>Estimate or bootstraps a multivariate Threshold VAR
</p>


<h3>Usage</h3>

<pre><code class="language-R">TVECM.sim(
  B,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  beta,
  nthresh = 1,
  Thresh,
  starting = NULL,
  innov = rmnorm(n, varcov = diag(1, nrow(B))),
  show.parMat = FALSE,
  returnStarting = FALSE,
  ...
)

VECM.sim(
  B,
  n = 200,
  lag = 1,
  include = c("const", "trend", "none", "both"),
  beta,
  starting = NULL,
  innov = rmnorm(n, varcov = diag(1, nrow(B))),
  show.parMat = FALSE,
  returnStarting = FALSE,
  ...
)

VECM.boot(
  object,
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL,
  ...
)

TVECM.boot(
  object,
  boot.scheme = c("resample", "resample_block", "wild1", "wild2", "check"),
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>Simulation: Matrix of coefficients to simulate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Simulation: Number of observations to simulate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>The cointegrating value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Thresh, nthresh, lag, include</code></td>
<td>
<p>Simulation: parameters for the VECM/TVECM to simulate. 
See <code>TVECM</code> for their description.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>starting</code></td>
<td>
<p>Simulation: Starting values (same length as lag = 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>innov</code></td>
<td>
<p>Simulation: time series of innovations/residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.parMat</code></td>
<td>
<p>Logical. Whether to show how the parameter matrix B is interpreted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnStarting</code></td>
<td>
<p>Logical. Whether to return the starting values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for the unexported <code>TVECM.gen</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Object computed by function <code>TVECM</code>
or linear <code>VECM</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boot.scheme</code></td>
<td>
<p>Bootstrap: which resampling scheme to use for the residuals. See <code>resample_vec</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Bootstrap: seed used in the resampling</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function offers the possibility to generate series following a
VECM/TVECM from two approaches: bootstrap or simulation. <code>VECM.sim</code> is
just a wrapper for <code>TVECM.sim</code>.
</p>
<p>When the argument <code>matrix</code> is given, on can only simulate a VECM
(<code>nthresh</code>=0) or TVECM (<code>nthresh</code>=1 or 2). One can have a
specification with constant (<code>"const"</code>), <code>"trend"</code>, <code>"both"</code>
or <code>"none"</code> (see argument <code>include</code>). Order for the parameters is
ECT/include/lags for VECM and ECT1/include1/lags1/ECT2/include2/lags2 for
TVECM. To be sure that once is using it correctly, setting <code>show.parMat
= TRUE</code> will show the matrix of parameters together with their values and
names.
</p>
<p>The argument <code>beta</code> is the cointegrating value on the right side of the
long-run relationship, and hence the function use the vector (1,-beta). The
<code>innov</code> argument specifies the innovations. It should be given as a
matrix of dim nxk, (here <var>n</var> does not include the starting values!), by
default it uses a multivariate normal distribution, with covariance matrix
specified by <code>varcov</code>.
</p>
<p>The starting values (of dim lags x k) can be given through argument
<code>starting</code>. The user should take care for their choice, since it is not
sure that the simulated values will cross the threshold even once. Notice
that only one cointegrating value is allowed. User interested in simulating a
VECM with more cointegrating values should do use the VAR representation and
use <code>TVAR.sim</code>.
</p>
<p>The second possibility is to bootstrap series. This is done on a object
generated by <code>TVECM</code> (or <code>VECM</code>). A simple residual
bootstrap is done, or one can simulate a series with the same parameter
matrix and with normal distributed residuals (with variance pre-specified),
corresponding to Monte-carlo simulations.
</p>
<p>One can alternatively give only the series, and then the function will call
internally <code>TVECM</code>.
</p>


<h3>Value</h3>

<p>A matrix with the simulated/bootstrapped series.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler
</p>


<h3>See Also</h3>

<p><code>VECM</code> or <code>TVECM</code> to estimate the VECM or TVECM.  
Similar <code>TVAR.sim</code> and <code>TVAR.boot</code> for <code>TVAR</code>, 
<code>VAR.sim</code> and <code>VAR.boot</code> for VAR models estimated with <code>lineVar</code> models.
</p>


<h3>Examples</h3>

<pre><code class="language-R">

###reproduce example in Enders (2004, 2 edition) p. 350, 
# (similar example in Enders (2010, 3 edition) 301-302). 

if(require(mnormt)){
#see that the full "VAR" coefficient matrix is:
 A &lt;- matrix(c(-0.2, 0.2, 0.2, -0.2), byrow=TRUE, ncol=2)

# but this is not the input of VECM.sim. You should decompose into the a and b matrix:
 a&lt;-matrix(c(-0.2, 0.2), ncol=1)
 b&lt;-matrix(c(1,-1), nrow=1)

# so that:
 a%*%b

# The a matrix is the input under argument B, while the b matrix is under argument beta: 
# (the other zeros in B are for the not-specified lags)
 innov&lt;-rmnorm(100, varcov=diag(2))
 Bvecm &lt;- rbind(c(-0.2, 0,0), c(0.2, 0,0))
 vecm1 &lt;- VECM.sim(B=Bvecm, beta=1,n=100, lag=1,include="none", innov=innov)
 ECT &lt;- vecm1[,1]-vecm1[,2]

#add an intercept as in panel B
 Bvecm2 &lt;- rbind(c(-0.2, 0.1,0,0), c(0.2,0.4, 0,0))
 vecm2 &lt;- VECM.sim(B=Bvecm2,  n=100,beta=1, lag=1,include="const", innov=innov)

 par(mfrow=c(2,1))
 plot(vecm1[,1], type="l", main="Panel a: no drift or intercept", ylab="", xlab="")
 lines(vecm1[,2], lty=2)
 plot(vecm2[,1], type="l", main="Panel b: drift terms (0.1)", ylab="", xlab="")
 lines(vecm2[,2], lty=2)
}
##Bootstrap a TVAR with 1 threshold (two regimes)
data(zeroyld)
TVECMobject &lt;- TVECM(zeroyld, nthresh=1, lag=1, ngridBeta=20, ngridTh=20, plot=FALSE, trace = FALSE)
TVECM.boot(TVECMobject)

##Check the bootstrap: do we get original series, when not resampling residuals?
TVECM.boot.check &lt;- TVECM.boot(TVECMobject, boot.scheme = "check")
all.equal(as.data.frame(TVECM.boot.check), zeroyld)

</code></pre>


</div>