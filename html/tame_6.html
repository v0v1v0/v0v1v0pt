<div class="container">

<table style="width: 100%;"><tr>
<td>employ</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Employ a Clustering to New Data</h2>

<h3>Description</h3>

<p>Employ a clustering to new data
</p>


<h3>Usage</h3>

<pre><code class="language-R">employ(
  object,
  new_data,
  only = NULL,
  additional_data = NULL,
  assignment_method = "nearest_cluster",
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A <code>medic</code> clustering object for which employment is desired.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_data</code></td>
<td>
<p>A data frame in which to look for variables with</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>only</code></td>
<td>
<p>&lt;<code>data-masking</code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code> and specifies which clusterings should be
employed to the new data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>assignment_method</code></td>
<td>
<p>A character naming the employment method. The
default assignment method <code>"nearest_cluster"</code> matches people in <code>new_data</code>
to their nearest cluster in the chosen clusterings from <code>object</code>. As
finding exact matches (the next assignment method) is contained within this
strategy the <code>"exact_only"</code> matches are also reported in additional columns
in the output.
</p>
<p>The assignment method <code>"exact_only"</code> only matches a person from <code>new_data</code>
to a cluster if they are a perfect match to anyone in <code>object</code>. Thus,
people from <code>new_data</code> are not guaranteed assignment to a cluster.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>A logical or an integer. If <code>FALSE</code>, the default, no
parallelization is done.
</p>
<p>If <code>TRUE</code> or an integer larger than 2L parallelization is implemented via
parLapply from the <strong>parallel</strong> package. When
<code>parallel</code> is <code>TRUE</code> the number of clusters
is set to detectCores - 1, and when <code>parallel</code> is
an integer then the number of clusters is set to
<code>parallel</code>. For more details on the parallelization method see
parallel::parLapply.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments affecting the employment procedure.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>employ</code> returns a <code>medic</code> object.
</p>


<h3>Examples</h3>

<pre><code class="language-R">part1 &lt;- complications[1:100,]
part2 &lt;- complications[101:149,]

clust &lt;- medic(part1, id = id, atc = atc, k = 3)

# Nearest cluster matching
employ(clust, part2)

# Only exact matching
employ(clust, part2, assignment_method = "exact_only")

</code></pre>


</div>