<div class="container">

<table style="width: 100%;"><tr>
<td>evolve_gbmdl</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate a list of candidate changepoints using a genetic algorithm</h2>

<h3>Description</h3>

<p>Generate a list of candidate changepoints using a genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class="language-R">evolve_gbmdl(x, mat_cp, these_bmdls)

junta_1_puntos_cambio(padres, mat_cp)

junta_k_puntos_cambio(mat_padres, mat_cp)

mata_1_tau_volado(cp, prob_volado = 0.5)

mata_k_tau_volado(mat_cp)

muta_1_cp_BMDL(
  cp,
  x,
  probs_nuevos_muta0N = c(0.8, 0.1, 0.1),
  dist_extremos = 10,
  min_num_cpts = 1,
  mutation_possibilities = c(-1, 0, 1),
  mutation_probs = c(0.3, 0.4, 0.3),
  max_num_cp = 20
)

muta_k_cp_BMDL(mat_cp, x)

sim_1_cp_BMDL(x, max_num_cp = 20, prob_inicial = 0.06)

sim_k_cp_BMDL(x, generation_size = 50, max_num_cp = 20)

probs_vec_MDL(vec_MDL, probs_rank0_MDL1 = 0)

selec_k_pares_de_padres(vec_probs)

chromo2tau(chromo)

mat_cp_2_list(mat_cp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A time series object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat_cp</code></td>
<td>
<p>A matrix of potential changepoints</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>these_bmdls</code></td>
<td>
<p>vector of <code>BMDL()</code> scores</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>padres</code></td>
<td>
<p>vector de longitud dos con índice de papa e índice de mama</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat_padres</code></td>
<td>
<p>matriz de kx2 la cual contiene en sus renglones las
parejas de padres</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cp</code></td>
<td>
<p>vector cromosoma que se va a poner a prueba</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob_volado</code></td>
<td>
<p>probabilidad de quitar un tiempo de cambio existente
utilizado por mata_k_tau_volado para quitar elementos de más. Se recomienda
dejar el valor de 0.5 ya que así al juntar los pc del padre y madre se
eliminará la mitad de estos</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs_nuevos_muta0N</code></td>
<td>
<p>probabilidades de mutar 0,1,2,...,l hasta cierto
numero l; eg si vale c(.5,.2,.2,.1) se tiene una probabilidad 0.5 de mutar
0 (de no mutar), probabilidad 0.2 de mutar 1,, probabilidad 0.2 de mutar 2,
y, probabilidad 0.1 de mutar 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist_extremos</code></td>
<td>
<p>distancia entre el primer los puntos de cambio v_0 y v_1
al igual que entre v_m y v_{m+1}; distancia minima que debe de haber de un
punto de cambio y los valores 1 y T, donde T es la longitud total de la
serie</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_num_cpts</code></td>
<td>
<p>es la cota inferior del número de puntos de cambio
que puede tener un cromosoma</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutation_possibilities</code></td>
<td>
<p>vector con mutaciones posibles; eg si mutaciones=c(-1,0,1)
entonces un punto de cambio puede ser movido una unidad a la izquierda,
puede quedarse igual, o moverse una unidad a la derecha</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mutation_probs</code></td>
<td>
<p>probabilidades de mutación. Las longitudes de este vector y
mutaciones tienen que ser iguales; eg si mutaciones=c(-1,0,1) y probs_muta
= c(.2, .6, .2) entonces se tiene una probabilidad .2 de que el punto de
cambio se desplace a la izquierda, probabilidad .6 de quedar igual, y
probabilidad . 2 de ser movido a la derecha</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_num_cp</code></td>
<td>
<p>el máximo número de rebases. Este parámetro se ocupa en
particular para que todos los cromosomas quepan en una matriz.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob_inicial</code></td>
<td>
<p>probabilidad de que en la primera generación un punto
cualquiera sea punto de cambio. Se recomienda =.5 ya que con esto se
distribuyen relativamente uniformes los puntos de cambio</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>generation_size</code></td>
<td>
<p>tamaño de las generaciones</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec_MDL</code></td>
<td>
<p>vector con valores MDL
</p>
<p>OBSERVACIÓN: Esto regresa numeros negativos, los cuales mientras más negativo mejor, ya que
dará que es un mejor vector de tiempos de cambio. Es decir, un MDL de -6000 es
mejor que -4000</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>probs_rank0_MDL1</code></td>
<td>
<p>para medir obtener la probabilidad de los padres se
pueden tomar o las probabilidades con respecto a los rangos (como en el
artículo) o se pueden tomar las probabilidades con respecto a el MDL. La
diferencia radica en que si se toma con respecto al MDL se tendrá que un
cromosoma con un gran MDL este tendrá una gran ventaja de ocurrir, en
cambio cuando solo se tiene rank esta ventaja gran ventaja se reduce</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec_probs</code></td>
<td>
<p>vector de probabilidades de selección de cada uno de los
cromosomas</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chromo</code></td>
<td>
<p>Chromosome, from a row of the matrix <code>mat_cp</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>regresa un vector de tamaño <code>max_num_cp+3</code> donde la primera entrada es
m, la segunda <code class="reqn">v_0=1, ...., v_{m+1}=N,0,...,0</code>
</p>
<p>por ejemplo: <code>c(4,1,3,8,11,15,20,0,0,0,0)</code> para <code>m=4</code>, <code class="reqn">max\_num\_cp=8</code>, <code class="reqn">N=20</code>.
Se tienen <code>m</code> puntos de cambio, los cuales
<code class="reqn">\tau_0=1</code> y <code class="reqn">\tau_{m+1}= N+1</code>,
pero en nuestro caso
tenemos que los vectores <code>cp</code> tienen <code class="reqn">c(m,\tau_0=1,\tau_1,...,\tau_{m-1},\tau_m= N,0,0,0)</code>
por lo cual se nosotros:
</p>

<ul>
<li>
<p> empieza con el número de puntos de cambio;
</p>
</li>
<li>
<p> la segunda entrada es un uno;
</p>
</li>
<li>
<p> la tercera entrada es el primer punto de cambio;
</p>
</li>
<li>
<p> las siguientes son otros puntos de cambio;
</p>
</li>
<li>
<p> la siguiente entrada después de punto de cambio tiene el valor  <code>N</code>; y
</p>
</li>
<li>
<p> los siguientes son númores cero hasta llenarlo para que sea de tamaño <code>max_num_cp</code>
</p>
</li>
</ul>
<h3>Value</h3>

<p>regresa una matriz de las mismas dimensiones que mat_cp, pero con los
nuevos cromosomas
</p>
<p>el mismo cromosoma sin algunos de sus puntos de cambio
</p>
<p>regresa una matriz a la cual se le quitaron a sus cromosomas algunos
puntos de cambio
</p>
<p>regresa un vector mutado
</p>
<p>regreas una mat_cp mutada
</p>
<p>regresa una matriz de <code>k</code> por <code>max_num_cp+3</code>, la cual en cada renglón tiene
una simulación de un vector de tiempos de cambio
</p>
<p>regresa un vector de probabilidades
</p>


<h3>Examples</h3>

<pre><code class="language-R">mat_cp &lt;- sim_k_cp_BMDL(DataCPSim)
bmdls &lt;- mat_cp |&gt; 
  mat_cp_2_list() |&gt; 
  evaluate_cpts(.data = as.ts(DataCPSim), model_fn = fit_nhpp) |&gt; 
  dplyr::pull(BMDL)
evolve_gbmdl(exceedances(DataCPSim), mat_cp, bmdls)
sim_1_cp_BMDL(exceedances(DataCPSim))
sim_1_cp_BMDL(exceedances(rlnorm_ts_1))
sim_1_cp_BMDL(exceedances(rlnorm_ts_2))
sim_1_cp_BMDL(exceedances(rlnorm_ts_3))
sim_1_cp_BMDL(exceedances(bogota_pm))

sim_k_cp_BMDL(DataCPSim)

chromo &lt;- c(4, 1, 557, 877 , 905, 986, 1096, 0, 0, 0)
chromo2tau(chromo)
</code></pre>


</div>