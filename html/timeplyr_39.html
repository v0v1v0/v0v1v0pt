<div class="container">

<table style="width: 100%;"><tr>
<td>group_collapse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Key group information</h2>

<h3>Description</h3>

<p>Key group information
</p>


<h3>Usage</h3>

<pre><code class="language-R">group_collapse(
  data,
  ...,
  order = TRUE,
  sort = FALSE,
  ascending = TRUE,
  .by = NULL,
  .cols = NULL,
  id = TRUE,
  size = TRUE,
  loc = TRUE,
  start = TRUE,
  end = TRUE,
  .drop = df_group_by_drop_default(data)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame or vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional groups using tidy <code>data-masking</code> rules. <br>
To specify groups using <code>tidyselect</code>, simply use the <code>.by</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order</code></td>
<td>
<p>Should the groups be ordered?
<b>THE PHYSICAL ORDER OF THE DATA IS NOT CHANGED.</b> <br>
When order is <code>TRUE</code> (the default) the group IDs will be ordered but not sorted.
If <code>FALSE</code> the order of the group IDs will be based on first appearance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>Should the data frame be sorted by the groups?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ascending</code></td>
<td>
<p>Should groups be ordered in ascending order?
Default is <code>TRUE</code> and only applies when <code>order = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.by</code></td>
<td>
<p>Alternative way of supplying groups using <code>tidyselect</code> notation.
This is kept to be consistent with other functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Should group IDs be added? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>Should group sizes be added? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>Should group locations be added? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start</code></td>
<td>
<p>Should group start locations be added? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>
<p>Should group end locations be added? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.drop</code></td>
<td>
<p>Should unused factor levels be dropped? Default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>group_collapse()</code> is similar to <code>dplyr::group_data()</code> but differs in 3 key regards:
</p>

<ul>
<li>
<p> The output tries to convey as much information about the groups as possible.
By default, like <code>dplyr</code>, the groups are ordered, but unlike <code>dplyr</code> they are not
sorted, which conveys information on order-of-first-appearance in the data.
In addition to group locations, group sizes and start indices are returned.
</p>
</li>
<li>
<p> There is more flexibility in specifying how the groups are ordered and/or sorted.
</p>
</li>
<li> <p><code>collapse</code> is used to obtain the grouping structure, which is very fast.
</p>
</li>
</ul>
<p>There are 3 ways to specify the groups:
</p>

<ul>
<li>
<p> Using <code>...</code> which utilises <code>tidy</code> <code>data-masking</code>.
</p>
</li>
<li>
<p> Using <code>.by</code> which utilises <code>tidyselect</code>.
</p>
</li>
<li>
<p> Using <code>.cols</code> which accepts a named character/integer vector.
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>tibble</code> of unique groups and an integer ID uniquely identifying each group.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(timeplyr)
library(dplyr)

iris &lt;- dplyr::as_tibble(iris)
group_collapse(iris) # No groups
group_collapse(iris, Species) # Species groups

iris %&gt;%
  group_by(Species) %&gt;%
  group_collapse() # Same thing

# Group entire data frame
group_collapse(iris, .by = everything())

</code></pre>


</div>