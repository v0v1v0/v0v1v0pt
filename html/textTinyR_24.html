<div class="container">

<table style="width: 100%;"><tr>
<td>text_file_parser</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>text file parser</h2>

<h3>Description</h3>

<p>text file parser
</p>


<h3>Usage</h3>

<pre><code class="language-R">text_file_parser(
  input_path_file = NULL,
  output_path_file = "",
  start_query = NULL,
  end_query = NULL,
  min_lines = 1,
  trimmed_line = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input_path_file</code></td>
<td>
<p>either a path to an input file or a vector of character strings ( normally the latter would represent ordered lines of a text file in form of a character vector )</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_path_file</code></td>
<td>
<p>either an empty character string ("") or a character string specifying a path to an output file ( it applies only if the <em>input_path_file</em> parameter is a valid path to a file )</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_query</code></td>
<td>
<p>a character string or a vector of character strings. The <em>start_query</em> (if it's a single character string) is the first word of the subset of the data and should appear frequently at the beginning of each line in the text file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end_query</code></td>
<td>
<p>a character string or a vector of character strings. The <em>end_query</em> (if it's a single character string) is the last word of the subset of the data and should appear frequently at the end of each line in the text file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_lines</code></td>
<td>
<p>a numeric value specifying the minimum number of lines ( applies only if the <em>input_path_file</em> is a valid path to a file) . For instance if min_lines = 2, then only subsets of text with more than 1 lines will be pre-processed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trimmed_line</code></td>
<td>
<p>either TRUE or FALSE. If FALSE then each line of the text file will be trimmed both sides before applying the start_query and end_query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then information will be printed in the console</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The text file should have a structure (such as an xml-structure), so that subsets can be extracted using the <em>start_query</em> and <em>end_query</em> parameters ( the same applies in case of a vector of character strings)
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

library(textTinyR)

# In case that the 'input_path_file' is a valid path
#---------------------------------------------------

fp = text_file_parser(input_path_file = '/folder/input_data.txt',
                       output_path_file = '/folder/output_data.txt',
                       start_query = 'word_a', end_query = 'word_w',
                       min_lines = 1, trimmed_line = FALSE)


# In case that the 'input_path_file' is a character vector of strings
#--------------------------------------------------------------------

PATH_url = "https://FILE.xml"
con = url(PATH_url, method = "libcurl")
tmp_dat = read.delim(con, quote = "\"", comment.char = "", stringsAsFactors = FALSE)

vec_docs = unlist(lapply(1:length(as.vector(tmp_dat[, 1])), function(x)
                    trimws(tmp_dat[x, 1], which = "both")))

parse_data = text_file_parser(input_path_file = vec_docs,
                                start_query = c("&lt;query1&gt;", "&lt;query2&gt;", "&lt;query3&gt;"),
                                end_query = c("&lt;/query1&gt;", "&lt;/query2&gt;", "&lt;/query3&gt;"),
                                min_lines = 1, trimmed_line = TRUE)
                                

## End(Not run)
</code></pre>


</div>