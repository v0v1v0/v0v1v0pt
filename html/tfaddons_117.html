<div class="container">

<table style="width: 100%;"><tr>
<td>parse_time</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Parse time</h2>

<h3>Description</h3>

<p>Parse an input string according to the provided format string into a
</p>


<h3>Usage</h3>

<pre><code class="language-R">parse_time(time_string, time_format, output_unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>time_string</code></td>
<td>
<p>The input time string to be parsed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_format</code></td>
<td>
<p>The time format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_unit</code></td>
<td>
<p>The output unit of the parsed unix time. Can only be SECOND, MILLISECOND, MICROSECOND, NANOSECOND.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Unix time. Parse an input string according to the provided format string
into a Unix
time, the number of seconds / milliseconds / microseconds / nanoseconds
elapsed since January 1, 1970 UTC. Uses strftime()-like formatting options, with
the same extensions as
FormatTime(), but with the exceptions that 

characters as it can, so the matching
data should always be terminated with a non-numeric. 
consumes exactly four characters, including any sign. Unspecified fields are taken
from the default date and time of ... "1970-01-01 00:00:00.0 +0000" For example,
parsing a string of "15:45" (
Unix time that represents "1970-01-01 15:45:00.0 +0000". Note that ParseTime only
heeds the fields year, month, day, hour,
minute, (fractional) second, and UTC offset. Other fields, like
weekday (
ignored in the conversion. Date and time fields that are out-of-range will be treated as
errors rather than normalizing them like 'absl::CivilSecond' does.
For example, it is an error to parse the date "Oct 32, 2013"
because 32 is out of range. A leap second of ":60" is normalized to ":00" of the following
minute with fractional seconds discarded. The following table
shows how the given seconds and subseconds will be parsed: "59.x" -&gt; 59.x // exact "60.x" -&gt; 00.0 // normalized "00.x" -&gt; 00.x // exact
</p>


<h3>Value</h3>

<p>the number of seconds / milliseconds / microseconds / nanoseconds elapsed since January 1, 1970 UTC.
</p>


<h3>Raises</h3>

<p>ValueError: If 'output_unit' is not a valid value, if parsing 'time_string' according to 'time_format' failed.
</p>


</div>