<div class="container">

<table style="width: 100%;"><tr>
<td>graph_measures</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Graph measurements</h2>

<h3>Description</h3>

<p>This set of functions provide wrappers to a number of <code>ìgraph</code>s graph
statistic algorithms. As for the other wrappers provided, they are intended
for use inside the <code>tidygraph</code> framework and it is thus not necessary to
supply the graph being computed on as the context is known. All of these
functions are guarantied to return scalars making it easy to compute with
them.
</p>


<h3>Usage</h3>

<pre><code class="language-R">graph_adhesion()

graph_assortativity(attr, in_attr = NULL, directed = TRUE)

graph_automorphisms(sh = "fm", colors = NULL)

graph_clique_num()

graph_clique_count(min = NULL, max = NULL, subset = NULL)

graph_component_count(type = "weak")

graph_motif_count(size = 3, cut.prob = rep(0, size))

graph_diameter(weights = NULL, directed = TRUE, unconnected = TRUE)

graph_girth()

graph_radius(mode = "out")

graph_mutual_count()

graph_asym_count()

graph_unconn_count()

graph_size()

graph_order()

graph_reciprocity(ignore_loops = TRUE, ratio = FALSE)

graph_min_cut(capacity = NULL)

graph_mean_dist(directed = TRUE, unconnected = TRUE, weights = NULL)

graph_modularity(group, weights = NULL)

graph_efficiency(weights = NULL, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>attr</code></td>
<td>
<p>The node attribute to measure on</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>in_attr</code></td>
<td>
<p>An alternative node attribute to use for incomming node. If <code>NULL</code> the attribute given by <code>type</code> will be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>Should a directed graph be treated as directed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sh</code></td>
<td>
<p>The splitting heuristics for the BLISS algorithm. Possible values
are: ‘<code>f</code>’: first non-singleton cell, ‘<code>fl</code>’: first
largest non-singleton cell, ‘<code>fs</code>’: first smallest non-singleton
cell, ‘<code>fm</code>’: first maximally non-trivially connected
non-singleton cell, ‘<code>flm</code>’: first largest maximally
non-trivially connected non-singleton cell, ‘<code>fsm</code>’: first
smallest maximally non-trivially connected non-singleton cell.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min, max</code></td>
<td>
<p>The upper and lower bounds of the cliques to be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>The indexes of the nodes to start the search from (logical or integer). If provided only the cliques containing these nodes will be counted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The type of component to count, either 'weak' or 'strong'. Ignored for undirected graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>The size of the motif.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
distances. If the graph has a <code>weight</code> edge attribute, then this is
used by default.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unconnected</code></td>
<td>
<p>Logical, what to do if the graph is unconnected. If
FALSE, the function will return a number that is one larger the largest
possible diameter, which is always the number of vertices. If TRUE, the
diameters of the connected components will be calculated and the largest one
will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>How should eccentricity be calculated. If <code>"out"</code> only outbound edges are followed. If <code>"in"</code> only inbound are followed. If <code>"all"</code> all edges are followed. Ignored for undirected graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_loops</code></td>
<td>
<p>Logical. Should loops be ignored while calculating the reciprocity</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ratio</code></td>
<td>
<p>Should the old "ratio" approach from igraph &lt; v0.6 be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>capacity</code></td>
<td>
<p>The capacity of the edges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The node grouping to calculate the modularity on</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A scalar, the type depending on the function
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>graph_adhesion()</code>: Gives the minimum edge connectivity. Wraps <code>igraph::edge_connectivity()</code>
</p>
</li>
<li> <p><code>graph_assortativity()</code>: Measures the propensity of similar nodes to be connected. Wraps <code>igraph::assortativity()</code>
</p>
</li>
<li> <p><code>graph_automorphisms()</code>: Calculate the number of automorphisms of the graph. Wraps <code>igraph::count_automorphisms()</code>
</p>
</li>
<li> <p><code>graph_clique_num()</code>: Get the size of the largest clique. Wraps <code>igraph::clique_num()</code>
</p>
</li>
<li> <p><code>graph_clique_count()</code>: Get the number of maximal cliques in the graph. Wraps <code>igraph::count_max_cliques()</code>
</p>
</li>
<li> <p><code>graph_component_count()</code>: Count the number of unconnected componenets in the graph. Wraps <code>igraph::count_components()</code>
</p>
</li>
<li> <p><code>graph_motif_count()</code>: Count the number of motifs in a graph. Wraps <code>igraph::count_motifs()</code>
</p>
</li>
<li> <p><code>graph_diameter()</code>: Measures the length of the longest geodesic. Wraps <code>igraph::diameter()</code>
</p>
</li>
<li> <p><code>graph_girth()</code>: Measrues the length of the shortest circle in the graph. Wraps <code>igraph::girth()</code>
</p>
</li>
<li> <p><code>graph_radius()</code>: Measures the smallest eccentricity in the graph. Wraps <code>igraph::radius()</code>
</p>
</li>
<li> <p><code>graph_mutual_count()</code>: Counts the number of mutually connected nodes. Wraps <code>igraph::dyad_census()</code>
</p>
</li>
<li> <p><code>graph_asym_count()</code>: Counts the number of asymmetrically connected nodes. Wraps <code>igraph::dyad_census()</code>
</p>
</li>
<li> <p><code>graph_unconn_count()</code>: Counts the number of unconnected node pairs. Wraps <code>igraph::dyad_census()</code>
</p>
</li>
<li> <p><code>graph_size()</code>: Counts the number of edges in the graph. Wraps <code>igraph::gsize()</code>
</p>
</li>
<li> <p><code>graph_order()</code>: Counts the number of nodes in the graph. Wraps <code>igraph::gorder()</code>
</p>
</li>
<li> <p><code>graph_reciprocity()</code>: Measures the proportion of mutual connections in the graph. Wraps <code>igraph::reciprocity()</code>
</p>
</li>
<li> <p><code>graph_min_cut()</code>: Calculates the minimum number of edges to remove in order to split the graph into two clusters. Wraps <code>igraph::min_cut()</code>
</p>
</li>
<li> <p><code>graph_mean_dist()</code>: Calculates the mean distance between all node pairs in the graph. Wraps <code>igraph::mean_distance()</code>
</p>
</li>
<li> <p><code>graph_modularity()</code>: Calculates the modularity of the graph contingent on a provided node grouping
</p>
</li>
<li> <p><code>graph_efficiency()</code>: Calculate the global efficiency of the graph
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Use e.g. to modify computations on nodes and edges
create_notable('meredith') %&gt;%
  activate(nodes) %&gt;%
  mutate(rel_neighbors = centrality_degree()/graph_order())
</code></pre>


</div>