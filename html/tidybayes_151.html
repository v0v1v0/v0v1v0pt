<div class="container">

<table style="width: 100%;"><tr>
<td>add_epred_draws</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add draws from the posterior fit, predictions, or residuals of a model to a data frame</h2>

<h3>Description</h3>

<p>Given a data frame and a model, adds draws from the linear/link-level predictor,
the expectation of the posterior predictive, the posterior predictive, or the residuals of a model to
the data frame in a long format.
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_epred_draws(
  newdata,
  object,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

## Default S3 method:
epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  seed = NULL,
  category = NULL
)

## S3 method for class 'stanreg'
epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

## S3 method for class 'brmsfit'
epred_draws(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

add_linpred_draws(
  newdata,
  object,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL,
  n
)

linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL,
  n,
  scale
)

## Default S3 method:
linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  seed = NULL,
  category = NULL
)

## S3 method for class 'stanreg'
linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

## S3 method for class 'brmsfit'
linpred_draws(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  dpar = NULL
)

add_predicted_draws(
  newdata,
  object,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n
)

predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n,
  prediction
)

## Default S3 method:
predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  seed = NULL,
  category = ".category"
)

## S3 method for class 'stanreg'
predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category"
)

## S3 method for class 'brmsfit'
predicted_draws(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category"
)

add_residual_draws(
  newdata,
  object,
  ...,
  value = ".residual",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n
)

residual_draws(
  object,
  newdata,
  ...,
  value = ".residual",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category",
  n,
  residual
)

## Default S3 method:
residual_draws(object, newdata, ...)

## S3 method for class 'brmsfit'
residual_draws(
  object,
  newdata,
  ...,
  value = ".residual",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  category = ".category"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Data frame to generate predictions from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A supported Bayesian model fit that can provide fits and predictions. Supported models
are listed in the second section of tidybayes-models: <em>Models Supporting Prediction</em>. While other
functions in this package (like <code>spread_draws()</code>) support a wider range of models, to work with
<code>add_epred_draws()</code>, <code>add_predicted_draws()</code>, etc. a model must provide an interface for generating
predictions, thus more generic Bayesian modeling interfaces like <code>runjags</code> and <code>rstan</code> are not directly
supported for these functions (only wrappers around those languages that provide predictions, like <code>rstanarm</code>
and <code>brm</code>, are supported here).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the underlying prediction method for the type of
model given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>The name of the output column:
</p>

<ul>
<li>
<p> for <code style="white-space: pre;">⁠[add_]epred_draws()⁠</code>, defaults to <code>".epred"</code>.
</p>
</li>
<li>
<p> for <code style="white-space: pre;">⁠[add_]predicted_draws()⁠</code>, defaults to <code>".prediction"</code>.
</p>
</li>
<li>
<p> for <code style="white-space: pre;">⁠[add_]linpred_draws()⁠</code>, defaults to <code>".linpred"</code>.
</p>
</li>
<li>
<p> for <code style="white-space: pre;">⁠[add_]residual_draws()⁠</code>, defaults to <code>".residual"</code>
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in the prediction.
If <code>NULL</code> (default), include all group-level effects; if <code>NA</code>, include no group-level effects.
Some model types (such as brms::brmsfit and rstanarm::stanreg-objects) allow
marginalizing over grouping factors by specifying new levels of a factor in <code>newdata</code>. In the case of
<code>brms::brm()</code>, you must also pass <code>allow_new_levels = TRUE</code> here to include new levels (see
<code>brms::posterior_predict()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>category</code></td>
<td>
<p>For <em>some</em> ordinal, multinomial, and multivariate models (notably, <code>brms::brm()</code> models but
<em>not</em> <code>rstanarm::stan_polr()</code> models), multiple sets of rows will be returned per input row for
<code>epred_draws()</code> or <code>predicted_draws()</code>, depending on the model type. For ordinal/multinomial models,
these rows correspond to different categories of the response variable. For multivariate models, these correspond to
different response variables. The <code>category</code> argument specifies the name of the column
to put the category names (or variable names) into in the resulting data frame. The default name of this column
(<code>".category"</code>) reflects the fact that this functionality was originally used only for ordinal models and
has been re-used for multivariate models. The fact that multiple rows per response are returned only for some
model types reflects the fact that tidybayes takes the approach of tidying whatever output is given to us, and
the output from different modeling functions differs on this point.
See <code>vignette("tidy-brms")</code> and <code>vignette("tidy-rstanarm")</code> for examples of dealing with output
from ordinal models using both approaches.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dpar</code></td>
<td>
<p>For <code>add_epred_draws()</code> and <code>add_linpred_draws()</code>: Should distributional regression
parameters be included in the output? Valid only for models that support distributional regression parameters,
such as submodels for variance parameters (as in <code>brms::brm()</code>). If <code>TRUE</code>, distributional regression
parameters are included in the output as additional columns named after each parameter
(alternative names can be provided using a list or named vector, e.g. <code>c(sigma.hat = "sigma")</code>
would output the <code>"sigma"</code> parameter from a model as a column named <code>"sigma.hat"</code>).
If <code>NULL</code> or <code>FALSE</code> (the default), distributional regression parameters are not included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>(Deprecated). Use <code>ndraws</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>(Deprecated). Use the appropriate function (<code>epred_draws()</code> or <code>linpred_draws()</code>)
depending on what type of distribution you want. For <code>linpred_draws()</code>, you may want the
<code>transform</code> argument. See <code>rstanarm::posterior_linpred()</code> or <code>brms::posterior_linpred()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prediction, residual</code></td>
<td>
<p>(Deprecated). Use <code>value</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider a model like:
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}
y &amp;\sim&amp; \textrm{SomeDist}(\theta_1, \theta_2)\\
f_1(\theta_1) &amp;=&amp; \alpha_1 + \beta_1 x\\
f_2(\theta_2) &amp;=&amp; \alpha_2 + \beta_2 x
\end{array}</code>
</p>

<p>This model has:
</p>

<ul>
<li>
<p> an outcome variable, <code class="reqn">y</code>
</p>
</li>
<li>
<p> a response distribution, <code class="reqn">\textrm{SomeDist}</code>, having parameters <code class="reqn">\theta_1</code>
(with link function <code class="reqn">f_1</code>) and <code class="reqn">\theta_2</code> (with link function <code class="reqn">f_2</code>)
</p>
</li>
<li>
<p> a single predictor, <code class="reqn">x</code>
</p>
</li>
<li>
<p> coefficients <code class="reqn">\alpha_1</code>, <code class="reqn">\beta_1</code>, <code class="reqn">\alpha_2</code>, and <code class="reqn">\beta_2</code>
</p>
</li>
</ul>
<p>We fit this model to some observed data, <code class="reqn">y_\textrm{obs}</code>, and predictors,
<code class="reqn">x_\textrm{obs}</code>. Given new values of predictors, <code class="reqn">x_\textrm{new}</code>,
supplied in the data frame <code>newdata</code>, the functions for posterior draws are
defined as follows:
</p>

<ul>
<li> <p><code>add_predicted_draws()</code> adds draws from the <strong>posterior predictive distribution</strong>,
<code class="reqn">p(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code>rstanarm::posterior_predict()</code> or <code>brms::posterior_predict()</code>.
</p>
</li>
<li> <p><code>add_epred_draws()</code> adds draws from the <strong>expectation of the posterior predictive
distribution</strong>, aka the conditional expectation,
<code class="reqn">E(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code>rstanarm::posterior_epred()</code> or <code>brms::posterior_epred()</code>.
Not all models support this function.
</p>
</li>
<li> <p><code>add_linpred_draws()</code> adds draws from the <strong>posterior linear predictors</strong> to the data.
It corresponds to <code>rstanarm::posterior_linpred()</code> or <code>brms::posterior_linpred()</code>.
Depending on the model type and additional parameters passed, this may be:
</p>

<ul>
<li>
<p> The untransformed linear predictor, e.g.
<code class="reqn">p(f_1(\theta_1) | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(\alpha_1 + \beta_1 x_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_draws(transform = FALSE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "link"</code> in <code>predict.glm()</code>.
</p>
</li>
<li>
<p> The inverse-link transformed linear predictor, e.g.
<code class="reqn">p(\theta_1 | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(f_1^{-1}(\alpha_1 + \beta_1 x_\textrm{new}) | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_draws(transform = TRUE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "response"</code> in <code>predict.glm()</code>.
</p>
</li>
</ul>
<p><strong>NOTE:</strong> <code>add_linpred_draws(transform = TRUE)</code> and <code>add_epred_draws()</code> may be equivalent but
are not guaranteed to be. They are equivalent when the expectation of the response
distribution is equal to its first parameter, i.e. when <code class="reqn">E(y) = \theta_1</code>. Many
distributions have this property (e.g. Normal distributions, Bernoulli distributions),
but not all. If you want the expectation of the posterior predictive, it is best to
use <code>add_epred_draws()</code> if available, and if not available, verify this property holds prior
to using <code>add_linpred_draws()</code>.
</p>
</li>
<li> <p><code>add_residual_draws()</code> adds draws from residuals,
<code class="reqn">p(y_\textrm{obs} - y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code>brms::residuals.brmsfit()</code>.
</p>
</li>
</ul>
<p>The corresponding functions without <code>add_</code> as a prefix are alternate spellings
with the opposite order of the first two arguments: e.g. <code>add_predicted_draws(newdata, object)</code>
versus <code>predicted_draws(object, newdata)</code>. This facilitates use in data
processing pipelines that start either with a data frame or a model.
</p>
<p>Given equal choice between the two, the spellings prefixed with <code>add_</code>
are preferred.
</p>


<h3>Value</h3>

<p>A data frame (actually, a tibble) with a <code>.row</code> column (a
factor grouping rows from the input <code>newdata</code>), <code>.chain</code> column (the chain
each draw came from, or <code>NA</code> if the model does not provide chain information),
<code>.iteration</code> column (the iteration the draw came from, or <code>NA</code> if the model does
not provide iteration information), and a <code>.draw</code> column (a unique index corresponding to each draw
from the distribution). In addition, <code>epred_draws</code> includes a column with its name specified by
the <code>epred</code> argument (default <code>".epred"</code>); <code>linpred_draws</code> includes a column with its name
specified by the <code>linpred</code> argument (default <code>".linpred"</code>), and
<code>predicted_draws</code> contains a column with its name specified by the <code>.prediction</code> argument (default
<code>".prediction"</code>). For convenience, the resulting data frame comes grouped by the original input rows.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code>add_draws()</code> for the variant of these functions for use with packages that do not have
explicit support for these functions yet. See <code>spread_draws()</code> for manipulating posteriors directly.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

library(ggplot2)
library(dplyr)
library(brms)
library(modelr)

theme_set(theme_light())

m_mpg = brm(mpg ~ hp * cyl, data = mtcars,
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# draw 100 lines from the posterior means and overplot them
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  # NOTE: only use ndraws here when making spaghetti plots; for
  # plotting intervals it is always best to use all draws (omit ndraws)
  add_epred_draws(m_mpg, ndraws = 100) %&gt;%
  ggplot(aes(x = hp, y = mpg, color = ordered(cyl))) +
  geom_line(aes(y = .epred, group = paste(cyl, .draw)), alpha = 0.25) +
  geom_point(data = mtcars)

# plot posterior predictive intervals
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  add_predicted_draws(m_mpg) %&gt;%
  ggplot(aes(x = hp, y = mpg, color = ordered(cyl))) +
  stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), alpha = 0.25) +
  geom_point(data = mtcars) +
  scale_fill_brewer(palette = "Greys")


## End(Not run)
</code></pre>


</div>