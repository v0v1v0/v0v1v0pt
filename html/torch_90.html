<div class="container">

<table style="width: 100%;"><tr>
<td>linalg_pinv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes the pseudoinverse (Moore-Penrose inverse) of a matrix.</h2>

<h3>Description</h3>

<p>The pseudoinverse may be <code style="white-space: pre;">⁠defined algebraically⁠</code>_
but it is more computationally convenient to understand it <code style="white-space: pre;">⁠through the SVD⁠</code>_
Supports input of float, double, cfloat and cdouble dtypes.
Also supports batches of matrices, and if <code>A</code> is a batch of matrices then
the output has the same batch dimensions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">linalg_pinv(A, rcond = NULL, hermitian = FALSE, atol = NULL, rtol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(Tensor): tensor of shape <code style="white-space: pre;">⁠(*, m, n)⁠</code> where <code>*</code> is zero or more batch dimensions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rcond</code></td>
<td>
<p>(float or Tensor, optional): the tolerance value to determine when is a singular value zero
If it is a <code>torch_Tensor</code>, its shape must be
broadcastable to that of the singular values of
<code>A</code> as returned by <code>linalg_svd()</code>.
Alias for <code>rtol</code>.
Default: <code>0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hermitian</code></td>
<td>
<p>(bool, optional): indicates whether <code>A</code> is Hermitian if complex
or symmetric if real. Default: <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atol</code></td>
<td>
<p>the absolute tolerance value. When <code>NULL</code> it’s considered to be zero.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rtol</code></td>
<td>
<p>the relative tolerance value. See above for the value it takes when <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>hermitian= TRUE</code>, <code>A</code> is assumed to be Hermitian if complex or
symmetric if real, but this is not checked internally. Instead, just the lower
triangular part of the matrix is used in the computations.
The singular values (or the norm of the eigenvalues when <code>hermitian= TRUE</code>)
that are below the specified <code>rcond</code> threshold are treated as zero and discarded
in the computation.
</p>


<h3>Note</h3>

<p>This function uses <code>linalg_svd()</code> if <code>hermitian= FALSE</code> and
<code>linalg_eigh()</code> if <code>hermitian= TRUE</code>.
For CUDA inputs, this function synchronizes that device with the CPU.
</p>
<p>Consider using <code>linalg_lstsq()</code> if possible for multiplying a matrix on the left by
the pseudoinverse, as <code>linalg_lstsq(A, B)$solution == A$pinv() %*% B</code>
</p>
<p>It is always prefered to use <code>linalg_lstsq()</code> when possible, as it is faster and more
numerically stable than computing the pseudoinverse explicitly.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>linalg_inv()</code> computes the inverse of a square matrix.
</p>
</li>
<li> <p><code>linalg_lstsq()</code> computes <code>A$pinv() %*% B</code> with a
numerically stable algorithm.
</p>
</li>
</ul>
<p>Other linalg: 
<code>linalg_cholesky_ex()</code>,
<code>linalg_cholesky()</code>,
<code>linalg_det()</code>,
<code>linalg_eigh()</code>,
<code>linalg_eigvalsh()</code>,
<code>linalg_eigvals()</code>,
<code>linalg_eig()</code>,
<code>linalg_householder_product()</code>,
<code>linalg_inv_ex()</code>,
<code>linalg_inv()</code>,
<code>linalg_lstsq()</code>,
<code>linalg_matrix_norm()</code>,
<code>linalg_matrix_power()</code>,
<code>linalg_matrix_rank()</code>,
<code>linalg_multi_dot()</code>,
<code>linalg_norm()</code>,
<code>linalg_qr()</code>,
<code>linalg_slogdet()</code>,
<code>linalg_solve_triangular()</code>,
<code>linalg_solve()</code>,
<code>linalg_svdvals()</code>,
<code>linalg_svd()</code>,
<code>linalg_tensorinv()</code>,
<code>linalg_tensorsolve()</code>,
<code>linalg_vector_norm()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
A &lt;- torch_randn(3, 5)
linalg_pinv(A)
}
</code></pre>


</div>