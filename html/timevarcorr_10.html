<div class="container">

<table style="width: 100%;"><tr>
<td>CI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal functions for the computation of confidence intervals</h2>

<h3>Description</h3>

<p>These functions compute the different terms required for <code>tcor()</code> to compute the confidence
interval around the time-varying correlation coefficient. These terms are defined in Choi &amp; Shin (2021).
</p>


<h3>Usage</h3>

<pre><code class="language-R">calc_H(smoothed_obj)

calc_e(smoothed_obj, H)

calc_Gamma(e, l)

calc_GammaINF(e, L)

calc_L_And(e, AR.method = c("yule-walker", "burg", "ols", "mle", "yw"))

calc_D(smoothed_obj)

calc_SE(
  smoothed_obj,
  h,
  AR.method = c("yule-walker", "burg", "ols", "mle", "yw")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>smoothed_obj</code></td>
<td>
<p>an object created with <code>calc_rho</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>H</code></td>
<td>
<p>an object created with <code>calc_H</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e</code></td>
<td>
<p>an object created with <code>calc_e</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l</code></td>
<td>
<p>a scalar indicating a number of time points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>a scalar indicating a bandwidth parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>AR.method</code></td>
<td>
<p>character string specifying the method to fit the autoregressive model used to compute <code class="reqn">\hat{\gamma}_1</code> in <code class="reqn">L_{And}</code> (see <code>stats::ar</code> for details).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>a scalar indicating the bandwidth used by the smoothing function.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li> <p><code>calc_H()</code> returns a 5 x 5 x <code class="reqn">t</code> array of elements of class numeric, which corresponds to <code class="reqn">\hat{H_t}</code> in Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_e()</code> returns a <code class="reqn">t</code> x 5 matrix of elements of class numeric storing the residuals, which corresponds to <code class="reqn">\hat{e}_t</code> in Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_Gamma()</code> returns a 5 x 5 matrix of elements of class numeric, which corresponds to <code class="reqn">\hat{\Gamma}_l</code> in Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_GammaINF()</code> returns a 5 x 5 matrix of elements of class numeric, which corresponds to <code class="reqn">\hat{\Gamma}^\infty</code> in Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_L_And()</code> returns a scalar of class numeric, which corresponds to <code class="reqn">L_{And}</code> in Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_D()</code> returns a <code class="reqn">t</code> x 5 matrix of elements of class numeric storing the residuals, which corresponds to <code class="reqn">D_t</code> in Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_SE()</code> returns a vector of length <code class="reqn">t</code> of elements of class numeric, which corresponds to <code class="reqn">se(\hat{\rho}_t(h))</code> in Choi &amp; Shin (2021).
</p>
</li>
</ul>
<h3>Functions</h3>


<ul>
<li> <p><code>calc_H()</code>: computes the <code class="reqn">\hat{H_t}</code> array.
</p>
<p><code class="reqn">\hat{H_t}</code> is a component needed to compute confidence intervals;
<code class="reqn">H_t</code> is defined in eq. 6 from Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_e()</code>: computes <code class="reqn">\hat{e}_t</code>.
</p>
<p><code class="reqn">\hat{e}_t</code> is defined in eq. 9 from Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_Gamma()</code>: computes <code class="reqn">\hat{\Gamma}_l</code>.
</p>
<p><code class="reqn">\hat{\Gamma}_l</code> is defined in eq. 9 from Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_GammaINF()</code>: computes <code class="reqn">\hat{\Gamma}^\infty</code>.
</p>
<p><code class="reqn">\hat{\Gamma}^\infty</code> is the long run variance estimator, defined in eq. 9 from Choi &amp; Shin (2021).
</p>
</li>
<li> <p><code>calc_L_And()</code>: computes <code class="reqn">L_{And}</code>.
</p>
<p><code class="reqn">L_{And}</code> is defined in Choi &amp; Shin (2021, p 342).
It also corresponds to <code class="reqn">S_T^*</code>, eq 5.3 in Andrews (1991).
</p>
</li>
<li> <p><code>calc_D()</code>: computes <code class="reqn">D_t</code>.
</p>
<p><code class="reqn">D_t</code> is defined in Choi &amp; Shin (2021, p 338).
</p>
</li>
<li> <p><code>calc_SE()</code>: computes <code class="reqn">se(\hat{\rho}_t(h))</code>.
</p>
<p>The standard deviation of the time-varying correlation (<code class="reqn">se(\hat{\rho}_t(h))</code>) is defined in eq. 8 from Choi &amp; Shin (2021).
It depends on <code class="reqn">D_{Lt}</code>, <code class="reqn">D_{Mt}</code> &amp; <code class="reqn">D_{Ut}</code>, themselves defined in Choi &amp; Shin (2021, p 337 &amp; 339).
The <code class="reqn">D_{Xt}</code> terms are all computed within the function since they all rely on the same components.
</p>
</li>
</ul>
<h3>References</h3>

<p>Choi, JE., Shin, D.W. Nonparametric estimation of time varying correlation coefficient.
J. Korean Stat. Soc. 50, 333â€“353 (2021). <a href="https://doi.org/10.1007/s42952-020-00073-6">doi:10.1007/s42952-020-00073-6</a>
</p>
<p>Andrews, D. W. K. Heteroskedasticity and autocorrelation consistent covariance matrix estimation.
Econometrica: Journal of the Econometric Society, 817-858 (1991).
</p>


<h3>See Also</h3>

<p><code>tcor()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">rho_obj &lt;- with(na.omit(stockprice),
                calc_rho(x = SP500, y = FTSE100, t = DateID, h = 20, kernel = "box"))
head(rho_obj)

## Computing \eqn{\hat{H_t}}

H &lt;- calc_H(smoothed_obj = rho_obj)
H[, , 1:2] # H array for the first two time points

## Computing \eqn{\hat{e}_t}

e &lt;- calc_e(smoothed_obj = rho_obj, H = H)
head(e) # e matrix for the first six time points

## Computing \eqn{\hat{\Gamma}_l}

calc_Gamma(e = e, l = 3)

## Computing \eqn{\hat{\Gamma}^\infty}

calc_GammaINF(e = e, L = 2)

## Computing \eqn{L_{And}}

calc_L_And(e = e)
sapply(c("yule-walker", "burg", "ols", "mle", "yw"),
       function(m) calc_L_And(e = e, AR.method = m)) ## comparing AR.methods

## Computing \eqn{D_t}

D &lt;- calc_D(smoothed_obj = rho_obj)
head(D) # D matrix for the first six time points

## Computing \eqn{se(\hat{\rho}_t(h))}
# nb: takes a few seconds to run

run &lt;- FALSE ## change to TRUE to run the example
if (in_pkgdown() || run) {

SE &lt;- calc_SE(smoothed_obj = rho_obj, h = 50)
head(SE) # SE vector for the first six time points

}


</code></pre>


</div>