<div class="container">

<table style="width: 100%;"><tr>
<td>seqformat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conversion between sequence formats</h2>

<h3>Description</h3>

<p>Convert a sequence data set from one format to another.
</p>


<h3>Usage</h3>

<pre><code class="language-R">seqformat(data, var = NULL, from, to, compress = FALSE, nrep = NULL, tevent,
  stsep = NULL, covar = NULL, SPS.in = list(xfix = "()", sdsep = ","),
  SPS.out = list(xfix = "()", sdsep = ","), id = 1, begin = 2, end = 3,
  status = 4, process = TRUE, pdata = NULL, pvar = NULL, limit = 100,
  overwrite = TRUE, fillblanks = NULL, tmin = NULL, tmax = NULL, missing = "*",
  with.missing = TRUE, right="DEL", compressed, nr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>Data frame, matrix, <code>stslist</code> state sequence object, or character string vector.
The data to use. (Tibble will be converted with <code>as.data.frame</code>).
</p>
<p>A data frame or a matrix with sequence data in one or more columns when
<code>from = "STS"</code> or <code>from = "SPS"</code>. If sequence data are in a single
column or in a string vector, they are assumed to be in the compressed form (see <code>stsep</code>).
</p>
<p>A data frame with sequence data in one or more columns when <code>from = "SPELL"</code>.
If sequence data has not four columns ordered as individual ID, spell
start time, spell end time, and spell state status, use <code>var</code> or
<code>id</code> / <code>begin</code> / <code>end</code> / <code>status</code>.
</p>
<p>A state sequence object when <code>from = "STS"</code> or <code>from</code> is not specified.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>

<p><code>NULL</code>, List of Integers or Strings.
Default: <code>NULL</code>.
The indexes or the names of the columns with the sequence data in <code>data</code>.
If <code>NULL</code>, all columns are considered.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>

<p>String.
The format of the input sequence data.
It can be <code>"STS"</code>, <code>"SPS"</code>, or <code>"SPELL"</code>. It is not needed
if <code>data</code> is a state sequence object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>

<p>String.
The format of the output data.
It can be <code>"STS"</code>, <code>"DSS"</code>, <code>"SPS"</code>, <code>"SRS"</code>, <code>"SPELL"</code>, or <code>"TSE"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compress</code></td>
<td>


<p>Logical.
Default: <code>FALSE</code>.
When <code>to = "STS"</code>, <code>to = "DSS"</code>, or <code>to = "SPS"</code>, should the
sequences (row vector of states) be concatenated into strings? See
<code>seqconc</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nrep</code></td>
<td>


<p>Integer.
The number of shifted replications when <code>to = "SRS"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tevent</code></td>
<td>


<p>Matrix.
The transition-definition matrix when <code>to = "TSE"</code>.
It should be of size <code class="reqn">d * d</code> where <code class="reqn">d</code> is the number of distinct
states appearing in the sequences. The cell <code class="reqn">(i,j)</code> lists the events
associated with a transition from state <code class="reqn">i</code> to state <code class="reqn">j</code>. It can be
created with <code>seqetm</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stsep</code></td>
<td>


<p><code>NULL</code>, Character.
Default: <code>NULL</code>.
The separator between states in the compressed form (strings) when
<code>from = "STS"</code> or <code>from = "SPS"</code>.
If <code>NULL</code>, <code>seqfcheck</code> is called for detecting automatically
a separator among "-" and ":". Other separators must be specified explicitly.
See <code>seqdecomp</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covar</code></td>
<td>


<p>List of Integers or Strings.
The indexes or the names of additional columns in <code>data</code> to include as
covariates in the output when <code>to = "SRS"</code>.
The covariates are replicated across the shifted replicated rows.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SPS.in</code></td>
<td>


<p>List.
Default: <code>list(xfix = "()", sdsep = ",")</code>.
The specifications for the state-duration couples in the input data when
<code>from = "SPS"</code>.
The first specification, <code>xfix</code>, specifies the prefix/suffix character.
Use a two-character string if the prefix and the suffix differ. Use
<code>xfix = ""</code> when no prefix/suffix are present. The second
specification, <code>sdsep</code>, specifies the state/duration separator.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>SPS.out</code></td>
<td>


<p>List.
Default: <code>list(xfix = "()", sdsep = ",")</code>.
The specifications for the state-duration couples in the output data when
<code>to = "SPS"</code>.
See <code>SPS.in</code> above.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>



<p><code>NULL</code>, Integer, String, List of Integers or Strings.
Default: <code>1</code>.
</p>
<p>When <code>from = "SPELL"</code>, the index or the name of the column containing
the individual IDs in <code>data</code> (after <code>var</code> filtering).
</p>
<p>When <code>to = "TSE"</code>, the index or the name of the column containing
the individual IDs in <code>data</code> (after <code>var</code> filtering) or the unique
individual IDs. If <code>id</code> is not manually specified, <code>id</code> is set as
<code>NULL</code> for backward compatibility with TraMineR 1.8-13 behaviour. If
<code>id</code> is manually or automatically set as <code>NULL</code>, the original
individual IDs are ignored and replaced by the indexes of the sequences in the
input data.
</p>
<p>When <code>from = "SPELL"</code> and <code>to = "TSE"</code>, the index or the name of
the column containing the individual IDs in <code>data</code> (after <code>var</code>
filtering). The TSE output will use the original individual IDs.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>begin</code></td>
<td>


<p>Integer or String.
Default: <code>2</code>.
The index or the name of the column containing the spell start times in
<code>data</code> (after <code>var</code> filtering) when <code>from = "SPELL"</code>.
Start times should be positive integers.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end</code></td>
<td>


<p>Integer or String.
Default: <code>3</code>.
The index or the name of the column containing the spell end times in
<code>data</code> (after <code>var</code> filtering) when <code>from = "SPELL"</code>.
End times should be positive integers.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status</code></td>
<td>


<p>Integer or String.
Default: <code>4</code>.
The index or the name of the column containing the spell statuses in
<code>data</code> (after <code>var</code> filtering) when <code>from = "SPELL"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>process</code></td>
<td>


<p>Logical.
Default: <code>TRUE</code>.
When <code>from = "SPELL"</code>, if <code>TRUE</code>, create sequences on a process
time axis, if <code>FALSE</code>, create sequences on a calendar time axis.


</p>
<p>This <code>process</code> argument as well as the associated <code>pdata</code> and <code>pvar</code>
arguments are intended for <code>data</code> containing spell data with calendar begin
and end times. When those times are ages, use <code>process = FALSE</code> with
<code>pdata=NULL</code> to use those ages as process times. Option <code>process = TRUE</code>
does currently not work for age times.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pdata</code></td>
<td>



<p><code>NULL</code>, <code>"auto"</code>, or data frame.
Default: <code>NULL</code>. (tibble will be converted with <code>as.data.frame</code>).
</p>
<p>If <code>NULL</code>, the start and end times of each spell are supposed to be, if
<code>process = TRUE</code>, ages, if <code>process = FALSE</code>, years when
<code>from = "SPELL"</code>.
</p>
<p>If <code>"auto"</code>, ages are computed using the start time of the first spell
of each individual as her/his birthdate when <code>from = "SPELL"</code> and
<code>process = TRUE</code>. For <code>from = "SPELL"</code> and <code>process = FALSE</code>, <code>"auto"</code> is equivalent to <code>NULL</code>.
</p>
<p>A data frame containing the ID and the birth time of the individuals when
<code>from = "SPELL"</code> or <code>to = "SPELL"</code>. Use <code>pvar</code> to specify
the column names. The ID is used to match the birth time of each individual
with the sequence data. The birth time should be integer. It is the start
time from which the positions on the time axis are computed. It also serves
to compute <code>tmin</code> and to guess <code>tmax</code> when the latter are <code>NULL</code>,
<code>from = "SPELL"</code>, and <code>process = FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvar</code></td>
<td>



<p>List of Integers or Strings.
The indexes or names of the columns of the data frame <code>pdata</code> that
contain the ID and the birth time of the individuals in that order.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limit</code></td>
<td>


<p>Integer.
Default: <code>100</code>.
The maximum age of age sequences when <code>from = "SPELL"</code> and <code>process = TRUE</code>.
Age sequences will be considered to start at 1 and to end at <code>limit</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>


<p>Logical.
Default: <code>TRUE</code>.
When <code>from = "SPELL"</code>, if <code>TRUE</code>, the most recent episode
overwrites the older one when they overlap each other, if <code>FALSE</code>,
in case of overlap, the most recent episode starts after the end of the
previous one.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fillblanks</code></td>
<td>


<p>Character.
The value to fill gaps between episodes when <code>from = "SPELL"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmin</code></td>
<td>


<p><code>NULL</code> or Integer.
Default: <code>NULL</code>.
The start time of the axis when <code>from = "SPELL"</code> and <code>process = FALSE</code>.
If <code>NULL</code>, the value is the minimum of the spell start times
(see <code>begin</code>) or the minimum of the birth time of the individuals
(see <code>pdata</code> when it is a data frame and <code>process = FALSE</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tmax</code></td>
<td>


<p><code>NULL</code> or Integer.
Default: <code>NULL</code>.
The end time of the axis when <code>from = "SPELL"</code> and <code>process = FALSE</code>.
If <code>NULL</code>, the value is the maximum of the spell end times (see <code>end</code>)
or the sum of the maximum of the spell end times and of the maximum of the
birth time of the individuals (see <code>pdata</code> when it is a data frame and
<code>process = FALSE</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>missing</code></td>
<td>

<p>String.
Default: <code>"*"</code>.
The code for missing states in <code>data</code>.
It will be replaced by <code>NA</code> in the output data. Ignored when <code>data</code> is a state sequence object
(see <code>seqdef</code>), in which case the attribute <code>nr</code> is used as missing value code.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.missing</code></td>
<td>


<p>Logical.
Default: <code>TRUE</code>.
When <code>to = "SPELL"</code>, should the spells of missing states be included?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>


<p>One of <code>"DEL"</code> or <code>NA</code>.
Default: <code>"DEL"</code>.
When <code>to = "SPELL"</code> and <code>with.missing=TRUE</code>, set <code>right=NA</code> to include the end spells of missing states.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compressed</code></td>
<td>

<p>Deprecated. Use <code>compress</code> instead.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr</code></td>
<td>

<p>Deprecated. Use <code>missing</code> instead.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>seqformat</code> function is used to convert data from one format to
another. The input data is first converted into the STS format and then
converted to the output format. Depending on input and output formats, some
information can be lost in the conversion process. The output is a matrix or
a data frame, NOT a sequence <code>stslist</code> object. To process, print or plot
the sequences with TraMineR functions, you will have to first transform the data frame
into a <code>stslist</code> state sequence object with <code>seqdef</code>.
See <cite>Gabadinho et al. (2009)</cite> and <cite>Ritschard et al. (2009)</cite> for more
details on longitudinal data formats and converting between them.
</p>
<p>When data are in <code>"SPELL"</code> format (<code>from = "SPELL"</code>), the begin and end times are expected to be positions in the sequences. Therefore they should be strictly positive integers.
With <code>process=TRUE</code>, the outcome sequences will be aligned on ages (process duration since birth), while with <code>process=FALSE</code> they will be aligned on dates (position on the calendar time). If <code>process=TRUE</code>, values in the <code>begin</code> and <code>end</code> columns of <code>data</code> are assumed to be ages when <code>pdata</code> is <code>NULL</code> and integer dates otherwise. If <code>process=FALSE</code>, begin and end values are assumed to be integer dates when <code>pdata</code> is <code>NULL</code> and ages otherwise.
</p>
<p>To convert from person-period data use <code>from = "SPELL"</code> and set both <code>begin</code> and <code>end</code> as the column index or name of the time variable. Alternatively, use the <code>reshape</code> command of <code>stats</code>, which is more efficient.
</p>


<h3>Value</h3>

<p>A data frame for <code>SRS</code>, <code>TSE</code>, and <code>SPELL</code>, a matrix otherwise.
</p>
<p>When <code>from="SPELL"</code>, outcome has an attribute <code>issues</code> with indexes of sequences with issues (truncated sequences, missing start time, spells before birth year, ...)
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho, Pierre-Alexandre Fonta, Nicolas S. Müller, Matthias Studer,
and Gilbert Ritschard.
</p>


<h3>References</h3>

<p>Gabadinho, A., G. Ritschard, M. Studer and N. S. Müller (2009). Mining
Sequence Data in <code>R</code> with the <code>TraMineR</code> package: A user's guide.
Department of Econometrics and Laboratory of Demography, University of Geneva.
</p>
<p>Ritschard, G., A. Gabadinho, M. Studer and N. S. Müller. Converting between
various sequence representations. in Ras, Z. &amp; Dardzinska, A. (eds.)
<em>Advances in Data Management</em>, Springer, 2009, 223, 155-175.
</p>


<h3>See Also</h3>

<p><code>seqdef</code>,<code>reshape</code></p>


<h3>Examples</h3>

<pre><code class="language-R">## ========================================
## Examples with raw STS sequences as input
## ========================================

## Loading a data frame with sequence data in the columns 13 to 24
data(actcal)

## Converting to SPS format
actcal.SPS.A &lt;- seqformat(actcal, 13:24, from = "STS", to = "SPS")
head(actcal.SPS.A)

## Converting to compressed SPS format with no
## prefix/suffix and with "/" as state/duration separator
actcal.SPS.B &lt;- seqformat(actcal, 13:24, from = "STS", to = "SPS",
  compress = TRUE, SPS.out = list(xfix = "", sdsep = "/"))
head(actcal.SPS.B)

## Converting to compressed DSS format
actcal.DSS &lt;- seqformat(actcal, 13:24, from = "STS", to = "DSS",
  compress = TRUE)
head(actcal.DSS)


## ==============================================
## Examples with a state sequence object as input
## ==============================================

## Loading a data frame with sequence data in the columns 10 to 25
data(biofam)

## Limiting the number of considered cases to the first 20
biofam &lt;- biofam[1:20, ]

## Creating a state sequence object
biofam.labs &lt;- c("Parent", "Left", "Married", "Left/Married",
  "Child", "Left/Child", "Left/Married/Child", "Divorced")
biofam.short.labs &lt;- c("P", "L", "M", "LM", "C", "LC", "LMC", "D")
biofam.seq &lt;- seqdef(biofam, 10:25, alphabet = 0:7,
  states = biofam.short.labs, labels = biofam.labs)

## Converting to SPELL format
bf.spell &lt;- seqformat(biofam.seq, from = "STS", to = "SPELL",
  pdata = biofam, pvar = c("idhous", "birthyr"))
head(bf.spell)


## ======================================
## Examples with SPELL sequences as input
## ======================================

## Loading two data frames: bfspell20 and bfpdata20
## bfspell20 contains the first 20 biofam sequences in SPELL format
## bfpdata20 contains the IDs and the years at which the
## considered individuals were aged 15
data(bfspell)

## Converting to STS format with alignement on calendar years
bf.sts.y &lt;- seqformat(bfspell20, from = "SPELL", to = "STS",
  id = "id", begin = "begin", end = "end", status = "states",
  process = FALSE)
head(bf.sts.y)

## Converting to STS format with alignement on ages
bf.sts.a &lt;- seqformat(bfspell20, from = "SPELL", to = "STS",
  id = "id", begin = "begin", end = "end", status = "states",
  process = TRUE, pdata = bfpdata20, pvar = c("id", "when15"),
  limit = 16)
names(bf.sts.a) &lt;- paste0("a", 15:30)
head(bf.sts.a)


## ==================================
## Examples for TSE and SPELL output
## in presence of missing values
## ==================================

data(ex1) ## STS data with missing values
## creating the state sequence object with by default
## the end missings coded as void ('%')
sqex1 &lt;- seqdef(ex1[,1:13])
as.matrix(sqex1)

## Creating state-event transition matrices
ttrans &lt;- seqetm(sqex1, method='transition')
tstate &lt;- seqetm(sqex1, method='state')

## Converting into time stamped events
seqformat(sqex1, from = "STS", to = "TSE", tevent = ttrans)
seqformat(sqex1, from = "STS", to = "TSE", tevent = tstate)

## Converting into vertical spell data
seqformat(sqex1, from = "STS", to = "SPELL", with.missing=TRUE)
seqformat(sqex1, from = "STS", to = "SPELL", with.missing=TRUE, right=NA)
seqformat(sqex1, from = "STS", to = "SPELL", with.missing=FALSE)
</code></pre>


</div>