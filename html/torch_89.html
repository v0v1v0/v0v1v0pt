<div class="container">

<table style="width: 100%;"><tr>
<td>linalg_norm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes a vector or matrix norm.</h2>

<h3>Description</h3>

<p>If <code>A</code> is complex valued, it computes the norm of <code>A$abs()</code>
Supports input of float, double, cfloat and cdouble dtypes.
Whether this function computes a vector or matrix norm is determined as follows:
</p>


<h3>Usage</h3>

<pre><code class="language-R">linalg_norm(A, ord = NULL, dim = NULL, keepdim = FALSE, dtype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(Tensor): tensor of shape <code style="white-space: pre;">⁠(*, n)⁠</code> or <code style="white-space: pre;">⁠(*, m, n)⁠</code> where <code>*</code> is zero or more batch dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ord</code></td>
<td>
<p>(int, float, inf, -inf, 'fro', 'nuc', optional): order of norm. Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>(int, Tupleint, optional): dimensions over which to compute
the vector or matrix norm. See above for the behavior when <code>dim=NULL</code>.
Default: <code>NULL</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keepdim</code></td>
<td>
<p>(bool, optional): If set to <code>TRUE</code>, the reduced dimensions are retained
in the result as dimensions with size one. Default: <code>FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtype</code></td>
<td>
<p>dtype (<code>torch_dtype</code>, optional): If specified, the input tensor is cast to
<code>dtype</code> before performing the operation, and the returned tensor's type
will be <code>dtype</code>. Default: <code>NULL</code></p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p> If <code>dim</code> is an int, the vector norm will be computed.
</p>
</li>
<li>
<p> If <code>dim</code> is a 2-tuple, the matrix norm will be computed.
</p>
</li>
<li>
<p> If <code>dim=NULL</code> and <code>ord=NULL</code>, A will be flattened to 1D and the 2-norm of the resulting vector will be computed.
</p>
</li>
<li>
<p> If <code>dim=NULL</code> and <code>ord!=NULL</code>, A must be 1D or 2D.
</p>
</li>
</ul>
<p><code>ord</code> defines the norm that is computed. The following norms are
supported:</p>

<table>
<tr>
<td style="text-align: left;">
   <code>ord</code> </td>
<td style="text-align: left;"> norm for matrices </td>
<td style="text-align: left;"> norm for vectors </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>NULL</code> (default) </td>
<td style="text-align: left;"> Frobenius norm </td>
<td style="text-align: left;"> <code>2</code>-norm (see below) </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"fro"</code> </td>
<td style="text-align: left;"> Frobenius norm </td>
<td style="text-align: left;"> – not supported – </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>"nuc"</code> </td>
<td style="text-align: left;"> nuclear norm </td>
<td style="text-align: left;"> – not supported – </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>Inf</code> </td>
<td style="text-align: left;"> <code>max(sum(abs(x), dim=2))</code> </td>
<td style="text-align: left;"> <code>max(abs(x))</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>-Inf</code> </td>
<td style="text-align: left;"> <code>min(sum(abs(x), dim=2))</code> </td>
<td style="text-align: left;"> <code>min(abs(x))</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>0</code> </td>
<td style="text-align: left;"> – not supported – </td>
<td style="text-align: left;"> <code>sum(x != 0)</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>1</code> </td>
<td style="text-align: left;"> <code>max(sum(abs(x), dim=1))</code> </td>
<td style="text-align: left;"> as below </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>-1</code> </td>
<td style="text-align: left;"> <code>min(sum(abs(x), dim=1))</code> </td>
<td style="text-align: left;"> as below </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>2</code> </td>
<td style="text-align: left;"> largest singular value </td>
<td style="text-align: left;"> as below </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>-2</code> </td>
<td style="text-align: left;"> smallest singular value </td>
<td style="text-align: left;"> as below </td>
</tr>
<tr>
<td style="text-align: left;">
   other <code>int</code> or <code>float</code> </td>
<td style="text-align: left;"> – not supported – </td>
<td style="text-align: left;"> <code>sum(abs(x)^{ord})^{(1 / ord)}</code> </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>See Also</h3>

<p>Other linalg: 
<code>linalg_cholesky_ex()</code>,
<code>linalg_cholesky()</code>,
<code>linalg_det()</code>,
<code>linalg_eigh()</code>,
<code>linalg_eigvalsh()</code>,
<code>linalg_eigvals()</code>,
<code>linalg_eig()</code>,
<code>linalg_householder_product()</code>,
<code>linalg_inv_ex()</code>,
<code>linalg_inv()</code>,
<code>linalg_lstsq()</code>,
<code>linalg_matrix_norm()</code>,
<code>linalg_matrix_power()</code>,
<code>linalg_matrix_rank()</code>,
<code>linalg_multi_dot()</code>,
<code>linalg_pinv()</code>,
<code>linalg_qr()</code>,
<code>linalg_slogdet()</code>,
<code>linalg_solve_triangular()</code>,
<code>linalg_solve()</code>,
<code>linalg_svdvals()</code>,
<code>linalg_svd()</code>,
<code>linalg_tensorinv()</code>,
<code>linalg_tensorsolve()</code>,
<code>linalg_vector_norm()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
a &lt;- torch_arange(0, 8, dtype = torch_float()) - 4
a
b &lt;- a$reshape(c(3, 3))
b

linalg_norm(a)
linalg_norm(b)
}
</code></pre>


</div>