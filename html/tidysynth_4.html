<div class="container">

<table style="width: 100%;"><tr>
<td>generate_weights</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>generate_weights</h2>

<h3>Description</h3>

<p>Generates weights from the the aggregate-level predictors to generate the
synthetic control. These weights determine which variable and which unit from
the donor pool is important in generating the synthetic control.
</p>


<h3>Usage</h3>

<pre><code class="language-R">generate_weights(
  data,
  optimization_window = NULL,
  custom_variable_weights = NULL,
  include_fit = FALSE,
  optimization_method = c("Nelder-Mead", "BFGS"),
  genoud = FALSE,
  quadopt = "ipop",
  margin_ipop = 5e-04,
  sigf_ipop = 5,
  bound_ipop = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>nested data of type <code>tbl_df</code> generated from <code>sythetic_control()</code>.
See <code>synthetic_control()</code> documentation for more information. In addition,
a matrix of predictors must be prespecified using the
<code>generate_predictor()</code> function. See documentation for more information on
how to generate a predictor function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimization_window</code></td>
<td>
<p>the temporal window of the pre-intervention
outcome time series to be used in the optimization task. Default behavior
uses the entire pre-intervention time period.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>custom_variable_weights</code></td>
<td>
<p>a vector of provided weights that define a
variable's importance in the optimization task. The weights are intended to
reflect the users prior regarding the relative significance of each
variable. Vector must sum to one. Note that the method is significantly
faster when a custom variable weights are provided. Default behavior
assumes no wieghts are provided and thus must be learned from the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>include_fit</code></td>
<td>
<p>Boolean flag, if TRUE, then the optimization output is
included in the outputted <code>tbl_df</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimization_method</code></td>
<td>
<p>string vector that specifies the optimization
algorithms to be used. Permissable values are all optimization algorithms
that are currently implemented in the optimx function (see this function
for details). This list currently includes c('Nelder-Mead', 'BFGS', 'CG',
'L-BFGS-B', 'nlm', 'nlminb', 'spg', and 'ucminf"). If multiple algorithms
are specified, synth will run the optimization with all chosen algorithms
and then return the result for the best performing method. Default is
c('Nelder-Mead','BFGS'). As an additional possibility, the user can also
specify 'All' which means that synth will run the results over all
algorithms in optimx.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genoud</code></td>
<td>
<p>Logical flag. If true, synth embarks on a two step
optimization. In the first step, genoud, an optimization function that
combines evolutionary algorithm methods with a derivative-based
(quasi-Newton) method to solve difficult optimization problems, is used to
obtain a solution. See genoud for details. In the second step, the genoud
results are passed to the optimization algorithm(s) chosen in optimxmethod
for a local optimization within the neighborhood of the genoud solution.
This two step optimization procedure will require much more computing time,
but may yield lower loss in cases where the search space is highly
irregular.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadopt</code></td>
<td>
<p>string vector that specifies the routine for quadratic
optimization over w weights. possible values are "ipop" and "LowRankQP"
(see ipop and LowRankQP for details). default is 'ipop'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin_ipop</code></td>
<td>
<p>setting for ipop optimization routine: how close we get to
the constrains (see ipop for details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigf_ipop</code></td>
<td>
<p>setting for ipop optimization routine: Precision (default: 7
significant figures (see ipop for details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bound_ipop</code></td>
<td>
<p>setting for ipop optimization routine: Clipping bound for
the variables (see ipop for details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical flag. If TRUE then intermediate results will be shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to optimx and or genoud to
adjust optimization.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Optimization</strong>
</p>
<p>The method completes the following nested minimization task:
</p>
<p style="text-align: center;"><code class="reqn">W^*(V) =  min \sum^M_{m=1} v_m (X_{1m} - \sum^{J+1}_{j=2}w_j X_{jm})^2</code>
</p>

<p>Where <code class="reqn">X_1</code> and <code class="reqn">X_0</code>, which are matrices of aggregate-level
covariates, are generated using the <code>generate_predictor()</code> function. <code class="reqn">V</code>
denotes the variable weights with <code class="reqn">M</code> reflecting the total number of
predictor variables. Thus, the optimal weights are a function of <code class="reqn">V</code>.
</p>
<p>The weights themselves are optimized via the following:
</p>
<p style="text-align: center;"><code class="reqn">\sum^{T_0}_{t=1}(Y_{1t} - \sum^{J=1}_{j=2}w^*_j(V)Y_{jt})^2</code>
</p>

<p>where <code class="reqn">T_0</code> denotes the pre-intervention period (or a specific
optimization window supplied by the argument <code>time_window</code>); <code class="reqn">J</code> denotes
the number of control units from the donor pool, where <code class="reqn">j=1</code> reflects the
treated unit.
</p>
<p>Thus, the weights are selected in a manner that produces a synthetic
<code class="reqn">\hat{Y}</code> that approximates the observed <code class="reqn">Y</code> as closely as possible.
</p>
<p><strong>Variable Weights</strong>
</p>
<p>As proposed in Abadie and Gardeazabal (2003) and Abadie, Diamond, Hainmueller
(2010), the synth function routinely searches for the set of weights that
generate the best fitting convex combination of the control units. In other
words, the predictor weight matrix V (<code>custom_variable_weights</code>) is chosen
among all positive definite diagonal matrices such that MSPE is minimized for
the pre-intervention period. Instead of using this data-driven procedures to
search for the best fitting synthetic control group, the user may supply
their own weights using the <code>custom_variable_weights</code> argument. These weights
reflect the user's subjective assessment of the predictive power of the
variables generated by <code>generate_predictor()</code>.
</p>
<p>When generating weights for the placebo cases, the variable weights used for
the fit of the treated unit optimization. This ensures comparability between
the placebo and treated fits. In addition, it greatly decreases processing
time as the variable weights do not be learned for every placebo entry.
</p>


<h3>Value</h3>

<p><code>tbl_df</code> with nested fields containing the following:
</p>

<ul>
<li> <p><code>.id</code>: unit id for the intervention case (this will differ when a placebo
unit).
</p>
</li>
<li> <p><code>.placebo</code>: indicator field taking on the value of 1 if a unit is a
placebo unit, 0 if it's the specified treated unit.
</p>
</li>
<li> <p><code>.type</code>: type of the nested data construct: <code>treated</code> or <code>controls</code>.
Keeps tract of which data construct is located in <code>.outcome</code> field.
</p>
</li>
<li> <p><code>.outcome</code>: nested data construct containing the outcome variable
configured for the sythnetic control method. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.predictors</code>: nested data construct containing the covariate matrices
for the treated and control (donor) units. Data is configured into a wide
format for the optimization task.
</p>
</li>
<li> <p><code>.unit_weights</code>: Nested column of unit weights (i.e. how each unit from
the donor pool contributes to the synthetic control). Weights should sum to
</p>
</li>
</ul>
<ol><li> 
</li></ol>
<ul>
<li> <p><code>.predictor_weights</code>: Nested column of predictor variable weights (i.e.
the significance of each predictor in optimizing the weights that generate
the synthetic control). Weights should sum to 1. If variable weights are
provided, those variable weights are provided.
</p>
</li>
<li> <p><code>.original_data</code>: original impute data filtered by treated or control
units. This allows for easy processing down stream when generating
predictors.
</p>
</li>
<li> <p><code>.meta</code>: stores information regarding the unit and time index, the
treated unit and time and the name of the outcome variable. Used downstream
in subsequent functions.
</p>
</li>
<li> <p><code>.loss</code>: the RMPE loss for both sets of weights.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">


# Smoking example data
data(smoking)

smoking_out &lt;-
smoking %&gt;%

# initial the synthetic control object
synthetic_control(outcome = cigsale,
                  unit = state,
                  time = year,
                  i_unit = "California",
                  i_time = 1988,
                  generate_placebos= TRUE) %&gt;%

# Generate the aggregate predictors used to generate the weights
  generate_predictor(time_window=1980:1988,
                     lnincome = mean(lnincome, na.rm = TRUE),
                     retprice = mean(retprice, na.rm = TRUE),
                     age15to24 = mean(age15to24, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1984:1988,
                     beer = mean(beer, na.rm = TRUE)) %&gt;%

  generate_predictor(time_window=1975,
                     cigsale_1975 = cigsale) %&gt;%

  generate_predictor(time_window=1980,
                     cigsale_1980 = cigsale) %&gt;%

  generate_predictor(time_window=1988,
                     cigsale_1988 = cigsale) %&gt;%


  # Generate the fitted weights for the synthetic control
  generate_weights(optimization_window =1970:1988,
                   Margin.ipop=.02,Sigf.ipop=7,Bound.ipop=6)

# Retrieve weights
smoking_out %&gt;% grab_predictor_weights()
smoking_out %&gt;% grab_unit_weights()

# Retrieve the placebo weights as well.
smoking_out %&gt;% grab_predictor_weights(placebo= TRUE)
smoking_out %&gt;% grab_unit_weights(placebo= TRUE)

# Plot the unit weights
smoking_out %&gt;% plot_weights()



</code></pre>


</div>