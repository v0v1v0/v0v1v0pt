<div class="container">

<table style="width: 100%;"><tr>
<td>nn_dropout2d</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dropout2D module</h2>

<h3>Description</h3>

<p>Randomly zero out entire channels (a channel is a 2D feature map,
e.g., the <code class="reqn">j</code>-th channel of the <code class="reqn">i</code>-th sample in the
batched input is a 2D tensor <code class="reqn">\mbox{input}[i, j]</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">nn_dropout2d(p = 0.5, inplace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(float, optional): probability of an element to be zero-ed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inplace</code></td>
<td>
<p>(bool, optional): If set to <code>TRUE</code>, will do this operation
in-place</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Each channel will be zeroed out independently on every forward call with
probability <code>p</code> using samples from a Bernoulli distribution.
Usually the input comes from nn_conv2d modules.
</p>
<p>As described in the paper
<a href="https://arxiv.org/abs/1411.4280">Efficient Object Localization Using Convolutional Networks</a> ,
if adjacent pixels within feature maps are strongly correlated
(as is normally the case in early convolution layers) then i.i.d. dropout
will not regularize the activations and will otherwise just result
in an effective learning rate decrease.
In this case, nn_dropout2d will help promote independence between
feature maps and should be used instead.
</p>


<h3>Shape</h3>


<ul>
<li>
<p> Input: <code class="reqn">(N, C, H, W)</code>
</p>
</li>
<li>
<p> Output: <code class="reqn">(N, C, H, W)</code> (same shape as input)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
m &lt;- nn_dropout2d(p = 0.2)
input &lt;- torch_randn(20, 16, 32, 32)
output &lt;- m(input)
}
</code></pre>


</div>