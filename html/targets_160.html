<div class="container">

<table style="width: 100%;"><tr>
<td>tar_outdated</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Check which targets are outdated.</h2>

<h3>Description</h3>

<p>Checks for outdated targets in the pipeline,
targets that will be rerun automatically if you call
<code>tar_make()</code> or similar. See <code>tar_cue()</code> for the rules
that decide whether a target needs to rerun.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tar_outdated(
  names = NULL,
  shortcut = targets::tar_config_get("shortcut"),
  branches = FALSE,
  targets_only = TRUE,
  reporter = targets::tar_config_get("reporter_outdated"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  seconds_interval = targets::tar_config_get("seconds_interval"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function, reporter),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Names of the targets. <code>tar_outdated()</code> will check
these targets and all upstream ancestors in the dependency graph.
Set <code>names</code> to <code>NULL</code> to check/build all the targets (default).
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code>any_of()</code> or <code>starts_with()</code>
from <code>tidyselect</code> itself, or <code>tar_described_as()</code> to select target names
based on their descriptions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
If <code>TRUE</code>, then the function only checks the targets in <code>names</code>
and uses stored metadata for information about upstream dependencies
as needed. <code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
Also, <code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>branches</code></td>
<td>
<p>Logical of length 1, whether to include branch names.
Including branches could get cumbersome for large pipelines.
Individual branch names are still omitted when branch-specific information
is not reliable: for example, when a pattern branches over
an outdated target.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targets_only</code></td>
<td>
<p>Logical of length 1, whether to just restrict to targets
or to include functions and other global objects from the environment
created by running the target script file (default: <code style="white-space: pre;">⁠_targets.R⁠</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seconds_interval</code></td>
<td>
<p>Deprecated on 2023-08-24 (version 1.2.2.9001).
Use <code>seconds_meta_append</code>, <code>seconds_meta_upload</code>,
and <code>seconds_reporter</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">⁠_targets.R⁠</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code>tar_make()</code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">⁠_targets.R⁠</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code>tar_script()</code>,
<code>tar_config_get()</code>, and <code>tar_config_set()</code> for details
about the target script file and how to set it
persistently for a project.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">⁠_targets/⁠</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code>tar_config_get()</code> and <code>tar_config_set()</code> for details
about how to set the data store path persistently
for a project.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Requires that you define a pipeline
with a target script file (default: <code style="white-space: pre;">⁠_targets.R⁠</code>).
(See <code>tar_script()</code> for details.)
</p>


<h3>Value</h3>

<p>Names of the outdated targets.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other inspect: 
<code>tar_deps()</code>,
<code>tar_manifest()</code>,
<code>tar_network()</code>,
<code>tar_sitrep()</code>,
<code>tar_validate()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)))
tar_outdated()
tar_script({
  library(targets)
  library(tarchetypes)
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_outdated()
})
}
</code></pre>


</div>