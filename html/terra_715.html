<div class="container">

<table style="width: 100%;"><tr>
<td>predict</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Spatial model predictions</h2>

<h3>Description</h3>

<p>Make a SpatRaster with predictions from a fitted model object (for example, obtained with <code>glm</code> or <code>randomForest</code>). The first argument is a SpatRaster object with the predictor variables. The <code>names</code> in the SpatRaster should exactly match those expected by the model. Any regression like model for which a predict method has been implemented (or can be implemented) can be used. 
</p>
<p>The method should work if the model's predict function returns a vector, matrix or data.frame (or a list that can be coerced to a data.frame). In other cases it may be necessary to provide a custom "predict" function that wraps the model's predict function to return the values in the required form. See the examples.
</p>
<p>This approach of using model predictions is commonly used in remote sensing (for the classification of satellite images) and in ecology, for species distribution modeling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S4 method for signature 'SpatRaster'
predict(object, model, fun=predict, ..., const=NULL, na.rm=FALSE,
          index=NULL, cores=1, cpkgs=NULL, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>SpatRaster</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>fitted model of any class that has a "predict" method (or for which you can supply a similar method as <code>fun</code> argument. E.g. glm, gam, or randomForest</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>function. The predict function that takes <code>model</code> as first argument. The default value is <code>predict</code>, but can be replaced with e.g. predict.se (depending on the type of model), or your own custom function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for <code>fun</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>const</code></td>
<td>
<p>data.frame. Can be used to add a constant value as a predictor variable so that you do not need to make a SpatRaster layer for it</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells with <code>NA</code> values in the any of the layers of <code>x</code> are removed from the computation (even if the <code>NA</code> cell is in a layer that is not used as a variable in the model). This option prevents errors with models that cannot handle <code>NA</code> values when makeing predictions. In most other cases this will not affect the output. However, there are some models that return predicted values even if some (or all) variables are <code>NA</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>integer or character. Can be used to to select a subset of the model output variables</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cpkgs</code></td>
<td>
<p>character. The package(s) that need to be loaded on the nodes to be able to run the model.predict function (see examples)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filename</code></td>
<td>
<p>character. Output filename</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wopt</code></td>
<td>
<p>list with named options for writing files as in <code>writeRaster</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code>interpolate</code> for spatial model prediction </p>


<h3>Examples</h3>

<pre><code class="language-R">logo &lt;- rast(system.file("ex/logo.tif", package="terra"))   
names(logo) &lt;- c("red", "green", "blue")
p &lt;- matrix(c(48, 48, 48, 53, 50, 46, 54, 70, 84, 85, 74, 84, 95, 85, 
   66, 42, 26, 4, 19, 17, 7, 14, 26, 29, 39, 45, 51, 56, 46, 38, 31, 
   22, 34, 60, 70, 73, 63, 46, 43, 28), ncol=2)

a &lt;- matrix(c(22, 33, 64, 85, 92, 94, 59, 27, 30, 64, 60, 33, 31, 9,
   99, 67, 15, 5, 4, 30, 8, 37, 42, 27, 19, 69, 60, 73, 3, 5, 21,
   37, 52, 70, 74, 9, 13, 4, 17, 47), ncol=2)

xy &lt;- rbind(cbind(1, p), cbind(0, a))

# extract predictor values for points
e &lt;- extract(logo, xy[,2:3])

# combine with response (excluding the ID column)
v &lt;- data.frame(cbind(pa=xy[,1], e))

#build a model, here with glm 
model &lt;- glm(formula=pa~., data=v)

#predict to a raster
r1 &lt;- predict(logo, model)

plot(r1)
points(p, bg='blue', pch=21)
points(a, bg='red', pch=21)

# logistic regression
model &lt;- glm(formula=pa~., data=v, family="binomial")
r1log &lt;- predict(logo, model, type="response")

# to get the probability and standard error
r1se &lt;- predict(logo, model, se.fit=TRUE)

# or provide a custom predict function

predfun &lt;- function(model, data) {
  v &lt;- predict(model, data, se.fit=TRUE)
  cbind(p=as.vector(v$fit), se=as.vector(v$se.fit))
}

r2 &lt;- predict(logo, model, fun=predfun)

### principal components of a SpatRaster
pca &lt;- prcomp(logo)

# or use sampling if you have a large raster 
# and cannot process all cell values
sr &lt;- spatSample(logo, 100000, "regular")
pca &lt;- prcomp(sr)

x &lt;- predict(logo, pca)
plot(x)

## parallelization
## Not run: 
## simple case with GLM 
model &lt;- glm(formula=pa~., data=v)
p &lt;- predict(logo, model, cores=2)

## The above does not work with a model from a contributed
## package, as the package needs to be loaded in each core. 
## Below are three approaches to deal with that 

library(randomForest)
rfm &lt;- randomForest(formula=pa~., data=v)

## approach 0 (not parallel) 
rp0 &lt;- predict(logo, rfm)

## approach 1, use the "cpkgs" argument 
rp1 &lt;- predict(logo, rfm, cores=2, cpkgs="randomForest")

## approach 2, write a custom predict function that loads the package
rfun &lt;- function(mod, dat, ...) {
	library(randomForest)
	predict(mod, dat, ...)
}
rp2 &lt;- predict(logo, rfm, fun=rfun, cores=2)

## approach 3, write a parallelized custom predict function 
rfun &lt;- function(mod, dat, ...) {
	ncls &lt;- length(cls)
	nr &lt;- nrow(dat)
	s &lt;- split(dat, rep(1:ncls, each=ceiling(nr/ncls), length.out=nr))
	unlist(  parallel::clusterApply(cls, s, function(x, ...) predict(mod, x, ...))  )
}

library(parallel)
cls &lt;- parallel::makeCluster(2)
parallel::clusterExport(cls, c("rfm", "rfun", "randomForest"))
rp3 &lt;- predict(logo, rfm, fun=rfun)
parallel::stopCluster(cls)

plot(c(rp0, rp1, rp2, rp3))


### with two output variables (probabilities for each class)
v$pa &lt;- as.factor(v$pa)
rfm2 &lt;- randomForest(formula=pa~., data=v)
rfp &lt;- predict(logo, rfm2, cores=2, type="prob", cpkgs="randomForest")

## End(Not run)

</code></pre>


</div>