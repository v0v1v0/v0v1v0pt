<div class="container">

<table style="width: 100%;"><tr>
<td>tardis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Text Analysis with Rules and Dictionaries for Inferring Sentiment (TARDIS)</h2>

<h3>Description</h3>

<p>This function uses dictionaries (either the included defaults or user-supplied)
custom dictionaries) and simple rules to measure the sentiment of supplied text.
"Sentiment" means roughly the emotion expressed in the text, where emotions are
collapsed into positive (e.g. happy) or negative (e.g. sad, angry).
</p>


<h3>Usage</h3>

<pre><code class="language-R">tardis(
  input_text = c("I am happy.", "I am VERY happy!!", ":)", "Not sad.", "Bad.",
    "Not bad.", "A happy sentence! And a sad one. In the same text."),
  text_column = NA,
  dict_sentiments = NA,
  dict_modifiers = NA,
  dict_negations = NA,
  sigmoid_factor = 15,
  negation_factor = 0.75,
  allcaps_factor = 1.25,
  punctuation_factor = 1.15,
  use_punctuation = TRUE,
  summary_function = c("mean", "median", "max", "min", "sum"),
  simple_count = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input_text</code></td>
<td>
<p>Text to analyze, either a character vector or a data.frame with a column of text.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>text_column</code></td>
<td>
<p>If using data.frame input, the name of the column of text to analyze.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dict_sentiments</code></td>
<td>
<p>Optional sentiment dictionary, defaults to internal tardis dictionary.
A data.frame with two columns: <code>word</code> and <code>value</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dict_modifiers</code></td>
<td>
<p>Optional modifiers dictionary, or "none" to disable modifiers.
Defaults to internal tardis dictionary. A data.frame with two columns: <code>word</code> and <code>value</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dict_negations</code></td>
<td>
<p>Optional negation dictionary, or "none" to disable negations.
Defaults to internal tardis dictionary. A data.frame with one column: <code>word</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigmoid_factor</code></td>
<td>
<p>Numeric, default 15. Factor for scaling sentence scores to -1/+1
using a sigmoid function. Set to NA to disable the sigmoid function
and just return sums of scores, adjusted by any applicable
negators, modifiers, or punctuation/caps effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>negation_factor</code></td>
<td>
<p>Numeric, default 0.75. Multiplier for damping effects of
sentiment-bearing terms after negations. Stacks multiplicatively.
Should probably be less than 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allcaps_factor</code></td>
<td>
<p>Numeric, default 1.25. Multiplier for scaling effects of
of sentiment-bearing terms in ALL CAPS. Should probably
be more than 1, to increase effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>punctuation_factor</code></td>
<td>
<p>Numeric, default 1.15. Multiplier for scaling effects of
punctuation. A single question mark has no effect, but
one or more exclamation marks does, and question marks
have effects in the presence of exclamation marks, up
to three punctuation marks total.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_punctuation</code></td>
<td>
<p>Boolean, default TRUE. Should we consider sentence-level punctuation?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary_function</code></td>
<td>
<p>For multi-sentence texts, how should we summarise sentence
scores into a text score? Default "mean", also accepts
"median", "max", "min", and "sum".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>simple_count</code></td>
<td>
<p>Boolean, default FALSE. Convenience parameter that overrides many
other parameters to enable simple counts of dictionary words:
no modifiers, negations, capitalization, or punctuation
effects are considered and no sigmoid function is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>For debugging–should it print lots of messages to the console?</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Roughly, each word's sentiment is a property of its dictionary-given sentiment,
whether it's written in all-caps or not, and the three preceding words. A preceding
negation (e.g. "not") will reverse and reduce the sentiment–turning a positive
into a slightly less extreme negative, or vice-versa–and a preceding modifier
can either increase/decrease the sentiment (e.g. "very" will increase it,
"somewhat" will decrease it).
</p>
<p>Sentences are scored based on their words and the presence of exclamation or
question marks.
</p>
<p>If a supplied text string has more than one sentence, this function will also
return the mean, standard deviation, and range of sentiments expressed in its
sentences. The rationale is that it doesn't make sense to apply sentence-level
analysis to paragraphs, especially for online communications where people can
use quick swings in sentiment to express irony.
</p>
<p>Input can be supplied in a data.frame or character vector.
</p>


<h3>Value</h3>

<p>A <code>tbl_df</code> with one row for each input text and three new columns:
<code>sentiment_mean</code>: the average sentiment for each sentence in each text.
<code>sentiment_sd</code>: the standard deviation of sentence sentiments for each text.
<code>sentiment_range</code>: the range of sentence sentiments for each text.
</p>


</div>