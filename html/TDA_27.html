<div class="container">

<table style="width: 100%;"><tr>
<td>kde</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Kernel Density Estimator over a Grid of Points
</h2>

<h3>Description</h3>

<p>Given a point cloud <code>X</code> (<code class="reqn">n</code> points), the function <code>kde</code> computes the Kernel Density Estimator over a grid of points. The kernel is a Gaussian Kernel with smoothing parameter <code>h</code>. For each <code class="reqn">x \in R^d</code>, the Kernel Density estimator is defined as
</p>
<p style="text-align: center;"><code class="reqn">
    p_X (x) = \frac{1}{n (\sqrt{2 \pi} h )^d} \sum_{i=1}^n \exp \left( \frac{- \Vert x-X_i \Vert_2^2}{2h^2} \right).
  </code>
</p>
   


<h3>Usage</h3>

<pre><code class="language-R">kde(X, Grid, h, kertype = "Gaussian", weight = 1,
    printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of points used in the kernel density estimation process, where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the dimension.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Grid</code></td>
<td>

<p>an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">m</code> is the number of points in the grid.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>

<p>number: the smoothing paramter of the Gaussian Kernel.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kertype</code></td>
<td>

<p>string: if <code>kertype = "Gaussian"</code>, Gaussian kernel is used, and if <code>kertype = "Epanechnikov"</code>, Epanechnikov kernel is used. Defaults to <code>"Gaussian"</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight</code></td>
<td>

<p>either a number, or a vector of length <code class="reqn">n</code>. If it is a number, then same weight is applied to each points of <code>X</code>. If it is a vector, <code>weight</code> represents weights of each points of <code>X</code>. The default value is <code>1</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The function <code>kde</code> returns a vector of length <code class="reqn">m</code> (the number of points in the grid) containing the value of the kernel density estimator for each point in the grid.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Larry Wasserman (2004), "All of statistics: a concise course in statistical inference", Springer.
</p>
<p>Brittany T. Fasy, Fabrizio Lecci, Alessandro Rinaldo, Larry Wasserman, Sivaraman Balakrishnan, and Aarti Singh. (2013), "Statistical Inference For Persistent Homology: Confidence Sets for Persistence Diagrams", (arXiv:1303.7117). To appear, Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code>kernelDist</code>, <code>distFct</code>, <code>dtm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Generate Data from the unit circle
n &lt;- 300
X &lt;- circleUnif(n)

## Construct a grid of points over which we evaluate the function
by &lt;- 0.065
Xseq &lt;- seq(-1.6, 1.6, by=by)
Yseq &lt;- seq(-1.7, 1.7, by=by)
Grid &lt;- expand.grid(Xseq,Yseq)

## kernel density estimator
h &lt;- 0.3
KDE &lt;- kde(X, Grid, h)
</code></pre>


</div>