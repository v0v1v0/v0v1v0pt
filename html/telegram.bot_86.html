<div class="container">

<table style="width: 100%;"><tr>
<td>Webhook</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Building a Telegram Bot with a Webhook</h2>

<h3>Description</h3>

<p>This class, which employs the class <code>Dispatcher</code>, provides a
front-end to class <code>Bot</code> to the programmer, so you can focus on
coding the bot. Its purpose is to receive updates via webhook from Telegram and
to deliver them to said dispatcher. The dispatcher supports
<code>Handler</code> classes for different kinds of data: Updates from
Telegram, basic text commands and even arbitrary types. See
<code>add</code> (<code>+</code>) to learn more about building your <code>Webhook</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Webhook(
  webhook_url,
  token = NULL,
  base_url = NULL,
  base_file_url = NULL,
  request_config = NULL,
  certificate = NULL,
  max_connections = NULL,
  allowed_updates = NULL,
  ip_address = NULL,
  drop_pending_updates = FALSE,
  verbose = FALSE,
  bot = NULL
)

is.Webhook(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>webhook_url</code></td>
<td>
<p>Webhook HTTPS url to send updates to. The url is conventionally
suffixed with the <code>/webhook</code> path.
</p>
<p><strong>Note</strong>: The url must be publicly accessible, since Telegram will need to make
HTTP <code>POST</code> requests to the end-point for each update.
</p>
<p>For example, if you are deploying to Heroku, you can use the app's hostname,
such as <code>https://[name of app].herokuapp.com/webhook</code>, or a
<a href="https://devcenter.heroku.com/articles/custom-domains">custom hostname</a>
for a domain that belongs to you, such as <code>https://app.yourcustomdomain.com/webhook</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token</code></td>
<td>
<p>(Optional). The bot's token given by the <em>BotFather</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base_url</code></td>
<td>
<p>(Optional). Telegram Bot API service URL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base_file_url</code></td>
<td>
<p>(Optional). Telegram Bot API file URL.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>request_config</code></td>
<td>
<p>(Optional). Additional configuration settings
to be passed to the bot's POST requests. See the <code>config</code>
parameter from <code>httr::POST</code> for further details.
</p>
<p>The <code>request_config</code> settings are very
useful for the advanced users who would like to control the
default timeouts and/or control the proxy used for HTTP communication.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>certificate</code></td>
<td>
<p>(Optional). Upload your public key certificate so that
the root certificate in use can be checked. See Telegram's
<a href="https://core.telegram.org/bots/self-signed">self-signed guide</a> for
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_connections</code></td>
<td>
<p>(Optional). Maximum allowed number of simultaneous
HTTPS connections to the webhook for update delivery, 1-100. Defaults to
40. Use lower values to limit the load on your bot's server, and higher
values to increase your bot's throughput.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allowed_updates</code></td>
<td>
<p>(Optional). String or vector of strings with the
types of updates you want your bot to receive. For example, specify
<code>c("message", "edited_channel_post", "callback_query")</code> to only
receive updates of these types. See
<a href="https://core.telegram.org/bots/api#update">Update</a>
for a complete list of available update types. Specify an empty string
to receive all updates regardless of type (default). If not specified,
the previous setting will be used.
</p>
<p>Please note that this parameter doesn't affect updates created before
the call to the get_updates, so unwanted updates may be received for a
short period of time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ip_address</code></td>
<td>
<p>(Optional). The fixed IP address which will be used to
send webhook requests instead of the IP address resolved through DNS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop_pending_updates</code></td>
<td>
<p>(Optional). Pass True to drop all pending updates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>(Optional). If <code>TRUE</code>, prints status of the polling.
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bot</code></td>
<td>
<p>(Optional). A pre-initialized <code>Bot</code> instance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Object to be tested.</p>
</td>
</tr>
</table>
<h3>Format</h3>

<p>An <code>R6Class</code> object.
</p>


<h3>Details</h3>

<p>You <strong>must</strong> supply the <code>webhook_url</code> and either a <code>bot</code>
or a <code>token</code> argument.
</p>
<p>The <code>webhook_url</code> must be publicly accessible, since Telegram will
need to make HTTP <code>POST</code> requests to the end-point for each update.
</p>
<p><strong>Security Note</strong>: <code>Webhook</code> encapsulates generating a <code>secret_token</code> which
is used to validate that the request comes from a webhook set by you.
</p>


<h3>Methods</h3>


<dl>
<dt><code>start_server</code></dt>
<dd>
<p>Starts listening for updates from
Telegram.</p>
</dd>
<dt><code>stop_server</code></dt>
<dd>
<p>Stops listening for updates.</p>
</dd>
<dt><code>running</code></dt>
<dd>
<p>Returns <code>TRUE</code> when listening for updates.</p>
</dd>
</dl>
<h3>References</h3>

<p><a href="https://core.telegram.org/bots">Bots: An introduction for developers</a>,
<a href="https://core.telegram.org/bots/api">Telegram Bot API</a> and
<a href="https://core.telegram.org/bots/webhooks">Marvin's Marvellous Guide to All Things Webhook</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
webhook &lt;- Webhook("https://example.com/webhook", "TOKEN")

# In case you want to set a proxy
webhook &lt;- Webhook(
  webhook_url = "https://example.com/webhook",
  token = "TOKEN",
  request_config = httr::use_proxy(...),
  verbose = TRUE
)

# Add a handler
start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = sprintf(
      "Hello %s!",
      update$message$from$first_name
    )
  )
}
webhook &lt;- webhook + CommandHandler("start", start)

# Start polling
webhook$start_server() # Send '/start' to the bot

## End(Not run)
</code></pre>


</div>