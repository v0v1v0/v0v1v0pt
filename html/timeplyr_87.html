<div class="container">

<table style="width: 100%;"><tr>
<td>time_by</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Group by a time variable at a higher time unit</h2>

<h3>Description</h3>

<p><code>time_by</code> groups a time variable by a specified time unit like
for example "days" or "weeks". <br>
It can be used exactly like <code>dplyr::group_by</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">time_by(
  data,
  time,
  time_by = NULL,
  from = NULL,
  to = NULL,
  .name = paste0("time_intv_", time_by_pretty(time_by, "_")),
  .add = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  as_interval = getOption("timeplyr.use_intervals", TRUE),
  .time_by_group = TRUE
)

time_by_span(x)

time_by_var(x)

time_by_units(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time</code></td>
<td>
<p>Time variable (<b>data-masking</b>). <br>
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_by</code></td>
<td>
<p>Time unit. <br>
Must be one of the following:
</p>

<ul>
<li>
<p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li>
<p> lubridate duration or period object, e.g. <code>days(1)</code> or <code>ddays(1)</code>.
</p>
</li>
<li>
<p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li>
<p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>(Optional) Start time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>(Optional) end time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.name</code></td>
<td>
<p>An optional glue specification passed to <code>stringr::glue()</code>
which can be used to concatenate
strings to the time column name or replace it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.add</code></td>
<td>
<p>Should the time groups be added to existing groups?
Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_type</code></td>
<td>
<p>If "auto", <code>periods</code> are used for
the time aggregation when days, weeks,
months or years are specified, and <code>durations</code>
are used otherwise. If <code>durations</code>
are used the output is always of class <code>POSIXct</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_interval</code></td>
<td>
<p>Should time variable be a <code>time_interval</code>?
Default is <code>FALSE</code>. <br>
This can be controlled globally through <code>options(timeplyr.use_intervals)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.time_by_group</code></td>
<td>
<p>Should the time aggregations be built on a
group-by-group basis (the default), or should the time variable be aggregated
using the full data? If done by group, different groups may contain
different time sequences. This only applies when <code>.add = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>time_tbl_df</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code>time_tbl_df</code> which for practical purposes can be treated the
same way as a dplyr <code>grouped_df</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)
library(timeplyr)
library(nycflights13)
library(lubridate)


# Basic usage
hourly_flights &lt;- flights %&gt;%
  time_by(time_hour) # Detects time granularity

hourly_flights
time_by_span(hourly_flights)

monthly_flights &lt;- flights %&gt;%
  time_by(time_hour, "month")
weekly_flights &lt;- flights %&gt;%
  time_by(time_hour, "week", from = floor_date(min(time_hour), "week"))

monthly_flights %&gt;%
  count()

weekly_flights %&gt;%
  summarise(n = n(), arr_delay = mean(arr_delay, na.rm = TRUE))

# To aggregate multiple variables, use time_aggregate

flights %&gt;%
  select(time_hour) %&gt;%
  mutate(across(everything(), \(x) time_aggregate(x, time_by = "weeks"))) %&gt;%
  count(time_hour)

</code></pre>


</div>