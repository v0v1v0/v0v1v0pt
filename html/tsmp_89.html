<div class="container">

<table style="width: 100%;"><tr>
<td>sdts_train</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Framework for Scalable Dictionary learning for Time Series (SDTS) training function</h2>

<h3>Description</h3>

<p>This function trains a model that uses a dictionary to predict state changes. Differently from
<code>fluss()</code>, it doesn't look for semantic changes (that may be several), but for binary states like
"on" or "off". Think for example that a human annotator is pressing a switch any time he thinks
that the recorded data is relevant, and releases the switch when he thinks the data is noise. This
algorithm will learn the switching points (even better) and try to predict using new data.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sdts_train(
  data,
  label,
  window_size,
  beta = 1,
  pat_max = Inf,
  parallel = FALSE,
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>. Time series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>a <code>vector</code> of <code>logical</code>. Annotations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window_size</code></td>
<td>
<p>an <code>int</code> or a <code>vector</code> of <code>int</code>. Sliding window sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>a <code>numeric</code>. See details. (default is <code>1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pat_max</code></td>
<td>
<p>an <code>int</code>. Max number of shape features captured. (default is <code>Inf</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>a <code>logical</code>. Use parallel computation inside (default is <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>beta</code> is used to balance F-score towards recall (<code style="white-space: pre;">⁠&gt;1⁠</code>) or precision (<code style="white-space: pre;">⁠&lt;1⁠</code>). <code>verbose</code> changes
how much information is printed by this function; <code>0</code> means nothing, <code>1</code> means text, <code>2</code> adds the
progress bar, <code>3</code> adds the finish sound.
</p>


<h3>Value</h3>

<p>Returns a list with the learned dictionary <code>score</code> (estimated score), <code>score_hist</code>
(history of scores), <code>pattern</code> (shape features), <code>thold</code> (threshold values).
</p>


<h3>References</h3>


<ul><li>
<p> Yeh C-CM, Kavantzas N, Keogh E. Matrix profile IV: Using Weakly Labeled Time Series
to Predict Outcomes. Proc VLDB Endow. 2017 Aug 1;10(12):1802-12.
</p>
</li></ul>
<p>Website: <a href="https://sites.google.com/view/weaklylabeled">https://sites.google.com/view/weaklylabeled</a>
</p>


<h3>See Also</h3>

<p>Other Scalable Dictionaries: 
<code>sdts_predict()</code>,
<code>sdts_score()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># This is a fast toy example and results are useless. For a complete result, run the code inside
#' Not run' section below.
w &lt;- c(110, 220)
subs &lt;- 11000:20000
tr_data &lt;- mp_test_data$train$data[subs]
tr_label &lt;- mp_test_data$train$label[subs]
te_data &lt;- mp_test_data$test$data[subs]
te_label &lt;- mp_test_data$test$label[subs]
model &lt;- sdts_train(tr_data, tr_label, w, verbose = 0)
predict &lt;- sdts_predict(model, te_data, round(mean(w)))
sdts_score(predict, te_label, 1)

windows &lt;- c(110, 220, 330)
model &lt;- sdts_train(mp_test_data$train$data, mp_test_data$train$label, windows)
predict &lt;- sdts_predict(model, mp_test_data$test$data, round(mean(windows)))
sdts_score(predict, mp_test_data$test$label, 1)

</code></pre>


</div>