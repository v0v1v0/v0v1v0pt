<div class="container">

<table style="width: 100%;"><tr>
<td>add_column_headers</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Attach column headers to a Tplyr output</h2>

<h3>Description</h3>

<p>When working with 'huxtable' tables, column headers can be controlled as if they are rows in the data frame.
<code>add_column_headers</code> eases the process of introducing these headers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_column_headers(.data, s, header_n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>The data.frame/tibble on which the headers shall be attached</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s</code></td>
<td>
<p>The text containing the intended header string</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>header_n</code></td>
<td>
<p>A header_n or generic data.frame to use for binding count values.
This is required if you are using the token replacement.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Headers are created by providing a single string. Columns are specified by delimitting each header with a '|' symbol.
Instead of specifying the destination of each header, <code>add_column_headers</code> assumes that you have organized the columns
of your data frame before hand. This means that after you use <code>Tplyr::build()</code>, if you'd like to reorganize the
default column order (which is simply alphabetical), simply pass the build output to a <code>dplyr::select</code> or <code>dplyr::relocate</code>
statement before passing into <code>add_column_headers</code>.
</p>
<p>Spanning headers are also supported. A spanning header is an overarching header that sits across multiple columns.
Spanning headers are introduced to <code>add_column_header</code> by providing the spanner text (i.e. the text that
you'd like to sit in the top row), and then the spanned text (the bottom row) within curly brackets ('{}). For example,
take the iris dataset. We have the names:
</p>
<p><code>"Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"</code>
</p>
<p>If we wanted to provide a header string for this dataset, with spanners to help with categorization of
the variables, we could provide the following string:
</p>
<p><code>"Sepal {Length | Width} | Petal {Length | Width} | Species"</code>
</p>


<h3>Value</h3>

<p>A data.frame with the processed header string elements attached as the top rows
</p>


<h3>Important note</h3>

<p>Make sure you are aware of the order of your variables prior to passing in to <code>add_column_headers</code>. The only requirement
is that the number of column match. The rest is up to you.
</p>


<h3>Development notes</h3>

<p>There are a few features of <code>add_column_header</code> that are intended but not yet supported:
</p>

<ul>
<li>
<p>Nested spanners are not yet supported. Only a spanning row and a bottom row can currently be created
</p>
</li>
<li>
<p>Different delimiters and indicators for a spanned group may be used in the future. The current choices were intuitive,
but based on feedback it could be determined that less common characters may be necessary.
</p>
</li>
</ul>
<h3>Token Replacement</h3>

<p>This function has support for reading values from the header_n object in a Tplyr table
and adding them in the column headers. Note: The order of the parameters
passed in the token is important. They should be first the treatment variable
then any <code>cols</code> variables in the order they were passed in the table construction.
</p>
<p>Use a double asterisk "**" at the begining to start the token and another
double asterisk to close it. You can separate column parameters in the token
with a single underscore. For example, **group1_flag2_param3** will pull the count
from the header_n binding for group1 in the <code>treat_var</code>, flag2 in the first <code>cols</code>
argument, and param3 in the second <code>cols</code> argument.
</p>
<p>You can pass fewer arguments in the token to get the sum of multiple columns.
For example, **group1** would get the sum of the group1 treat_var,
and all cols from the header_n.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Load in pipe
library(magrittr)
library(dplyr)
header_string &lt;- "Sepal {Length | Width} | Petal {Length | Width} | Species"

iris2 &lt;- iris %&gt;%
  mutate_all(as.character)

iris2 %&gt;% add_column_headers(header_string)

# Example with counts
mtcars2 &lt;- mtcars %&gt;%
  mutate_all(as.character)

t &lt;- tplyr_table(mtcars2, vs, cols = am) %&gt;%
  add_layer(
    group_count(cyl)
  )

b_t &lt;- build(t) %&gt;%
  mutate_all(as.character)

count_string &lt;- paste0(" | V N=**0** {auto N=**0_0** | man N=**0_1**} |",
                       " S N=**1** {auto N=**1_0** | man N=**1_1**} | | ")

add_column_headers(b_t, count_string, header_n(t))
</code></pre>


</div>