<div class="container">

<table style="width: 100%;"><tr>
<td>great_circle_line</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Great Circle Line</h2>

<h3>Description</h3>

<p>This function calculates the coordinates of the line on the surface of
a sphere between two points. All coordinates are in decimal degrees.
</p>
<p><code>gcl</code> is simply an alias.
</p>


<h3>Usage</h3>

<pre><code class="language-R">great_circle_line(x0, y0, x1, y1, linear = FALSE, npoints = 100)
gcl(x0, y0, x1, y1, linear = FALSE, npoints = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x0, y0, x1, y1</code></td>
<td>
<p>the coordinates of the two points similar to
<code>segments</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linear</code></td>
<td>
<p>a logical value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npoints</code></td>
<td>
<p>an integer giving the number of points where the
coordinates are calculated (should be at least two).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The interval between <code>x0</code> and <code>x1</code> is split into regular
segments, then the latitudes are computed, by default, using a
great circle formula (Chamberlain and Duquette, 2007).
</p>
<p>If <code>linear = TRUE</code>, the coordinates are treated as linear (i.e.,
Euclidean).
</p>


<h3>Value</h3>

<p>a numeric matrix with two columns and colnames 'x' and 'y'.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Paradis</p>


<h3>References</h3>

<p>Chamberlain, R. G. and Duquette, W. H. (2007) Some algorithms for
polygons on a sphere. JPL Open Repository. &lt;doi:2014/41271&gt;
</p>


<h3>See Also</h3>

<p><code>geod</code></p>


<h3>Examples</h3>

<pre><code class="language-R">X1 &lt;- 3; Y1 &lt;- 49 # Paris
X2 &lt;- 101; Y2 &lt;- 13 # Bangkok
## if (require(maps))  map() else
plot(c(-180, 180), c(-90, 90), "n")
text(X1, Y1, "Paris")
text(X2, Y2, "Bangkok")
lines(gcl(X1, Y1, X2, Y2), col = "blue", lwd = 2)
lines(gcl(X1, Y1, X2, Y2, linear = TRUE), col = "red", lwd = 2)

## assess the error implied by using linear interpolation for the
## diagonal of a 1 degree by 1 degree square near the equator:
xya &lt;- gcl(0, 0, 1, 1)
xyb &lt;- gcl(0, 0, 1, 1, TRUE)
## the error in degrees:
error &lt;- xya[, "y"] - xyb[, "y"]
plot(xya[, "x"], error * 3600, "o",
     xlab = "Longitude (degrees)", ylab = "Error (arc-seconds)")

## max (vertical) distance between these 2 curves:
geod(c(0.5, 0.5), c(0.5, 0.5 + max(error))) # ~6.5 m
## NOTE: the actual shortest (orthogonal) distance
## between these two curves is ~4.6 m
## (assuming the vertical distance helps to define a rectangular
## triangle, we have: 0.5 * sqrt(6.5^2 * 2)) ~ 4.6)

## NOTE2: dividing the coordinates by 10 results in dividing
## these deviations by 1000
</code></pre>


</div>