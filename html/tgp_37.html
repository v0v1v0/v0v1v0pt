<div class="container">

<table style="width: 100%;"><tr>
<td>predict.tgp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Predict method for Treed Gaussian process models </h2>

<h3>Description</h3>

<p>This generic prediction method was designed to obtain samples
from the posterior predictive distribution after the <code>b*</code>
functions have finished.  Samples, or kriging mean and variance
estimates, can be obtained from the MAP model encoded in the
<code>"tgp"</code>-class object, or this parameterization can be used
as a jumping-off point in obtaining further samples from the
joint posterior and posterior predictive distributions
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'tgp'
predict(object, XX = NULL, BTE = c(0, 1, 1), R = 1,
            MAP = TRUE, pred.n = TRUE, krige = TRUE, zcov = FALSE,
            Ds2x = FALSE, improv = FALSE, sens.p = NULL, trace = FALSE,
            verb = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
 <p><code>"tgp"</code>-class object that is the output of one of
the <code>b*</code> functions: <code>blm</code>, <code>btlm</code>
<code>bgp</code>, <code>bgpllm</code>, <code>btgp</code>, or 
<code>btgpllm</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>XX</code></td>
<td>
<p> Optional <code>data.frame</code>, <code>matrix</code>,
or vector of predictive input locations 
with <code>ncol(XX) == ncol(object$X)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>BTE</code></td>
<td>
<p> 3-vector of Monte-carlo parameters (B)urn in, (T)otal, and
(E)very. Predictive samples are saved every E MCMC rounds starting
at round B, stopping at T. The default <code>BTE=c(0,1,1)</code> is
specified to give the kriging means and variances as outputs, plus
one sample from the posterior predictive distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p> Number of repeats or restarts of <code>BTE</code> MCMC rounds,
default <code>R=1</code> is no restarts</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MAP</code></td>
<td>
<p> When <code>TRUE</code> (default) predictive data (i.e.,
kriging mean and variance estimates, and samples from the
posterior predictive distribution) are obtained for the
<em>fixed</em> MAP model encoded in <code>object</code>.  Otherwise,
when <code>MAP=FALSE</code> sampling from the joint posterior
of the model parameters (i.e., tree and GPs) and the posterior
predictive distribution are obtained starting from the MAP model and
proceeding just as the <code>b*</code> functions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred.n</code></td>
<td>
<p><code>TRUE</code> (default) value results in prediction at
the inputs <code>X</code>; <code>FALSE</code> 
skips prediction at <code>X</code> resulting in a faster
implementation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>krige</code></td>
<td>
<p><code>TRUE</code> (default) value results in collection of
kriging means and variances at predictive (and/or data)
locations; <code>FALSE</code> skips the gathering of kriging statistics
giving a savings in storage</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zcov</code></td>
<td>
<p>If <code>TRUE</code> then the predictive covariance matrix is
calculated– can be computationally (and memory) intensive if
<code>X</code> or <code>XX</code> is large.  Otherwise only the variances
(diagonal of covariance matrices) are calculated (default).  See
outputs <code>Zp.s2</code>, <code>ZZ.s2</code>, etc., below</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Ds2x</code></td>
<td>
<p><code>TRUE</code> results in ALC (Active Learning–Cohn)
computation of expected reduction in uncertainty calculations at the
<code>X</code> locations, which can be used for adaptive sampling;
<code>FALSE</code> (default) skips this computation, resulting in
a faster implementation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>improv</code></td>
<td>
<p><code>TRUE</code> results in samples from the
improvement at locations <code>XX</code> with respect to the observed
data minimum. These samples are used to calculate the expected
improvement over <code>XX</code>, as well as to rank all of the points in
<code>XX</code> in the order that they should be sampled to minimize the
expected multivariate improvement (refer to Schonlau et al, 1998).
Alternatively, <code>improv</code> can be set to any positive integer 'g',
in which case the ranking is performed with respect to the expectation
for improvement raised to the power 'g'. Increasing 'g' leads to
rankings that are more oriented towards a global optimization.
The option <code>FALSE</code> (default) skips these computations,
resulting in a faster implementation.  Optionally, a two-vector
can be supplied where <code>improv[2]</code> is interpreted as the 
(maximum) number of points to rank by improvement.  
See the note in <code>btgp</code> documentation.
If not specified, then the larger of 10% of <code>nn = nrow(XX)</code> 
and <code>min(10, nn)</code> is taken by default </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sens.p</code></td>
<td>
<p> Either <code>NULL</code> or a vector of parameters for
sensitivity analysis, built by the function <code>sens</code>.
Refer there for details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trace</code></td>
<td>
 <p><code>TRUE</code> results in a saving of samples from the
posterior distribution for most of the parameters in the model.  The
default is <code>FALSE</code> for speed/storage reasons. See note below </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p> Level of verbosity of R-console print statements: from 0
(default: none); 1 which shows the “progress meter”; 2
includes an echo of initialization parameters; up to 3 and 4 (max)
with more info about successful tree operations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> Ellipses are not used in the current version
of <code>predict.tgp</code>.  They are are only included in order to 
maintain S3 generic/method consistency </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>While this function was designed with prediction in mind, it is
actually far more general.  It allows a continuation of
MCMC sampling where the <code>b*</code> function left off (when
<code>MAP=FALSE</code>) with a possibly new set of predictive locations
<code>XX</code>.  The intended use of this function is to obtain quick
kriging-style predictions for a previously-fit MAP estimate
(contained in a <code>"tgp"</code>-class object)
on a new set of predictive locations <code>XX</code>.  However,
it can also be used simply to extend the search for an MAP model
when <code>MAP=FALSE</code>, <code>pred.n=FALSE</code>, and <code>XX=NULL</code>
</p>


<h3>Value</h3>

<p>The output is the same, or a subset of, the output produced
by the <code>b*</code> functions, for example see <code>btgp</code>
</p>


<h3>Note</h3>

<p>It is important to note that this function is not a replacement
for supplying <code>XX</code> to the <code>b*</code> functions, which is the only
way to get fully Bayesian samples from the posterior prediction
at new inputs.  It is only intended as a post-analysis (diagnostic)
tool.
</p>
<p>Inputs <code>XX</code> containing <code>NaN, NA</code>, or <code>Inf</code> are
discarded with non-fatal warnings.  Upon execution, MCMC reports are
made every 1,000 rounds to indicate progress.
</p>
<p>If <code>XX</code>s are provided which fall outside the range of <code>X</code>
inputs provided to the original <code>b*</code> function, then those will
not be extrapolated properly, due to the way that bounding rectangles
are defined in the original run.  For a workaround, supply
<code>out$Xsplit &lt;- rbind(X, XX)</code> before running <code>predict</code> on
<code>out</code>.
</p>
<p>See note for <code>btgp</code> or another <code>b*</code> function
regarding the handling and appropriate specification of <code>traces</code>.
</p>
<p>The <code>"tgp"</code> class output produced by <code>predict.tgp</code> can
also be used as input to <code>predict.tgp</code>, as well as others (e.g.,
<code>plot.tgp</code>.
</p>


<h3>Author(s)</h3>

 
<p>Robert B. Gramacy, <a href="mailto:rbg@vt.edu">rbg@vt.edu</a>, and
Matt Taddy, <a href="mailto:mataddy@amazon.com">mataddy@amazon.com</a>
</p>


<h3>References</h3>

<p><a href="https://bobby.gramacy.com/r_packages/tgp/">https://bobby.gramacy.com/r_packages/tgp/</a>
</p>


<h3>See Also</h3>

 <p><code>predict</code>, <code>blm</code>, <code>btlm</code>,
<code>bgp</code>, <code>btgp</code>, <code>bgpllm</code>,
<code>btgpllm</code>, <code>plot.tgp</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">
## revisit the Motorcycle data
require(MASS)

## fit a btgpllm without predictive sampling (for speed)
out &lt;- btgpllm(X=mcycle[,1], Z=mcycle[,2], bprior="b0", 
	       pred.n=FALSE)
## nothing to plot here because there is no predictive data

## save the "tgp" class output object for use later and
save(out, file="out.Rsave")

## then remove it (for illustrative purposes)
out &lt;- NULL

## (now imagine emailing the out.Rsave file to a friend who
## then performs the following in order to use your fitted
## tgp model on his/her own predictive locations)

## load in the "tgp" class object we just saved
load("out.Rsave")

## new predictive locations
XX &lt;- seq(2.4, 56.7, length=200)

## now obtain kriging estimates from the MAP model
out.kp &lt;- predict(out, XX=XX, pred.n=FALSE)
plot(out.kp, center="km", as="ks2")

## actually obtain predictive samples from the MAP
out.p &lt;- predict(out, XX=XX, pred.n=FALSE, BTE=c(0,1000,1))
plot(out.p)

## use the MAP as a jumping-off point for more sampling
out2 &lt;- predict(out, XX, pred.n=FALSE, BTE=c(0,2000,2),
                MAP=FALSE, verb=1)
plot(out2)

## (generally you would not want to remove the file)
unlink("out.Rsave")

</code></pre>


</div>