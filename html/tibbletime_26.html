<div class="container">

<table style="width: 100%;"><tr>
<td>rollify</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a rolling version of any function</h2>

<h3>Description</h3>

<p><code>rollify</code> returns a rolling version of the input function, with a
rolling <code>window</code> specified by the user.
</p>


<h3>Usage</h3>

<pre><code class="language-R">rollify(.f, window = 1, unlist = TRUE, na_value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.f</code></td>
<td>
<p>A function to modify, specified in one of the following ways:
</p>

<ul>
<li>
<p> A named function, e.g. <code>mean</code>.
</p>
</li>
<li>
<p> An anonymous function, e.g. <code style="white-space: pre;">⁠\(x) x + 1⁠</code> or <code>function(x) x + 1</code>.
</p>
</li>
<li>
<p> A formula, e.g. <code>~ .x + 1</code>. Only recommended if you require backward
compatibility with older versions of R.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window</code></td>
<td>
<p>The window size to roll over</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unlist</code></td>
<td>
<p>If the function returns a single value each time it is called,
use <code>unlist = TRUE</code>. If the function returns more than one value, or a more
complicated object (like a linear model), use <code>unlist = FALSE</code> to create
a list-column of the rolling results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_value</code></td>
<td>
<p>A default value for the <code>NA</code> values at the beginning of the
roll.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The intended use of <code>rollify</code> is to turn a function into a rolling version
of itself for use inside of a call to <code>dplyr::mutate()</code>, however it works
equally as well when called from <code>purrr::map()</code>.
</p>
<p>Because of it's intended use with <code>dplyr::mutate()</code>, <code>rollify</code>
creates a function that always returns output with the same length of the
input, aligned right, and filled with <code>NA</code> unless otherwise specified
by <code>na_value</code>.
</p>
<p>The form of the <code>.f</code> argument is the same as the form that can be passed
to <code>purrr::map()</code>. Use <code>.x</code> or <code>.</code> to refer to the first object to roll over,
and <code>.y</code> to refer to the second object if required. The examples explain this
further.
</p>
<p>If optional arguments to the function are required, specify them in the
call to <code>rollify</code>, and not in the call to the rolling version of the
function. See the examples for more details.
</p>


<h3>See Also</h3>

<p>purrr::safely, purrr::possibly
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# Rolling mean --------------------------------------------------------------

data(FB)

# Turn the normal mean function into a rolling mean with a 5 row window
mean_roll_5 &lt;- rollify(mean, window = 5)

dplyr::mutate(FB,
       normal_mean  = mean(adjusted),
       rolling_mean = mean_roll_5(adjusted))

# There's nothing stopping you from combining multiple rolling functions with
# different window sizes in the same mutate call
mean_roll_10 &lt;- rollify(mean, window = 10)

dplyr::mutate(FB,
       rolling_mean_5  = mean_roll_5(adjusted),
       rolling_mean_10 = mean_roll_10(adjusted))

# Functions with multiple args and optional args ----------------------------

# With 2 args, use the purrr syntax of ~ and .x, .y
# Rolling correlation example
cor_roll &lt;- rollify(~cor(.x, .y), window = 5)

dplyr::mutate(FB, running_cor = cor_roll(adjusted, open))

# With &gt;2 args, create an anonymous function with &gt;2 args or use
# the purrr convention of ..1, ..2, ..3 to refer to the arguments
avg_of_avgs &lt;- rollify(function(x, y, z) {
                         (mean(x) + mean(y) + mean(z)) / 3
                       },
                       window = 10)

# Or
avg_of_avgs &lt;- rollify(~(mean(..1) + mean(..2) + mean(..3)) / 3,
                       window = 10)

dplyr::mutate(FB, avg_of_avgs = avg_of_avgs(open, high, low))

# Optional arguments MUST be passed at the creation of the rolling function
# Only data arguments that are "rolled over" are allowed when calling the
# rolling version of the function
FB$adjusted[1] &lt;- NA

roll_mean_na_rm &lt;- rollify(~mean(.x, na.rm = TRUE), window = 5)

dplyr::mutate(FB, roll_mean = roll_mean_na_rm(adjusted))

# Returning multiple values -------------------------------------------------

data(FB)

summary2 &lt;- function(x) {
  unclass(summary(x))
}

# If the function returns &gt;1 value, set the `unlist = FALSE` argument
# Running 5 number summary
summary_roll &lt;- rollify(summary2, window = 5, unlist = FALSE)

FB_summarised &lt;- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised$summary_roll[[5]]

# dplyr::bind_rows() is often helpful in these cases to get
# meaningful output

summary_roll &lt;- rollify(~dplyr::bind_rows(summary2(.)), window = 5, unlist = FALSE)
FB_summarised &lt;- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised %&gt;%
  dplyr::filter(!is.na(summary_roll)) %&gt;%
  tidyr::unnest(summary_roll)

# Rolling regressions -------------------------------------------------------

# Extending an example from R 4 Data Science on "Many Models".
# For each country in the gapminder data, calculate a linear regression
# every 5 periods of lifeExp ~ year
library(gapminder)

# Rolling regressions are easy to implement
lm_roll &lt;- rollify(~lm(.x ~ .y), window = 5, unlist = FALSE)

gapminder %&gt;%
  dplyr::group_by(country) %&gt;%
  dplyr::mutate(rolling_lm = lm_roll(lifeExp, year))

# Rolling with groups -------------------------------------------------------

# One of the most powerful things about this is that it works with
# groups since `mutate` is being used
data(FANG)
FANG &lt;- FANG %&gt;%
  dplyr::group_by(symbol)

mean_roll_3 &lt;- rollify(mean, window = 3)

FANG %&gt;%
  dplyr::mutate(mean_roll = mean_roll_3(adjusted)) %&gt;%
  dplyr::slice(1:5)

</code></pre>


</div>