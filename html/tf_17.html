<div class="container">

<table style="width: 100%;"><tr>
<td>Ops.tf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Math, Summary and Ops Methods for <code>tf</code>
</h2>

<h3>Description</h3>

<p>These methods and operators mostly work <code>arg</code>-value-wise on <code>tf</code> objects, see
<code>?groupGeneric</code> for implementation details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'tf'
Ops(e1, e2)

## S3 method for class 'tfd'
e1 == e2

## S3 method for class 'tfd'
e1 != e2

## S3 method for class 'tfb'
e1 == e2

## S3 method for class 'tfb'
e1 != e2

## S3 method for class 'tfd'
Ops(e1, e2)

## S3 method for class 'tfb'
Ops(e1, e2)

## S3 method for class 'tfd'
Math(x, ...)

## S3 method for class 'tfb'
Math(x, ...)

## S3 method for class 'tf'
Summary(...)

## S3 method for class 'tfd'
cummax(...)

## S3 method for class 'tfd'
cummin(...)

## S3 method for class 'tfd'
cumsum(...)

## S3 method for class 'tfd'
cumprod(...)

## S3 method for class 'tfb'
cummax(...)

## S3 method for class 'tfb'
cummin(...)

## S3 method for class 'tfb'
cumsum(...)

## S3 method for class 'tfb'
cumprod(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>e1</code></td>
<td>
<p>an <code>tf</code> or a numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e2</code></td>
<td>
<p>an <code>tf</code> or a numeric vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>an <code>tf</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p><code>tf</code>-objects (not used for <code>Math</code> group generic)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See examples below. Equality checks of functional objects are even more iffy
than usual for computer math and not very reliable. Note that <code>max</code> and <code>min</code>
are not guaranteed to be maximal/minimal over the entire domain, only on the
evaluation grid used for computation. With the exception of addition and
multiplication, operations on <code>tfb</code>-objects first evaluate the data on their
<code>arg</code>, perform computations on these evaluations and then convert back to an
<code>tfb</code>- object, so a loss of precision should be expected â€“ especially so for
small spline bases and/or very wiggly data.
</p>


<h3>Value</h3>

<p>a <code>tf</code>- or <code>logical</code> vector with the computed result
</p>


<h3>See Also</h3>

<p><code>tf_fwise()</code> for scalar summaries of each function in a <code>tf</code>-vector
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(1859)
f &lt;- tf_rgp(4)
2 * f == f + f
sum(f) == f[1] + f[2] + f[3] + f[4]
log(exp(f)) == f
plot(f, points = FALSE)
lines(range(f), col = 2, lty = 2)

f2 &lt;- tf_rgp(5) |&gt; exp() |&gt; tfb(k = 25)
layout(t(1:3))
plot(f2, col = gray.colors(5))
plot(cummin(f2), col = gray.colors(5))
plot(cumsum(f2), col = gray.colors(5))

# ?tf_integrate for integrals, ?tf_fwise for scalar summaries of each function
</code></pre>


</div>