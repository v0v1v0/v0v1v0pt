<div class="container">

<table style="width: 100%;"><tr>
<td>tfd_pixel_cnn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The Pixel CNN++ distribution</h2>

<h3>Description</h3>

<p>Pixel CNN++ (Salimans et al., 2017) models a distribution over image
data, parameterized by a neural network. It builds on Pixel CNN and
Conditional Pixel CNN, as originally proposed by
(van den Oord et al., 2016).
The model expresses the joint distribution over pixels as
the product of conditional distributions:
<code style="white-space: pre;">⁠p(x|h) = prod{ p(x[i] | x[0:i], h) : i=0, ..., d }⁠</code>, in which
<code style="white-space: pre;">⁠p(x[i] | x[0:i], h) : i=0, ..., d⁠</code> is the
probability of the <code>i</code>-th pixel conditional on the pixels that preceded it in
raster order (color channels in RGB order, then left to right, then top to
bottom). <code>h</code> is optional additional data on which to condition the image
distribution, such as class labels or VAE embeddings. The Pixel CNN++
network enforces the dependency structure among pixels by applying a mask to
the kernels of the convolutional layers that ensures that the values for each
pixel depend only on other pixels up and to the left.
Pixel values are modeled with a mixture of quantized logistic distributions,
which can take on a set of distinct integer values (e.g. between 0 and 255
for an 8-bit image).
Color intensity <code>v</code> of each pixel is modeled as:
<code style="white-space: pre;">⁠v ~ sum{q[i] * quantized_logistic(loc[i], scale[i]) : i = 0, ..., k }⁠</code>,
in which <code>k</code> is the number of mixture components and the <code>q[i]</code> are the
Categorical probabilities over the components.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tfd_pixel_cnn(
  image_shape,
  conditional_shape = NULL,
  num_resnet = 5,
  num_hierarchies = 3,
  num_filters = 160,
  num_logistic_mix = 10,
  receptive_field_dims = c(3, 3),
  dropout_p = 0.5,
  resnet_activation = "concat_elu",
  use_weight_norm = TRUE,
  use_data_init = TRUE,
  high = 255,
  low = 0,
  dtype = tf$float32,
  name = "PixelCNN"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>image_shape</code></td>
<td>
<p>3D <code>TensorShape</code> or tuple for the <code style="white-space: pre;">⁠[height, width, channels]⁠</code>
dimensions of the image.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional_shape</code></td>
<td>
<p><code>TensorShape</code> or tuple for the shape of the
conditional input, or <code>NULL</code> if there is no conditional input.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_resnet</code></td>
<td>
<p><code>integer</code>, the number of layers (shown in Figure 2 of https://arxiv.org/abs/1606.05328)
within each highest-level block of Figure 2 of https://pdfs.semanticscholar.org/9e90/6792f67cbdda7b7777b69284a81044857656.pdf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_hierarchies</code></td>
<td>
<p><code>integer</code>, the number of hightest-level blocks (separated by
expansions/contractions of dimensions in Figure 2 of https://pdfs.semanticscholar.org/9e90/6792f67cbdda7b7777b69284a81044857656.pdf.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_filters</code></td>
<td>
<p><code>integer</code>, the number of convolutional filters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_logistic_mix</code></td>
<td>
<p><code>integer</code>, number of components in the logistic mixture
distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>receptive_field_dims</code></td>
<td>
<p><code>tuple</code>, height and width in pixels of the receptive
field of the convolutional layers above and to the left of a given
pixel. The width (second element of the tuple) should be odd. Figure 1
(middle) of https://arxiv.org/abs/1606.05328 shows a receptive field of (3, 5)
(the row containing the current pixel is included in the height).
The default of (3, 3) was used to produce the results in https://pdfs.semanticscholar.org/9e90/6792f67cbdda7b7777b69284a81044857656.pdf.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dropout_p</code></td>
<td>
<p><code>float</code>, the dropout probability. Should be between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resnet_activation</code></td>
<td>
<p><code>string</code>, the type of activation to use in the resnet blocks.
May be 'concat_elu', 'elu', or 'relu'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_weight_norm</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> then use weight normalization (works
only in Eager mode).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_data_init</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> then use data-dependent initialization
(has no effect if <code>use_weight_norm</code> is <code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>high</code></td>
<td>
<p><code>integer</code>, the maximum value of the input data (255 for an 8-bit image).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low</code></td>
<td>
<p><code>integer</code>, the minimum value of the input data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtype</code></td>
<td>
<p>Data type of the <code>Distribution</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p><code>string</code>, the name of the <code>Distribution</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a distribution instance.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://www.semanticscholar.org/paper/OTHER-MODIFICATIONS-Karpathy/2e77b99e8bd10b9e4551a780c0bde9dd10fdbe9b?p2df">Tim Salimans, Andrej Karpathy, Xi Chen, and Diederik P. Kingma. PixelCNN++: Improving the PixelCNN with Discretized Logistic Mixture Likelihood and Other Modifications. In <em>International Conference on Learning Representations</em>, 2017.</a>
</p>
</li>
<li> <p><a href="https://arxiv.org/abs/1606.05328">Aaron van den Oord, Nal Kalchbrenner, Oriol Vinyals, Lasse Espeholt, Alex Graves, and Koray Kavukcuoglu. Conditional Image Generation with PixelCNN Decoders. In <em>Neural Information Processing Systems</em>, 2016.</a>
</p>
</li>
<li> <p><a href="https://arxiv.org/pdf/1601.06759.pdf">Aaron van den Oord, Nal Kalchbrenner, and Koray Kavukcuoglu. Pixel Recurrent Neural Networks. In <em>International Conference on Machine Learning</em>, 2016.</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p>For usage examples see e.g. <code>tfd_sample()</code>, <code>tfd_log_prob()</code>, <code>tfd_mean()</code>.
</p>
<p>Other distributions: 
<code>tfd_autoregressive()</code>,
<code>tfd_batch_reshape()</code>,
<code>tfd_bates()</code>,
<code>tfd_bernoulli()</code>,
<code>tfd_beta_binomial()</code>,
<code>tfd_beta()</code>,
<code>tfd_binomial()</code>,
<code>tfd_categorical()</code>,
<code>tfd_cauchy()</code>,
<code>tfd_chi2()</code>,
<code>tfd_chi()</code>,
<code>tfd_cholesky_lkj()</code>,
<code>tfd_continuous_bernoulli()</code>,
<code>tfd_deterministic()</code>,
<code>tfd_dirichlet_multinomial()</code>,
<code>tfd_dirichlet()</code>,
<code>tfd_empirical()</code>,
<code>tfd_exp_gamma()</code>,
<code>tfd_exp_inverse_gamma()</code>,
<code>tfd_exponential()</code>,
<code>tfd_gamma_gamma()</code>,
<code>tfd_gamma()</code>,
<code>tfd_gaussian_process_regression_model()</code>,
<code>tfd_gaussian_process()</code>,
<code>tfd_generalized_normal()</code>,
<code>tfd_geometric()</code>,
<code>tfd_gumbel()</code>,
<code>tfd_half_cauchy()</code>,
<code>tfd_half_normal()</code>,
<code>tfd_hidden_markov_model()</code>,
<code>tfd_horseshoe()</code>,
<code>tfd_independent()</code>,
<code>tfd_inverse_gamma()</code>,
<code>tfd_inverse_gaussian()</code>,
<code>tfd_johnson_s_u()</code>,
<code>tfd_joint_distribution_named_auto_batched()</code>,
<code>tfd_joint_distribution_named()</code>,
<code>tfd_joint_distribution_sequential_auto_batched()</code>,
<code>tfd_joint_distribution_sequential()</code>,
<code>tfd_kumaraswamy()</code>,
<code>tfd_laplace()</code>,
<code>tfd_linear_gaussian_state_space_model()</code>,
<code>tfd_lkj()</code>,
<code>tfd_log_logistic()</code>,
<code>tfd_log_normal()</code>,
<code>tfd_logistic()</code>,
<code>tfd_mixture_same_family()</code>,
<code>tfd_mixture()</code>,
<code>tfd_multinomial()</code>,
<code>tfd_multivariate_normal_diag_plus_low_rank()</code>,
<code>tfd_multivariate_normal_diag()</code>,
<code>tfd_multivariate_normal_full_covariance()</code>,
<code>tfd_multivariate_normal_linear_operator()</code>,
<code>tfd_multivariate_normal_tri_l()</code>,
<code>tfd_multivariate_student_t_linear_operator()</code>,
<code>tfd_negative_binomial()</code>,
<code>tfd_normal()</code>,
<code>tfd_one_hot_categorical()</code>,
<code>tfd_pareto()</code>,
<code>tfd_poisson_log_normal_quadrature_compound()</code>,
<code>tfd_poisson()</code>,
<code>tfd_power_spherical()</code>,
<code>tfd_probit_bernoulli()</code>,
<code>tfd_quantized()</code>,
<code>tfd_relaxed_bernoulli()</code>,
<code>tfd_relaxed_one_hot_categorical()</code>,
<code>tfd_sample_distribution()</code>,
<code>tfd_sinh_arcsinh()</code>,
<code>tfd_skellam()</code>,
<code>tfd_spherical_uniform()</code>,
<code>tfd_student_t_process()</code>,
<code>tfd_student_t()</code>,
<code>tfd_transformed_distribution()</code>,
<code>tfd_triangular()</code>,
<code>tfd_truncated_cauchy()</code>,
<code>tfd_truncated_normal()</code>,
<code>tfd_uniform()</code>,
<code>tfd_variational_gaussian_process()</code>,
<code>tfd_vector_diffeomixture()</code>,
<code>tfd_vector_exponential_diag()</code>,
<code>tfd_vector_exponential_linear_operator()</code>,
<code>tfd_vector_laplace_diag()</code>,
<code>tfd_vector_laplace_linear_operator()</code>,
<code>tfd_vector_sinh_arcsinh_diag()</code>,
<code>tfd_von_mises_fisher()</code>,
<code>tfd_von_mises()</code>,
<code>tfd_weibull()</code>,
<code>tfd_wishart_linear_operator()</code>,
<code>tfd_wishart_tri_l()</code>,
<code>tfd_wishart()</code>,
<code>tfd_zipf()</code>
</p>


</div>