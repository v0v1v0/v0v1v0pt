<div class="container">

<table style="width: 100%;"><tr>
<td>tbc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Temporal betweenness centrality</h2>

<h3>Description</h3>

<p><code>tbc</code> returns the temporal betweenness centrality for each node in a
dynamic network (sequence of graph snapshots).
</p>


<h3>Usage</h3>

<pre><code class="language-R">tbc(x, type = NULL, startsnapshot = 1, endsnapshot = length(x),
  vertexindices = NULL, directed = FALSE, normalize = TRUE,
  centrality_evolution = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A list of adjacency matrices or a list of adjacency lists.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Data format of <code>x</code>. Possible formats are <code>"M"</code> for a
list of adjacency matrices (containing only 1s and 0s) and <code>"L"</code> for a
list of adjacency lists (adjacency lists of the igraph package are
supported). Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>startsnapshot</code></td>
<td>
<p>Numeric. Entry of <code>x</code> to start the calculation of
<code>tbc</code>. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>endsnapshot</code></td>
<td>
<p>Numeric. Entry of <code>x</code> to end the calculation of
<code>tbc</code>. Default is the last element of <code>x</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vertexindices</code></td>
<td>
<p>Numeric. A vector of nodes. Only shortest temporal paths
ending at nodes in <code>vertexindices</code> are considered for calculating
<code>tbc</code>. Can be used to parallel the calculation of <code>tbc</code> (see
section Examples). Default is <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>Logical. Set <code>TRUE</code> if the dynamic network is a directed
network. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalize</code></td>
<td>
<p>Logical. Set <code>TRUE</code> if centrality values should be
normalized with <code class="reqn">1/((|V|-1)*(|V|-2)*m)</code> where <code class="reqn">|V|</code> is the number
of nodes and <code class="reqn">m =</code> <code>endsnapshot</code> <code class="reqn">-</code> <code>startsnapshot</code>.
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>centrality_evolution</code></td>
<td>
<p>Logical. Set <code>TRUE</code> if an additional matrix
should be returned containing the centrality values at each snapshot. Rows
correspondent to nodes, columns correspondent to snapshots. Default
is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>tbc</code> calculates the temporal betweenness centrality (Kim and
Anderson, 2012). To keep the computational effort linear in the number of
snapshots the Reversed Evolution Network algorithm (REN; Hanke and Foraita,
2017) is used to find all shortest temporal paths.
</p>


<h3>Value</h3>

<p>The (normalized) temporal betweenness centrality (<code>TBC</code>) values
of all nodes. If <code>centrality_evolution</code> is <code>TRUE</code>, an additional
matrix will be returned (<code>CentEvo</code>), containing the temporal <code class="reqn">(|V|
  x T)</code> matrix is returned (<code>CentEvo</code>), containing the temporal
centrality value at each snapshot between <code>startsnapshot</code> and
<code>endsnapshot</code>.
</p>


<h3>Warning</h3>

<p>Using adjacency matrices as input exponentially increases
the required memory. Use adjacency lists to save memory.
</p>


<h3>References</h3>

<p>Kim, Hyoungshick and Anderson, Ross (2012). <em>Temporal node
centrality in complex networks</em>. Physical Review E, 85 (2).
</p>
<p>Hanke, Moritz and Foraita, Ronja (2017). <em>Clone temporal centrality
measures for incomplete sequences of graph snapshots</em>. BMC Bioinformatics,
18 (1).
</p>


<h3>See Also</h3>

<p><code>tcc,tdc</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Create a list of adjacency matrices, plot the corresponding graphs
# (using the igraph package) and calculate tbc

A1 &lt;- matrix(c(0,1,0,0,0,0,
               1,0,1,0,0,0,
               0,1,0,0,0,0,
               0,0,0,0,0,0,
               0,0,0,0,0,0,
               0,0,0,0,0,0), ncol=6)

A2 &lt;- matrix(c(0,0,0,0,0,0,
               0,0,1,0,0,0,
               0,1,0,1,1,0,
               0,0,1,0,0,0,
               0,0,1,0,0,0,
               0,0,0,0,0,0), ncol=6)

A3 &lt;- matrix(c(0,0,0,0,0,0,
               0,0,0,0,0,0,
               0,0,0,0,0,0,
               0,0,0,0,0,0,
               0,0,0,0,0,0,
               0,0,0,0,0,0), ncol=6)

A4 &lt;- matrix(c(0,1,0,0,0,0,
               1,0,0,1,0,0,
               0,0,0,0,0,0,
               0,1,0,0,0,0,
               0,0,0,0,0,0,
               0,0,0,0,0,0), ncol=6)

library(igraph)
par(mfrow=c(2,2))

Layout &lt;-
 layout_in_circle(graph_from_adjacency_matrix(A1, mode = "undirected"))

plot(graph_from_adjacency_matrix(A1, "undirected"), layout=Layout)
plot(graph_from_adjacency_matrix(A2, "undirected"), layout=Layout)
plot(graph_from_adjacency_matrix(A3, "undirected"), layout=Layout)
plot(graph_from_adjacency_matrix(A4, "undirected"), layout=Layout)

As &lt;- list(A1,A2,A3,A4)

tbc(As, "M", centrality_evolution=TRUE)

### Create list of adjacency lists
Ls &lt;- lapply(seq_along(As), function(i){
  sapply(1:6, function(j){which(As[[i]][j,]==1)})
})

tbc(Ls, "L", centrality_evolution=TRUE)

### Run tbc in parallel ###
library(parallel)
# Calculate the number of cores
cores_avail &lt;- detectCores()-1
# Initiate cluster
cl &lt;- makeCluster(2)
clusterExport(cl, c("As", "tbc"))

TBC &lt;- parLapply(cl, 1:6, function(x){
  tbc(As, "M", vertexindices = x)
 }
)

stopCluster(cl)

Reduce("+", TBC)
</code></pre>


</div>