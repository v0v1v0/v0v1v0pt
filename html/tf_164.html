<div class="container">

<table style="width: 100%;"><tr>
<td>vec_cast.tfd_reg</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
<code>vctrs</code> methods for <code>tf</code> objects</h2>

<h3>Description</h3>

<p>These functions are the extensions that allow <code>tf</code> vectors
to work with <code>vctrs</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'tfd_reg'
vec_cast(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfd_reg(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfd_irreg(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfb_spline'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfb_fpc'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfb_spline(x, to, ...)

## S3 method for class 'tfd_reg'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfd_irreg'
vec_cast.tfb_fpc(x, to, ...)

## S3 method for class 'tfd_reg'
vec_ptype2(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfd_reg(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfd_irreg(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfb_spline(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2(x, y, ...)

## S3 method for class 'tfb_spline'
vec_ptype2.tfb_fpc(x, y, ...)

## S3 method for class 'tfb_fpc'
vec_ptype2.tfb_fpc(x, y, ...)

## S3 method for class 'tfd_reg'
vec_ptype2.tfb_fpc(x, y, ...)

## S3 method for class 'tfd_irreg'
vec_ptype2.tfb_fpc(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Vectors to cast.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>Type to cast to. If <code>NULL</code>, <code>x</code> will be returned as is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>vec_cast_common()</code>, vectors to cast. For
<code>vec_cast()</code>, <code>vec_cast_default()</code>, and <code>vec_restore()</code>, these
dots are only for future extensions and should be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Vectors to cast.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Notes on <code>vec_cast</code>:</strong>
Use <code>tf_rebase()</code> to change the representations of <code>tf</code>-vectors,
these methods are only for internal use â€“
automatic/implicit casting of <code>tf</code> objects is tricky
because it's hard to determine automatically whether such an operation would
lose precision (different bases with different expressivity? different
argument grids?), and it's not generally clear which instances of which
<code>tf</code>-subclasses should be considered the "richer" objects.
Rules for casting:
</p>

<ul>
<li>
<p> If the casted object's <code>domain</code> would not contain the entire original <code>domain</code>,
no casting is possible (would lose data).
</p>
</li>
<li>
<p> Every cast that evaluates (basis) functions on different <code>arg</code> values is a <em>lossy</em> cast,
since it might lose precision (<code>vctrs::maybe_lossy_cast</code>).
</p>
</li>
<li>
<p> As long as the casted object's <code>domain</code> contains the entire original <code>domain</code>:
</p>

<ul>
<li>
<p> every <code>tfd_reg</code>, <code>tfd_irreg</code> or <code>tfb</code> can always be cast into an equivalent
<code>tfd_irreg</code> (which may also change its <code>evaluator</code> and <code>domain</code>).
</p>
</li>
<li>
<p> every <code>tfd_reg</code> can always be cast to <code>tfd_reg</code> (which may change its <code>evaluator</code> and <code>domain</code>)
</p>
</li>
<li>
<p> every <code>tfb</code> can be cast <em>losslessly</em> to <code>tfd</code> (regular or irregular,
note it's lossless only on the <em>original</em> <code>arg</code>-grid)
</p>
</li>
</ul>
</li>
<li>
<p> Any cast of a <code>tfd</code> into <code>tfb</code> is potentially <em>lossy</em> (because we don't know how expressive the chosen basis is)
</p>
</li>
<li>
<p> Only <code>tfb</code> with identical bases and domains can be cast into one another <em>losslessly</em>
</p>
</li>
</ul>
<h3>Value</h3>

<p>for <code>vec_cast</code>: the casted <code>tf</code>-vector, for <code>vec_ptype2</code>: the common prototype
</p>


<h3>See Also</h3>

<p><code>vctrs::vec_cast()</code>, <code>vctrs::vec_ptype2()</code>
</p>


</div>