<div class="container">

<table style="width: 100%;"><tr>
<td>hilbert_env</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the envelope of X using Hilbert transform.
Compute the envelope of the signal matrix X using the Hilbert transform. 
To avoid long transforms, this function uses the overlap and add method.</h2>

<h3>Description</h3>

<p>Compute the envelope of X using Hilbert transform.
</p>
<p>Compute the envelope of the signal matrix X using the Hilbert transform. 
To avoid long transforms, this function uses the overlap and add method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">hilbert_env(X, N = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a vector or matrix of signals. If X is a matrix, each column is treated as a separate signal.
The signals must be regularly sampled for the result to be correctly interpretable as the envelope.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>N</code></td>
<td>
<p>(optional) specifies the transform length used. 
The default value is 1024 and this may be fine for most situations.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>E, the envelope of X. E is the same size as X: it has the same number of columns 
and the same number of samples per signal. It has the same units as
X but being an envelope, all values are &gt;=0.
</p>


<h3>Examples</h3>

<pre><code class="language-R">s &lt;- matrix(sin(0.1 * c(1:10000)), ncol = 1) *
 matrix(sin(0.001 * c(1:10000)), ncol = 1)
E &lt;- hilbert_env(s)
plot(c(1:length(s)), s, col = 'grey34')
lines(c(1:length(E)), E, col = 'black')

</code></pre>


</div>