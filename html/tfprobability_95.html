<div class="container">

<table style="width: 100%;"><tr>
<td>tfb_affine</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Affine bijector</h2>

<h3>Description</h3>

<p>This Bijector is initialized with shift Tensor and scale arguments,
giving the forward operation: <code>Y = g(X) = scale @ X + shift</code>
where the scale term is logically equivalent to:
<code style="white-space: pre;">⁠scale = scale_identity_multiplier * tf.diag(tf.ones(d)) + tf.diag(scale_diag) + scale_tril + scale_perturb_factor @ diag(scale_perturb_diag) @ tf.transpose([scale_perturb_factor]))⁠</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">tfb_affine(
  shift = NULL,
  scale_identity_multiplier = NULL,
  scale_diag = NULL,
  scale_tril = NULL,
  scale_perturb_factor = NULL,
  scale_perturb_diag = NULL,
  adjoint = FALSE,
  validate_args = FALSE,
  name = "affine",
  dtype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>Floating-point Tensor. If this is set to NULL, no shift is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_identity_multiplier</code></td>
<td>
<p>floating point rank 0 Tensor representing a scaling done
to the identity matrix. When <code>scale_identity_multiplier = scale_diag = scale_tril = NULL</code> then
<code style="white-space: pre;">⁠scale += IdentityMatrix⁠</code>. Otherwise no scaled-identity-matrix is added to <code>scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_diag</code></td>
<td>
<p>Floating-point Tensor representing the diagonal matrix.
<code>scale_diag</code> has shape <code style="white-space: pre;">⁠[N1, N2, ...  k]⁠</code>, which represents a k x k diagonal matrix.
When NULL no diagonal term is added to <code>scale</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_tril</code></td>
<td>
<p>Floating-point Tensor representing the lower triangular matrix.
<code>scale_tril</code> has shape <code style="white-space: pre;">⁠[N1, N2, ...  k, k]⁠</code>, which represents a k x k lower triangular matrix.
When NULL no <code>scale_tril</code> term is added to <code>scale</code>. The upper triangular elements above the diagonal are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_perturb_factor</code></td>
<td>
<p>Floating-point Tensor representing factor matrix with last
two dimensions of shape <code style="white-space: pre;">⁠(k, r)⁠</code> When NULL, no rank-r update is added to scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_perturb_diag</code></td>
<td>
<p>Floating-point Tensor representing the diagonal matrix.
<code>scale_perturb_diag</code> has shape <code style="white-space: pre;">⁠[N1, N2, ...  r]⁠</code>, which represents an r x r diagonal matrix.
When NULL low rank updates will take the form <code>scale_perturb_factor * scale_perturb_factor.T</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjoint</code></td>
<td>
<p>Logical indicating whether to use the scale matrix as specified or its adjoint.
Default value: FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validate_args</code></td>
<td>
<p>Logical, default FALSE. Whether to validate input with asserts. If validate_args is
FALSE, and the inputs are invalid, correct behavior is not guaranteed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>name prefixed to Ops created by this class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtype</code></td>
<td>
<p><code>tf$DType</code> to prefer when converting args to Tensors. Else, we fall back to a
common dtype inferred from the args, finally falling back to float32.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If NULL of <code>scale_identity_multiplier</code>, <code>scale_diag</code>, or <code>scale_tril</code> are specified then
<code style="white-space: pre;">⁠scale += IdentityMatrix⁠</code> Otherwise specifying a scale argument has the semantics of
<code style="white-space: pre;">⁠scale += Expand(arg)⁠</code>, i.e., <code>scale_diag != NULL</code> means <code style="white-space: pre;">⁠scale += tf$diag(scale_diag)⁠</code>.
</p>


<h3>Value</h3>

<p>a bijector instance.
</p>


<h3>See Also</h3>

<p>For usage examples see <code>tfb_forward()</code>, <code>tfb_inverse()</code>, <code>tfb_inverse_log_det_jacobian()</code>.
</p>
<p>Other bijectors: 
<code>tfb_absolute_value()</code>,
<code>tfb_affine_linear_operator()</code>,
<code>tfb_affine_scalar()</code>,
<code>tfb_ascending()</code>,
<code>tfb_batch_normalization()</code>,
<code>tfb_blockwise()</code>,
<code>tfb_chain()</code>,
<code>tfb_cholesky_outer_product()</code>,
<code>tfb_cholesky_to_inv_cholesky()</code>,
<code>tfb_correlation_cholesky()</code>,
<code>tfb_cumsum()</code>,
<code>tfb_discrete_cosine_transform()</code>,
<code>tfb_expm1()</code>,
<code>tfb_exp()</code>,
<code>tfb_ffjord()</code>,
<code>tfb_fill_scale_tri_l()</code>,
<code>tfb_fill_triangular()</code>,
<code>tfb_glow()</code>,
<code>tfb_gompertz_cdf()</code>,
<code>tfb_gumbel_cdf()</code>,
<code>tfb_gumbel()</code>,
<code>tfb_identity()</code>,
<code>tfb_inline()</code>,
<code>tfb_invert()</code>,
<code>tfb_iterated_sigmoid_centered()</code>,
<code>tfb_kumaraswamy_cdf()</code>,
<code>tfb_kumaraswamy()</code>,
<code>tfb_lambert_w_tail()</code>,
<code>tfb_masked_autoregressive_default_template()</code>,
<code>tfb_masked_autoregressive_flow()</code>,
<code>tfb_masked_dense()</code>,
<code>tfb_matrix_inverse_tri_l()</code>,
<code>tfb_matvec_lu()</code>,
<code>tfb_normal_cdf()</code>,
<code>tfb_ordered()</code>,
<code>tfb_pad()</code>,
<code>tfb_permute()</code>,
<code>tfb_power_transform()</code>,
<code>tfb_rational_quadratic_spline()</code>,
<code>tfb_rayleigh_cdf()</code>,
<code>tfb_real_nvp_default_template()</code>,
<code>tfb_real_nvp()</code>,
<code>tfb_reciprocal()</code>,
<code>tfb_reshape()</code>,
<code>tfb_scale_matvec_diag()</code>,
<code>tfb_scale_matvec_linear_operator()</code>,
<code>tfb_scale_matvec_lu()</code>,
<code>tfb_scale_matvec_tri_l()</code>,
<code>tfb_scale_tri_l()</code>,
<code>tfb_scale()</code>,
<code>tfb_shifted_gompertz_cdf()</code>,
<code>tfb_shift()</code>,
<code>tfb_sigmoid()</code>,
<code>tfb_sinh_arcsinh()</code>,
<code>tfb_sinh()</code>,
<code>tfb_softmax_centered()</code>,
<code>tfb_softplus()</code>,
<code>tfb_softsign()</code>,
<code>tfb_split()</code>,
<code>tfb_square()</code>,
<code>tfb_tanh()</code>,
<code>tfb_transform_diagonal()</code>,
<code>tfb_transpose()</code>,
<code>tfb_weibull_cdf()</code>,
<code>tfb_weibull()</code>
</p>


</div>