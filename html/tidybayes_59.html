<div class="container">

<table style="width: 100%;"><tr>
<td>gather_rvars</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract draws from a Bayesian model into tidy data frames of random variables</h2>

<h3>Description</h3>

<p>Extract draws from a Bayesian model for one or more variables (possibly with named
dimensions) into one of two types of long-format data frames of posterior::rvar objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gather_rvars(model, ..., ndraws = NULL, seed = NULL)

spread_rvars(model, ..., ndraws = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A supported Bayesian model fit. Tidybayes supports a variety of model objects;
for a full list of supported models, see tidybayes-models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Expressions in the form of
<code>variable_name[dimension_1, dimension_2, ...]</code>. See <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Imagine a JAGS or Stan fit named <code>model</code>. The model may contain a variable named
<code>b[i,v]</code> (in the JAGS or Stan language) with dimension <code>i</code> in <code>1:100</code> and
dimension <code>v</code> in <code>1:3</code>. However, the default format for draws returned from
JAGS or Stan in R will not reflect this indexing structure, instead
they will have multiple columns with names like <code>"b[1,1]"</code>, <code>"b[2,1]"</code>, etc.
</p>
<p><code>spread_rvars</code> and <code>gather_rvars</code> provide a straightforward
syntax to translate these columns back into properly-indexed <code>rvar</code>s in two different
tidy data frame formats, optionally recovering dimension types (e.g. factor levels) as it does so.
</p>
<p><code>spread_rvars</code> will spread names of variables in the model across the data frame as column names,
whereas <code>gather_rvars</code> will gather variable names into a single column named <code>".variable"</code> and place
values of variables into a column named <code>".value"</code>. To use naming schemes from other packages
(such as <code>broom</code>), consider passing
results through functions like <code>to_broom_names()</code> or <code>to_ggmcmc_names()</code>.
</p>
<p>For example, <code>spread_rvars(model, a[i], b[i,v])</code> might return a data frame with:
</p>

<ul>
<li>
<p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li>
<p> column <code>"v"</code>: value in <code>1:10</code>
</p>
</li>
<li>
<p> column <code>"a"</code>: <code>rvar</code> containing draws from <code>"a[i]"</code>
</p>
</li>
<li>
<p> column <code>"b"</code>: <code>rvar</code> containing draws from <code>"b[i,v]"</code>
</p>
</li>
</ul>
<p><code>gather_rvars(model, a[i], b[i,v])</code> on the same model would return a data frame with:
</p>

<ul>
<li>
<p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li>
<p> column <code>"v"</code>: value in <code>1:10</code>, or <code>NA</code>
on rows where <code>".variable"</code> is <code>"a"</code>.
</p>
</li>
<li>
<p> column <code>".variable"</code>: value in <code>c("a", "b")</code>.
</p>
</li>
<li>
<p> column <code>".value"</code>: <code>rvar</code> containing draws from <code>"a[i]"</code> (when <code>".variable"</code> is <code>"a"</code>)
or <code>"b[i,v]"</code> (when <code>".variable"</code> is <code>"b"</code>)
</p>
</li>
</ul>
<p><code>spread_rvars</code> and <code>gather_rvars</code> can use type information
applied to the <code>model</code> object by <code>recover_types()</code> to convert columns
back into their original types. This is particularly helpful if some of the dimensions in
your model were originally factors. For example, if the <code>v</code> dimension
in the original data frame <code>data</code> was a factor with levels <code>c("a","b","c")</code>,
then we could use <code>recover_types</code> before <code>spread_rvars</code>:
</p>
<pre>model %&gt;%
 recover_types(data) 
 spread_rvars(model, b[i,v])
</pre>
<p>Which would return the same data frame as above, except the <code>"v"</code> column
would be a value in <code>c("a","b","c")</code> instead of <code>1:3</code>.
</p>
<p>For variables that do not share the same subscripts (or share
some but not all subscripts), we can supply their specifications separately.
For example, if we have a variable <code>d[i]</code> with the same <code>i</code> subscript
as <code>b[i,v]</code>, and a variable <code>x</code> with no subscripts, we could do this:
</p>
<pre>spread_rvars(model, x, d[i], b[i,v])</pre>
<p>Which is roughly equivalent to this:
</p>
<pre>spread_rvars(model, x) %&gt;%
 inner_join(spread_rvars(model, d[i])) %&gt;%
 inner_join(spread_rvars(model, b[i,v]))
</pre>
<p>Similarly, this:
</p>
<pre>gather_rvars(model, x, d[i], b[i,v])</pre>
<p>Is roughly equivalent to this:
</p>
<pre>bind_rows(
 gather_rvars(model, x),
 gather_rvars(model, d[i]),
 gather_rvars(model, b[i,v])
)</pre>
<p>The <code>c</code> and <code>cbind</code> functions can be used to combine multiple variable names that have
the same dimensions. For example, if we have several variables with the same
subscripts <code>i</code> and <code>v</code>, we could do either of these:
</p>
<pre>spread_rvars(model, c(w, x, y, z)[i,v])</pre>
<pre>spread_rvars(model, cbind(w, x, y, z)[i,v])  # equivalent</pre>
<p>Each of which is roughly equivalent to this:
</p>
<pre>spread_rvars(model, w[i,v], x[i,v], y[i,v], z[i,v])</pre>
<p>Besides being more compact, the <code>c()</code>-style syntax is currently also slightly
faster (though that may change).
</p>
<p>Dimensions can be left nested in the resulting <code>rvar</code> objects by leaving their names
blank; e.g. <code>spread_rvars(model, b[i,])</code> will place the first index (<code>i</code>) into
rows of the data frame but leave the second index nested in the <code>b</code> column
(see <em>Examples</em> below).
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code>spread_draws()</code>, <code>recover_types()</code>, <code>compose_data()</code>. See also
<code>posterior::rvar()</code> and <code>posterior::as_draws_rvars()</code>, the functions that power
<code>spread_rvars</code> and <code>gather_rvars</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(dplyr)

data(RankCorr, package = "ggdist")

RankCorr %&gt;%
  spread_rvars(b[i, j])

# leaving an index out nests the index in the column containing the rvar
RankCorr %&gt;%
  spread_rvars(b[i, ])

RankCorr %&gt;%
  spread_rvars(b[i, j], tau[i], u_tau[i])

# gather_rvars places variables and values in a longer format data frame
RankCorr %&gt;%
  gather_rvars(b[i, j], tau[i], typical_r)

</code></pre>


</div>