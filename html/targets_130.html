<div class="container">

<table style="width: 100%;"><tr>
<td>tar_invalidate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Delete one or more metadata records (e.g. to rerun a target).</h2>

<h3>Description</h3>

<p>Delete the metadata of records in <code style="white-space: pre;">⁠_targets/meta/meta⁠</code>
but keep the return values of targets in <code style="white-space: pre;">⁠_targets/objects/⁠</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tar_invalidate(names, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Names of the targets to remove from the metadata list.
The object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code>any_of()</code> or <code>starts_with()</code>
from <code>tidyselect</code> itself, or <code>tar_described_as()</code> to select target names
based on their descriptions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">⁠_targets/⁠</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code>tar_config_get()</code> and <code>tar_config_set()</code> for details
about how to set the data store path persistently
for a project.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function forces one or more targets to rerun
on the next <code>tar_make()</code>, regardless of the cues and regardless
of how those targets are stored. After <code>tar_invalidate()</code>,
you will still be able to locate the data files with <code>tar_path_target()</code>
and manually salvage them in an emergency.
However, <code>tar_load()</code> and <code>tar_read()</code> will not be able to
read the data into R, and subsequent calls to <code>tar_make()</code>
will attempt to rerun those targets.
For patterns recorded in the metadata, all the branches
will be invalidated. For patterns no longer in the metadata,
branches are left alone.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other clean: 
<code>tar_delete()</code>,
<code>tar_destroy()</code>,
<code>tar_prune()</code>,
<code>tar_prune_list()</code>,
<code>tar_unversion()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  library(targets)
  library(tarchetypes)
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
tar_invalidate(starts_with("y")) # Only invalidates y1 and y2.
tar_make() # y1 and y2 rerun but return same values, so z is up to date.
})
}
</code></pre>


</div>