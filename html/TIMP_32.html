<div class="container">

<table style="width: 100%;"><tr>
<td>dat-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "dat" for model and data storage </h2>

<h3>Description</h3>

<p><code>dat</code> is the super-class of other classes representing models and data, so
that other model/data classes (e.g., <code>kin</code> and <code>spec</code>
for kinetic and spectral
models respectively) also have the slots defined here.  Slots whose
description are marked with *** may
be specified in the <code>...</code>
argument of the  <code>initModel</code> function.
</p>


<h3>Objects from the Class</h3>

<p>Objects from the class
can be created by calls of the form <code>new("dat", ...)</code> or
<code>dat(...)</code>, but
most are most often made by invoking another function such as
<code>readData</code> or <code>initModel</code>.
</p>


<h3>Slots</h3>


<dl>
<dt>chinde</dt>
<dd></dd>
<dt>clinde</dt>
<dd></dd>
<dt>clpequspecBD</dt>
<dd></dd>
<dt>cohcol</dt>
<dd></dd>
<dt>compnames</dt>
<dd></dd>
<dt>highcon</dt>
<dd></dd>
<dt>lowcon</dt>
<dd></dd>
<dt>lscalpar</dt>
<dd></dd>
<dt>
<code>thetascal</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  vector of values to scale the parameter vector with. </p>
</dd>
<dt>mvecind</dt>
<dd></dd>
<dt>nvecind</dt>
<dd></dd>
<dt>outMat</dt>
<dd></dd>
<dt>satMat</dt>
<dd></dd>
<dt>usecompnames0</dt>
<dd></dd>
<dt>usecompnamesequ</dt>
<dd></dd>
<dt>weightList</dt>
<dd></dd>
<dt>getX</dt>
<dd></dd>
<dt>getXsuper</dt>
<dd></dd>
<dt>
<code>weightpar</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code>  list of vectors
<code>c(first_x, last_x, first_x2, last_x2, weight)</code>,
where each vector is of length 5 and
specifies an interval in which to weight the data.
</p>

<ul>
<li>
<p>first_x: first(absolute, not an index) <code>x</code> to weight
</p>
</li>
<li>
<p>last_x: last (absolute, not an index) <code>x</code> to weight
</p>
</li>
<li>
<p>first_x2: first (absolute, not an index)  <code>x2</code> to weight
</p>
</li>
<li>
<p>last_x2: last (absolute, not an index)  <code>x2</code> to weight
</p>
</li>
<li>
<p>weight: numeric by which to weight data
</p>
</li>
</ul>
<p>Note that if vector elements 1-4 are <code>NA</code> (not a number), the firstmost
point of the data is taken for elements 1 and 3, and the lastmost points
are taken for 2 and 4.
For example, <code> weightpar = list(c(40, 1500, 400, 600, .9),
  c(NA, NA, 700, 800, .1))</code>  will weight data between times 40 and 1500
picoseconds and 700 and 800 wavelengths by .9, and will weight data at
all times between wavelength 700 and 800 by .1.
Note also that for single photon counting data
<code>weightpar = list(poisson = TRUE)</code> will apply poisson weighting to all
non-zero elements of the data. </p>
</dd>
<dt>
<code>mod_type</code>:</dt>
<dd>
<p>*** Object of class <code>"character"</code> character string defining the model type, e.g.,
<code>"kin"</code> or <code>"spec"</code></p>
</dd>
<dt>
<code>fixed</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code> list of lists or vectors giving the parameter values
to fix (at their starting values) during optimization. </p>
</dd>
<dt>
<code>free</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code> list of lists or vectors giving the parameter values
to free during optimization; if this list is present then all parameters
not specified in it are fixed, e.g., <code>free = list(irfpar = 2)</code> will fix
every parameter at its starting value except for the 2nd <code>irfpar</code>.  If
<code>fix = list(none=TRUE)</code>  (or if the element <code>none</code>  has length
greater than 0) then all parameters in the model are fixed.  Note that this
option only should be applied to multiexperiment models in which at least one
parameter applying to some other dataset is optimized (<code>nls</code> always must
have at least one parameter to optimize).      </p>
</dd>
<dt>
<code>constrained</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code> list whose elements
are lists containing a character vector <code>what</code>, a vector <code>ind</code>, and
either (but not both) a character vector <code>low</code> and <code>high</code>.
<code>what</code> should specify the parameter type to constrain.  <code>ind</code>
should give the index of the parameter to be constrained, e.g., <code>1</code> if
indexing into a vector, and <code>c(1,2)</code> if indexing into a list.
<code>low</code> gives a number that the parameter should always remain lower
than and <code>high</code> gives a number that the parameter should always remain
higher than (so that <code>low</code> bounds the parameter value from above and
<code>high</code> bounds the parameter value from below).  It is not now possible to
specify both <code>low</code> and <code>high</code> for a single parameter value.  An
example of a complete <code>constrained</code> specification is
<code>constrained = list(list(what = "kinpar", ind = 2, low = .3),
list(what = "parmu", ind = c(1,1), high = .002))</code>
</p>
</dd>
<dt>
<code>clp0</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code>  list of lists with elements <code>low</code>, <code>high</code> and
<code>comp</code>, specifying the least value in  <code>x2</code> to constrain
to zero, the greatest value in  <code>x2</code> to
constrain to zero, and the component to which to apply the zero constraint,
respectively.  e.g., <code>clp0 = list(list(low=400, high = 600, comp=2),
  list(low = 600, high = 650, comp=4))</code> applies zero constraints to the spectra
associated with components 2 and 4. </p>
</dd>
<dt>
<code>autoclp0</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code> that has two
elements; <code>oldRes</code>,
the output of <code>fitModel</code> and an index <code>ind</code> representing the
index of the dataset to use in <code>oldRes</code>; <code>ind</code> defaults to
one.   The clp that are negative in <code>oldRes</code> are constrained to
zero in the new model; this is primarily useful when fitting a model,
finding some negative clp, and constraining them to zero by fitting
again with this option.  See  also the help page for <code>opt</code> for
other ways to constrain the clp to non-negativity.
</p>
</dd>
<dt>
<code>clpequspec</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code> list of lists each of which has elements <code>to,
  from, low, high</code>, and optional element <code>dataset</code> to specify the dataset
from which to get the reference clp (that is, a spectrum for kinetic
models).  <code>to</code> is the component to be fixed in relation to some other
component; from is the reference component.  <code>low</code> and <code>high</code>
are the
least and greatest absolute values of the <code>clp</code> vector to constrain.
e.g.,
<code>clpequspec = list(list(low = 400, high = 600, to = 1, from = 2))</code>
will constrain the first component to equality to the second component
between wavelengths 400 and 600.  Note that equality constraints are
actually constraints to a linear relationship.  For each of the equality
constraints specified as a list in the <code>clpequspec</code> list, specify a
starting value parameterizing this linear relation in the vector
<code>clpequ</code>; if true equality is desired then fix the corresponding
parameter in <code>clpequ</code> to 1.  Note that if multiple components are
constrained, the <code>from</code> in the sublists should be increasing order,
(i.e., <code>(list(to=2, from=1, low=100, high=10000),
list(to=3, from=1, low=10000, high=100))</code>, not <code>list(to=3, from=1, low=10000, high=100),
list(to=2, from=1, low=10000, high=100)</code>)</p>
</dd>
<dt>
<code>clpequ</code>:</dt>
<dd>
<p>***Object of class <code>"vector"</code>  describes the
parameters governing the clp equality constraints specified in <code>clpequspec</code></p>
</dd>
<dt>
<code>prelspec</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code>  list of lists to specify the functional
relationship between parameters, each of which has elements
</p>

<ul>
<li>
<p>what1character string describing the parameter type to relate,
e.g., <code>"kinpar"</code>
</p>
</li>
<li>
<p>what2the parameter type on which the relation is based; usually
the same as <code>what1</code>
</p>
</li>
<li>
<p>ind1index into <code>what1</code>
</p>
</li>
<li>
<p>ind2index into <code>what2</code>
</p>
</li>
<li>
<p>relcharacter string,
optional argument to specify functional relation type,
by default linear </p>
</li>
</ul>
<p>e.g.,
<code>prelspec = list(list(what1 = "kinpar", what2 = "kinpar", ind1 = 1,
  ind2 = 5))</code>  relates the 1st element of <code>kinpar</code> to the 5th element of
<code>kinpar</code>.  The starting values parameterizing the relationship are
given in the <code>prel</code> vector</p>
</dd>
<dt>
<code>positivepar</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  containing
character strings of those parameter vectors to constrain to positivity,
e.g., <code>positivepar=c("kinpar")</code></p>
</dd>
<dt>
<code>weight</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code> <code>TRUE</code> when the specification in
<code>weightpar</code> is to be applied and <code>FALSE</code> otherwise</p>
</dd>
<dt>
<code>psi.df</code>:</dt>
<dd>
<p> Object of class <code>"matrix"</code>  dataset from 1 experiment</p>
</dd>
<dt>
<code>psi.weight</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code> weighted  dataset from 1 experiment</p>
</dd>
<dt>
<code>x</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code> time or other independent
variable.  </p>
</dd>
<dt>
<code>nt</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code> length <code>x</code></p>
</dd>
<dt>
<code>x2</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code>  vector of points in
2nd independent dimension, such as wavelengths of wavenumbers</p>
</dd>
<dt>
<code>nl</code>:</dt>
<dd>
<p>Object of class <code>"integer"</code>  length <code>x2</code> </p>
</dd>
<dt>
<code>C2</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code> concentration matrix for
simulated data</p>
</dd>
<dt>
<code>E2</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code> matrix of spectra for
simulated data</p>
</dd>
<dt>
<code>sigma</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code> noise level in
simulated data </p>
</dd>
<dt>
<code>parnames</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code> vector of
parameter names, used internally</p>
</dd>
<dt>
<code>simdata</code>:</dt>
<dd>
<p> Object of class <code>"logical"</code>  logical that is <code>TRUE</code> if the data is simulated,
<code>FALSE</code> otherwise; will determine whether values in <code>C2</code> and
<code>E2</code> are plotted with results</p>
</dd>
<dt>
<code>weightM</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code> weights </p>
</dd>
<dt>
<code>weightsmooth</code>:</dt>
<dd>
<p>Object of class <code>"list"</code> type of smoothing to apply with weighting; not currently
used</p>
</dd>
<dt>
<code>makeps</code>:</dt>
<dd>
<p> Object of class <code>"character"</code>
specifies the prefix of files written to
postscript
</p>
</dd>
<dt>
<code>lclp0</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code> <code>TRUE</code> if specification in <code>clp0</code>
is to be applied and <code>FALSE</code> otherwise </p>
</dd>
<dt>
<code>lclpequ</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code> <code>TRUE</code> if specification in clpequspec
is to be applied and <code>FALSE</code> otherwise</p>
</dd>
<dt>
<code>title</code>:</dt>
<dd>
<p> Object of class <code>"character"</code> displayed on output plots</p>
</dd>
<dt>
<code>mhist</code>:</dt>
<dd>
<p>Object of class <code>"list"</code>  list describing fitting history</p>
</dd>
<dt>
<code>datCall</code>:</dt>
<dd>
<p>Object of class <code>"list"</code> list of calls to functions</p>
</dd>
<dt>
<code>dscal</code>:</dt>
<dd>
<p> Object of class <code>"list"</code> </p>
</dd>
<dt>
<code>dscalspec</code>:</dt>
<dd>
<p> Object of class <code>"list"</code> </p>
</dd>
<dt>
<code>dummy</code>:</dt>
<dd>
<p> Object of class <code>"list"</code> containing dummy parameters</p>
</dd>
<dt>
<code>drel</code>:</dt>
<dd>
<p> Object of class <code>"vector"</code>  vector of starting parameters for dataset scaling relations</p>
</dd>
<dt>
<code>scalx</code>:</dt>
<dd>
<p> Object of class <code>"numeric"</code>  numeric by which to scale the <code>x</code> axis in plotting</p>
</dd>
<dt>prel</dt>
<dd>
<p>vector of starting values for the relations described in
prelspec</p>
</dd>
<dt>
<code>fvecind</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code>  vector containing indices of fixed parameters</p>
</dd>
<dt>
<code>pvecind</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code>  used internally to
store indices of related parameters. </p>
</dd>
<dt>
<code>iter</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>  describing the
number of iterations that is run; this is sometimes
stored after fitting, but has not effect as an argument to
<code>initModel</code></p>
</dd>
<dt>
<code>clpCon</code>:</dt>
<dd>
<p>Object of class <code>"list"</code>  used internally to enforce constraints on the clp</p>
</dd>
<dt>
<code>ncomp</code>:</dt>
<dd>
<p>Object of class <code>"numeric"</code>  describing the number of components in a model</p>
</dd>
<dt>
<code>clpdep</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>  describing whether a model is dependent on the index
of <code>x2</code></p>
</dd>
<dt>
<code>inten</code>:</dt>
<dd>
<p>Object of class <code>"matrix"</code>  for use with FLIM data; represents the number of photons
per pixel measured over the course of all
times $t$ represented by the dataset.  See the help for the <code>readData</code>
function for more information. </p>
</dd>
<dt>
<code>datafile</code>:</dt>
<dd>
<p>Object of class <code>"character"</code>
containing the name of a datafile associated with the <code>psi.df</code> </p>
</dd>
<dt>
<code>clpType</code>:</dt>
<dd>
<p>Object of class <code>"character"</code>
that is "nt" if the model has clp in the "x" dimension and "nl" otherwise
(so that, e.g., if <code>mod\_type = "kin"</code>, then <code>clpType = "nl"</code>).</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum, Joris J. Snellenburg, Sergey P. Laptenok</p>


<h3>See Also</h3>

<p><code>kin-class</code>, <code>spec-class</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># simulate data

 C &lt;- matrix(nrow = 51, ncol = 2)
 k &lt;- c(.5, 1)
 t &lt;- seq(0, 2, by = 2/50)
 C[, 1] &lt;- exp( - k[1] * t)
 C[, 2] &lt;- exp( - k[2] * t)
 E &lt;- matrix(nrow = 51, ncol = 2)
 wavenum &lt;- seq(18000, 28000, by=200)
 location &lt;- c(25000, 20000)
 delta &lt;- c(5000, 7000)
 amp &lt;- c(1, 2)
 E[, 1] &lt;- amp[1] * exp( - log(2) * (2 * (wavenum - location[1])/delta[1])^2)
 E[, 2] &lt;- amp[2] * exp( - log(2) * (2 * (wavenum - location[2])/delta[2])^2)
 sigma &lt;- .001
 Psi_q  &lt;- C %*% t(E) + sigma * rnorm(nrow(C) * nrow(E))

 # initialize an object of class dat
 Psi_q_data &lt;- dat(psi.df = Psi_q, x = t, nt = length(t),
 x2 = wavenum, nl = length(wavenum))

 # initialize an object of class dat via initModel
 # this dat object is also a kin object
 kinetic_model &lt;- initModel(mod_type = "kin", seqmod = FALSE,
 kinpar = c(.1, 2))
</code></pre>


</div>