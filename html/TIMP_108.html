<div class="container">

<table style="width: 100%;"><tr>
<td>kin-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "kin" for kinetic model storage.</h2>

<h3>Description</h3>

<p><code>kin</code> is the class for kinetic models;
an object
of class "kin" is initialized if
<code>mod_type = "kin"</code> is an
argument of <code>initModel</code>.
All objects of class <code>kin</code> are sub-classes of
class <code>dat</code>; see documentation for <code>dat</code>
for a description of
these slots.  </p>


<h3>Details</h3>

<p>See <code>dat-class</code> for an
example of the initialization of a
<code>kin</code> object via the <code>initModel</code> function. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("kin", ...)</code> or
<code>kin(...)</code>.  Slots whose
description are marked with *** may
be specified in the <code>...</code>
argument of the  <code>initModel</code> function.
</p>


<h3>Slots</h3>


<dl>
<dt>anipar</dt>
<dd></dd>
<dt>anispec</dt>
<dd></dd>
<dt>autoclp0</dt>
<dd></dd>
<dt>C2</dt>
<dd></dd>
<dt>chinde</dt>
<dd></dd>
<dt>clinde</dt>
<dd></dd>
<dt>clp0</dt>
<dd></dd>
<dt>clpCon</dt>
<dd></dd>
<dt>clpdep</dt>
<dd></dd>
<dt>clpequ</dt>
<dd></dd>
<dt>clpequspecBD</dt>
<dd></dd>
<dt>clpType</dt>
<dd></dd>
<dt>cohcol</dt>
<dd></dd>
<dt>cohirf</dt>
<dd></dd>
<dt>datafile</dt>
<dd></dd>
<dt>datCall</dt>
<dd></dd>
<dt>drel</dt>
<dd></dd>
<dt>dscal</dt>
<dd></dd>
<dt>dscalspec</dt>
<dd></dd>
<dt>
<code>dummy</code>:</dt>
<dd>
<p>Object of class <code>"list"</code> of dummy parameters which can be used in complex relations</p>
</dd>
<dt>E2</dt>
<dd></dd>
<dt>fixed</dt>
<dd></dd>
<dt>fixedkmat</dt>
<dd></dd>
<dt>free</dt>
<dd></dd>
<dt>fvecind</dt>
<dd></dd>
<dt>getX</dt>
<dd></dd>
<dt>getXsuper</dt>
<dd></dd>
<dt>highcon</dt>
<dd></dd>
<dt>inten</dt>
<dd></dd>
<dt>kin2scal</dt>
<dd></dd>
<dt>kinpar2</dt>
<dd></dd>
<dt>kinscalspecial</dt>
<dd></dd>
<dt>kinscalspecialspec</dt>
<dd></dd>
<dt>lclp0</dt>
<dd></dd>
<dt>lclpequ</dt>
<dd></dd>
<dt>title</dt>
<dd></dd>
<dt>parnames</dt>
<dd></dd>
<dt>prel</dt>
<dd></dd>
<dt>prelspec</dt>
<dd></dd>
<dt>psi.df</dt>
<dd></dd>
<dt>psi.weight</dt>
<dd></dd>
<dt>pvecind</dt>
<dd></dd>
<dt>satMat</dt>
<dd></dd>
<dt>scalx</dt>
<dd></dd>
<dt>usecompnames0</dt>
<dd></dd>
<dt>usecompnamesequ</dt>
<dd></dd>
<dt>usekin2</dt>
<dd></dd>
<dt>weight</dt>
<dd></dd>
<dt>weightList</dt>
<dd></dd>
<dt>weightM</dt>
<dd></dd>
<dt>weightpar</dt>
<dd></dd>
<dt>weightsmooth</dt>
<dd></dd>
<dt>x</dt>
<dd></dd>
<dt>x2</dt>
<dd></dd>
<dt>clpequspec</dt>
<dd></dd>
<dt>compnames</dt>
<dd></dd>
<dt>constrained</dt>
<dd></dd>
<dt>iter</dt>
<dd></dd>
<dt>lightregimespec</dt>
<dd></dd>
<dt>lowcon</dt>
<dd></dd>
<dt>makeps</dt>
<dd></dd>
<dt>mhist</dt>
<dd></dd>
<dt>mod_type</dt>
<dd></dd>
<dt>mvecind</dt>
<dd></dd>
<dt>ncomp</dt>
<dd></dd>
<dt>nl</dt>
<dd></dd>
<dt>nt</dt>
<dd></dd>
<dt>nvecind</dt>
<dd></dd>
<dt>outMat</dt>
<dd></dd>
<dt>positivepar</dt>
<dd></dd>
<dt>sigma</dt>
<dd></dd>
<dt>simdata</dt>
<dd></dd>
<dt>speckin2</dt>
<dd></dd>
<dt>kinpar</dt>
<dd>
<p>*** vector of rate constants to be used as starting
values for the exponential decay of components; the length of this
vector determines the number of components of the kinetic
model. </p>
</dd>
<dt>
<code>specpar</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code>  parameters for
spectral constraints</p>
</dd>
<dt>
<code>seqmod</code>:</dt>
<dd>
<p>*** Object of class <code>"logical"</code>  that is <code>TRUE</code> if a sequential model is to be applied
and <code>FALSE</code> otherwise</p>
</dd>
<dt>
<code>irf</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>   that is <code>TRUE</code> is an IRF is modeled and <code>FALSE</code> otherwise</p>
</dd>
<dt>
<code>mirf</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>  that is <code>TRUE</code> if a measured IRF is modeled and <code>FALSE</code>
otherwise</p>
</dd>
<dt>
<code>measured_irf</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  containing a measured IRF</p>
</dd>
<dt>
<code>convalg</code>:</dt>
<dd>
<p>*** Object of class <code>"numeric"</code>  1-3 determining the numerical convolution algorithm
used in the case of modeling a measured IRF; if <code>3</code> then supply a
reference lifetime in the slot <code>reftau</code>.</p>
</dd>
<dt>
<code>reftau</code>:</dt>
<dd>
<p>*** Object of class <code>"numeric"</code>  containing a
reference lifetime to be used when <code>convalg=3</code></p>
</dd>
<dt>
<code>irffun</code>:</dt>
<dd>
<p>*** Object of class <code>"character"</code>  describing the
function to use to describe the IRF, by default "gaus"</p>
</dd>
<dt>
<code>irfpar</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  of IRF parameters; for the common Gaussian IRF this
vector is ordered <code>c(location, width)</code></p>
</dd>
<dt>
<code>dispmu</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>   that is <code>TRUE</code> if dispersion of the parameter for IRF
location is to be modeled and <code>FALSE</code> otherwise</p>
</dd>
<dt>
<code>dispmufun</code>:</dt>
<dd>
<p>***Object of class <code>"character"</code>  describing the functional form of the
dispersion of the IRF location parameter; if equal to "discrete" then the
IRF location is shifted per element of <code>x2</code> and <code>parmu</code> should have the same
length as <code>x2</code>.  defaults to a polynomial description</p>
</dd>
<dt>
<code>parmu</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code>   of starting values for the dispersion model for the
IRF location</p>
</dd>
<dt>
<code>disptau</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>  that is <code>TRUE</code> if dispersion of the parameter for
IRF width is to be modeled and <code>FALSE</code> otherwise</p>
</dd>
<dt>
<code>disptaufun</code>:</dt>
<dd>
<p>*** Object of class <code>"character"</code>  describing the functional form of the
dispersion of the IRF width parameter; if equal to <code>"discrete"</code> then the
IRF width is parameterized per element of <code>x2</code> and <code>partau</code> should have the same
length as <code>x2</code>.  defaults to a polynomial description</p>
</dd>
<dt>
<code>partau</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  of starting values for the dispersion model for the
IRF FWHM </p>
</dd>
<dt>
<code>fullk</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>  that is <code>TRUE</code> if the data are to be modeled using a
compartmental model defined in a K matrix and <code>FALSE</code> otherwise</p>
</dd>
<dt>
<code>kmat</code>:</dt>
<dd>
<p>*** Object of class <code>"array"</code>  containing the K matrix descriptive of  a compartmental
model</p>
</dd>
<dt>
<code>jvec</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  containing the J vector descriptive of the inputs to a
compartmental model</p>
</dd>
<dt>
<code>ncolc</code>:</dt>
<dd>
<p>Object of class <code>"vector"</code>  describing the number of columns of the C matrix for
each clp in <code>x2</code></p>
</dd>
<dt>
<code>kinscal</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>   of starting values for branching parameters in a
compartmental model</p>
</dd>
<dt>
<code>kmatfit</code>:</dt>
<dd>
<p>Object of class <code>"array"</code>  of fitted values for a compartmental model</p>
</dd>
<dt>
<code>cohspec</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code>   describing the model for
coherent artifact/scatter component(s) containing the element  <code>type</code>
and optionally the element <code>numdatasets</code>.  The element
<code>type</code> can be set as follows:
</p>

<dl>
<dt>
<code>"irf"</code>:</dt>
<dd>
<p>if <code>type="irf"</code>, the coherent artifact/scatter has the
time profile of  the IRF.</p>
</dd>
<dt>
<code>"freeirfdisp"</code>:</dt>
<dd>
<p>if <code>type="freeirfdisp"</code>, the  coherent
artifact/scatter has  a
Gaussian time profile whose location and width are parameterized in the
vector <code>coh</code>.  </p>
</dd>
<dt>
<code>"irfmulti"</code>:</dt>
<dd>
<p>if <code>type="irfmulti"</code> the time profile of
the IRF is used for
the coherent artifact/scatter model, but the IRF parameters are taken per
dataset (for the multidataset case), and the integer argument
<code>numdatasets</code> must be equal to the
number of datasets modeled.</p>
</dd>
<dt>
<code>"seq"</code>:</dt>
<dd>
<p>if <code>type="seq"</code> a sequential exponential decay
model is applied, whose starting value are contained in an additional
list element <code>start</code>. This
often models oscillating behavior well, where the number of
oscillations is the number of parameter starting values given in
<code>start</code>.  The starting values after optimization will be found in
the slot <code>coh</code> of the object of class <code>theta</code> corresponding
to each dataset modeled. </p>
</dd>
<dt>
<code>"mix"</code>:</dt>
<dd>
<p>if <code>type="mix"</code> if <code>type="mix"</code> a sequential exponential decay
model is applied along with a model that follows the time profile of the IRF;
the coherent artifact/scatter is then a linear superposition of these two
models; see the above description of <code>seq</code> for how to supply the
starting values. </p>
</dd>
</dl>
</dd>
<dt>
<code>coh</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  of starting values for the parameterization of a
coherent artifact</p>
</dd>
<dt>
<code>oscspec</code>:</dt>
<dd>
<p>*** Object of class <code>"list"</code> describing the model for
additional oscillation component(s) containing the element  <code>type</code>
and optionally the element <code>start</code>. The element <code>start</code> can be used to specify the starting values for the oscillation function. The element <code>type</code> can be set as follows:
</p>

<dl>
<dt>
<code>"harmonic"</code>:</dt>
<dd>
<p>if <code>type="harmonic"</code>, the oscillation function is a damped harmonic oscillator.</p>
</dd> </dl>
</dd>
<dt>
<code>oscpar</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>  of starting values for the oscillation parameters</p>
</dd>
<dt>
<code>wavedep</code>:</dt>
<dd>
<p>Object of class <code>"logical"</code>  describing whether the kinetic model is dependent on
<code>x2</code> index (i.e., whether there is clp-dependence)</p>
</dd>
<dt>
<code>lambdac</code>:</dt>
<dd>
<p>*** Object of class <code>"numeric"</code>  for the center wavelength to be used in a polynomial
description of <code>x2</code>-dependence </p>
</dd>
<dt>
<code>amplitudes</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>
that may be used to multiply the concentrations by a square diagonal
matrix with the number of columns that the concentration matrix has;
the diagonal is given in <code>amplitudes</code> and these values will be
treated as parameters to be optimized.
</p>
</dd>
<dt>
<code>streak</code>:</dt>
<dd>
<p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code>; if <code>streak=TRUE</code> then
the period of the laser is expected via <code>streakT</code>.</p>
</dd>
<dt>
<code>streakT</code>:</dt>
<dd>
<p>*** Object of class <code>"numeric"</code>
the period of the laser; this will be used to add a
backsweep term to the concentration matrix and should be
set in conjunction <code>streak=TRUE</code>.</p>
</dd>
<dt>
<code>doublegaus</code>:</dt>
<dd>
<p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code> and determines whether a double
Gaussian should be used to model the IRF. If   <code>doublegaus=TRUE</code>
then <code>irfpar</code> should contain four numeric values corresponding to
the location (mean) of the IRF, the FWHM of the first Gaussian, the
FWHM of the second Gaussian, and the relative amplitude of the
second Gaussian, respectively.
</p>
</dd>
<dt>
<code>multiplegaus</code>:</dt>
<dd>
<p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code> and determines whether multiple
Gaussians should be used to model the IRF. If <code>multiplegaus=TRUE</code>
then <code>irfpar</code> should contain: two numeric values corresponding to
the location (mean) and the FWHM of the first Gaussian of the IRF, and
three numeric values for <b>each</b> additional gaussian modeled, corresponding to
the relative scaling to the first gaussian, the shift (in time) relative to the
first gaussian and the FWHM of the additional Gaussian, respectively.
</p>
</dd>
<dt>
<code>numericalintegration</code>:</dt>
<dd>
<p>*** Object of class <code>"logical"</code>
that defaults to <code>FALSE</code> and determines whether a kinetic theory
model of a reaction mechanism should be numerically integrated (using
<span class="pkg">deSolve</span>) to find the concentrations.
If <code>numericalintegration=TRUE</code> then
<code>initialvals</code> should specify the initial concentrations and
<code>reactantstoichiometrymatrix</code> and
<code>stoichiometrymatrix</code> should specify the reaction mechanism,
as per Puxty et. al. (2006).
</p>
</dd>
<dt>
<code>initialvals</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>
giving the concentrations at the initial time step.
</p>
</dd>
<dt>
<code>reactantstoichiometrymatrix</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>
giving the (integer) <dfn>stoichiometric coefficients</dfn> for the reactants; this
is the matrix <b>X</b>r of Puxty et. al. (2006) with <code>dim=NULL</code>.
</p>
</dd>
<dt>
<code>stoichiometrymatrix</code>:</dt>
<dd>
<p>*** Object of class <code>"vector"</code>
giving the (integer) stoichiometric coefficients for the reactions; this
is the matrix <b>X</b> of Puxty et. al. (2006) with <code>dim=NULL</code>.
</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>dat-class</code>, directly.
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, David Nicolaides, Ivo H. M. van Stokkum</p>


<h3>References</h3>

<p>Puxty, G., Maeder, M., and Hungerbuhler, K. (2006) Tutorial on the fitting of
kinetics models to multivariate spectroscopic measurements
with non-linear least-squares regression, <em>Chemometrics and Intelligent
Laboratory Systems</em> <b>81</b>, 149-164.
</p>


<h3>See Also</h3>

<p><code>dat-class</code>, <code>spec-class</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example in modeling second order kinetics, by
## David Nicolaides.

## On simulated data.

##############################
## load TIMP
##############################

library("TIMP")

##############################
## SIMULATE DATA
##############################

## set up the Example problem, a la in-situ UV-Vis spectroscopy of a simple
## reaction.
## A + 2B -&gt; C + D, 2C -&gt; E

cstart &lt;- c(A = 1.0, B = 0.8, C = 0.0, D = 0.0, E = 0.0)
times &lt;- c(seq(0,2, length=21), seq(3,10, length=8))
k &lt;- c(kA = 0.5, k2C = 1)

## stoichiometry matrices

rsmatrix &lt;- c(1,2,0,0,0,0,0,2,0,0)
smatrix &lt;- c(-1,-2,1,1,0,0,0,-2,0,1)
concentrations &lt;- calcD(k, times, cstart, rsmatrix, smatrix)

wavelengths &lt;- seq(500, 700, by=2)
spectra &lt;- matrix(nrow = length(wavelengths), ncol = length(cstart))
location &lt;- c(550, 575, 625, 650, 675)
delta &lt;- c(10, 10, 10, 10, 10)
spectra[, 1] &lt;- exp( - log(2) *
(2 * (wavelengths - location[1])/delta[1])^2)
spectra[, 2] &lt;- exp( - log(2) *
(2 * (wavelengths - location[2])/delta[2])^2)
spectra[, 3] &lt;- exp( - log(2) *
(2 * (wavelengths - location[3])/delta[3])^2)
spectra[, 4] &lt;- exp( - log(2) *
(2 * (wavelengths - location[4])/delta[4])^2)
spectra[, 5] &lt;- exp( - log(2) *
(2 * (wavelengths - location[5])/delta[5])^2)

sigma &lt;- .001
Psi_q &lt;- concentrations %*% t(spectra) + sigma *
  rnorm(dim(concentrations)[1] * dim(spectra)[1])

## store the simulated data in an object of class "dat"
kinetic_data &lt;- dat(psi.df=Psi_q , x = times, nt = length(times),
 x2 = wavelengths, nl = length(wavelengths))

##############################
## DEFINE MODEL
##############################

## starting values
kstart &lt;- c(kA = 1, k2C = 0.5)

## model definition for 2nd order kinetics
kinetic_model &lt;- initModel(mod_type = "kin", seqmod = FALSE,
                           kinpar = kstart,
                           numericalintegration = TRUE,
                           initialvals = cstart,
                           reactantstoichiometrymatrix = rsmatrix,
                           stoichiometrymatrix = smatrix )

##############################
## FIT INITIAL MODEL
## adding constraints to non-negativity of the
## spectra via the opt option nnls=TRUE
##############################

kinetic_fit &lt;- fitModel(data=list(kinetic_data),
                        modspec = list(kinetic_model),
                        opt = kinopt(nnls = TRUE, iter=80,
                        selectedtraces = seq(1,kinetic_data@nl,by=2)))

## look at estimated parameters

parEst(kinetic_fit)

## various results

## concentrations

conRes &lt;- getX(kinetic_fit)

matplot(times, conRes, type="b", col=1,pch=21, bg=1:5, xlab="time (sec)",
        ylab="concentrations", main="Concentrations (2nd order kinetics)")


## spectra

specRes &lt;- getCLP(kinetic_fit)

matplot(wavelengths, specRes, type="b", col=1,pch=21, bg=1:5,
        xlab="wavelength (nm)",
        ylab="amplitude", main="Spectra")

## see help(getResults) for how to get more results information from
## kinetic_fit

##############################
## CLEANUP GENERATED FILES
##############################
# This removes the files that were generated in this example
# (do not run this code if you wish to inspect the output)
file_list_cleanup = c(Sys.glob("*paramEst.txt"), Sys.glob("*.ps"), Sys.glob("Rplots*.pdf"))
# Iterate over the files and delete them if they exist
for (f in file_list_cleanup) {
  if (file.exists(f)) {
    unlink(f)
  }
}

</code></pre>


</div>