<div class="container">

<table style="width: 100%;"><tr>
<td>cox.aalen</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fit Cox-Aalen survival model</h2>

<h3>Description</h3>

<p>Fits an Cox-Aalen survival model.  Time dependent variables and counting
process data (multiple events per subject) are possible.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cox.aalen(
  formula = formula(data),
  data = parent.frame(),
  beta = NULL,
  Nit = 20,
  detail = 0,
  start.time = 0,
  max.time = NULL,
  id = NULL,
  clusters = NULL,
  n.sim = 500,
  residuals = 0,
  robust = 1,
  weighted.test = 0,
  covariance = 0,
  resample.iid = 1,
  weights = NULL,
  rate.sim = 1,
  beta.fixed = 0,
  max.clust = 1000,
  exact.deriv = 1,
  silent = 1,
  max.timepoint.sim = 100,
  basesim = 0,
  offsets = NULL,
  strata = NULL,
  propodds = 0,
  caseweight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object with the response on the left of a '~'
operator, and the independent terms on the right as regressors. The response
must be a survival object as returned by the ‘Surv’ function. Terms with a
proportional effect are specified by the wrapper prop(), and cluster
variables (for computing robust variances) by the wrapper cluster().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>starting value for relative risk estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detail</code></td>
<td>
<p>if 0 no details is printed during iterations, if 1 details are
given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start.time</code></td>
<td>
<p>start of observation period where estimates are computed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.time</code></td>
<td>
<p>end of observation period where estimates are computed.
Estimates thus computed from [start.time, max.time]. Default is max of data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>For timevarying covariates the variable must associate each record
with the id of a subject.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>cluster variable for computation of robust variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>to returns residuals that can be used for model validation
in the function cum.residuals. Estimated martingale increments (dM) and
corresponding time vector (time). When rate.sim=1 returns estimated
martingales, dM_i(t) and if rate.sim=0, returns a matrix of dN_i(t).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robust</code></td>
<td>
<p>to compute robust variances and construct processes for
resampling. May be set to 0 to save memory and time, in particular for
rate.sim=1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted.test</code></td>
<td>
<p>to compute a variance weighted version of the
test-processes used for testing time-varying effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariance</code></td>
<td>
<p>to compute covariance estimates for nonparametric terms
rather than just the variances.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resample.iid</code></td>
<td>
<p>to return i.i.d. representation for nonparametric and
parametric terms. based on counting process or martingale resduals
(rate.sim).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights for weighted analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rate.sim</code></td>
<td>
<p>rate.sim=1 such that resampling of residuals is based on
estimated martingales and thus valid in rate case, rate.sim=0 means that
resampling is based on counting processes and thus only valid in intensity
case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta.fixed</code></td>
<td>
<p>option for computing score process for fixed relative risk
parameter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.clust</code></td>
<td>
<p>sets the total number of i.i.d. terms in i.i.d.
decompostition. This can limit the amount of memory used by coarsening the
clusters. When NULL then all clusters are used.  Default is 1000 to save
memory and time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact.deriv</code></td>
<td>
<p>if 1 then uses exact derivative in last iteration, if 2
then uses exact derivate for all iterations, and if 0 then uses
approximation for all computations and there may be a small bias in the
variance estimates. For Cox model always exact and all options give same
results.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>if 1 then opppresses some output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.timepoint.sim</code></td>
<td>
<p>considers only this resolution on the time scale
for simulations, see time.sim.resolution argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>basesim</code></td>
<td>
<p>1 to get simulations for cumulative baseline, including tests
for contant effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offsets</code></td>
<td>
<p>offsets for analysis on log-scale. RR=exp(offsets+ x beta).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strata</code></td>
<td>
<p>future option for making strata in a different day than
through X design in cox-aalen model (~-1+factor(strata)).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propodds</code></td>
<td>
<p>if 1 will fit the proportional odds model. Slightly less
efficient than prop.odds() function but much quicker, for large data this
also works.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>caseweight</code></td>
<td>
<p>these weights have length equal to number of jump times,
and are multiplied all jump times dN.  Useful for getting the program to fit
for example the proportional odds model or frailty models.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p style="text-align: center;"><code class="reqn"> \lambda_{i}(t) = Y_i(t) ( X_{i}^T(t) \alpha(t) ) \exp(Z_{i}^T \beta ) </code>
</p>

<p>The model thus contains the Cox's regression model as special case.
</p>
<p>To fit a stratified Cox model it is important to parametrize the baseline
apppropriately (see example below).
</p>
<p>Resampling is used for computing p-values for tests of time-varying effects.
Test for proportionality is considered by considering the score processes
for the proportional effects of model.
</p>
<p>The modelling formula uses the standard survival modelling given in the
<b>survival</b> package.
</p>
<p>The data for a subject is presented as multiple rows or 'observations', each
of which applies to an interval of observation (start, stop].  For counting
process data with the )start,stop] notation is used, the 'id' variable is
needed to identify the records for each subject. The program assumes that
there are no ties, and if such are present random noise is added to break
the ties.
</p>


<h3>Value</h3>

<p>returns an object of type "cox.aalen". With the following arguments:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.cum</code></td>
<td>
<p>the martingale
based pointwise variance estimates.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robvar.cum</code></td>
<td>
<p>robust pointwise
variances estimates.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>estimate of parametric components of
model.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.gamma</code></td>
<td>
<p>variance for gamma sandwhich estimator based on
optional variation estimator of score and 2nd derivative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>robvar.gamma</code></td>
<td>
<p>robust variance for gamma.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>residuals</code></td>
<td>
<p>list with
residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of
cumulative components scaled with the variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.testBeq0</code></td>
<td>
<p>p-value for covariate effects based on supremum test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.testBeq0</code></td>
<td>
<p>resampled supremum values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.testBeqC</code></td>
<td>
<p>resampled supremum values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared differences between
observed cumulative and estimate under null of constant effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.testBeqC.is</code></td>
<td>
<p>resampled supremum values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct robust 95% uniform
confidence bands. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.procBeqC</code></td>
<td>
<p>observed test-process of difference
between observed cumulative process and estimate under null of constant
effect over time.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.test.procBeqC</code></td>
<td>
<p>list of 50 random realizations
of test-processes under null based on resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>covariance</code></td>
<td>
<p>covariances for nonparametric terms of model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.iid</code></td>
<td>
<p>Resample processes for nonparametric terms of model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.iid</code></td>
<td>
<p>Resample processes for parametric terms of model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loglike</code></td>
<td>
<p>approximate log-likelihood for model, similar to Cox's
partial likelihood. Only computed when robust=1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D2linv</code></td>
<td>
<p>inverse of
the derivative of the score function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>value of score for final
estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.procProp</code></td>
<td>
<p>observed score process for proportional
part of model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.score</code></td>
<td>
<p>variance of score process (optional
variation estimator for beta.fixed=1 and robust estimator otherwise).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.Prop</code></td>
<td>
<p>p-value based on resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.supProp</code></td>
<td>
<p>re-sampled
absolute supremum values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.test.procProp</code></td>
<td>
<p>list of 50 random
realizations of test-processes for proportionality under the model based on
resampling.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Martinussen and Scheike, Dynamic Regression Models for Survival
Data, Springer (2006).
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(timereg)
data(sTRACE)
# Fits Cox model 
out&lt;-cox.aalen(Surv(time,status==9)~prop(age)+prop(sex)+
prop(vf)+prop(chf)+prop(diabetes),data=sTRACE)

# makes Lin, Wei, Ying test for proportionality
summary(out)
par(mfrow=c(2,3))
plot(out,score=1) 

# Fits stratified Cox model 
out&lt;-cox.aalen(Surv(time,status==9)~-1+factor(vf)+ prop(age)+prop(sex)+
	       prop(chf)+prop(diabetes),data=sTRACE,max.time=7,n.sim=100)
summary(out)
par(mfrow=c(1,2)); plot(out); 
# Same model, but needs to invert the entire marix for the aalen part: X(t) 
out&lt;-cox.aalen(Surv(time,status==9)~factor(vf)+ prop(age)+prop(sex)+
	       prop(chf)+prop(diabetes),data=sTRACE,max.time=7,n.sim=100)
summary(out)
par(mfrow=c(1,2)); plot(out); 


# Fits Cox-Aalen model 
out&lt;-cox.aalen(Surv(time,status==9)~prop(age)+prop(sex)+
               vf+chf+prop(diabetes),data=sTRACE,max.time=7,n.sim=100)
summary(out)
par(mfrow=c(2,3))
plot(out)

</code></pre>


</div>