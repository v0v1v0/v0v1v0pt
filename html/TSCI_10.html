<div class="container">

<table style="width: 100%;"><tr>
<td>tsci_poly</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Two Stage Curvature Identification with Polynomial Basis Expansion</h2>

<h3>Description</h3>

<p><code>tsci_poly</code> implements Two Stage Curvature Identification
(Guo and Buehlmann 2022) with a basis expansion by monomials. Through a data-dependent way it
tests for the smallest sufficiently large violation space among a pre-specified
sequence of nested violation space candidates. Point and uncertainty estimates
of the treatment effect for all violation space candidates including the
selected violation space will be returned amongst other relevant statistics.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tsci_poly(
  Y,
  D,
  Z,
  X = NULL,
  W = X,
  vio_space = NULL,
  create_nested_sequence = TRUE,
  sel_method = c("comparison", "conservative"),
  min_order = 1,
  max_order = 10,
  exact_order = NULL,
  order_selection_method = c("grid search", "backfitting"),
  max_iter = 100,
  conv_tol = 10^-6,
  gcv = FALSE,
  nfolds = 5,
  sd_boot = TRUE,
  iv_threshold = 10,
  threshold_boot = TRUE,
  alpha = 0.05,
  intercept = TRUE,
  B = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>observations of the outcome variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If outcome variable is binary use dummy encoding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>observations of the treatment variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If treatment variable is binary use dummy encoding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Z</code></td>
<td>
<p>observations of the instrumental variable(s). Either a vector of length n
or a matrix with dimension n by s.
If observations are not numeric dummy encoding will be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>observations of baseline covariate(s). Either a vector of length n
or a matrix with dimension n by p or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>(transformed) observations of baseline covariate(s) used to fit the outcome model. Either a vector of length n
or a matrix with dimension n by p_w or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vio_space</code></td>
<td>
<p>either <code>NULL</code> or a list with numeric vectors of length n and/or numeric matrices with n rows as elements to
specify the violation space candidates.
If observations are not numeric dummy encoding will be applied.
See Details for more information.
If <code>NULL</code>, then the violation space candidates are chosen to be a nested sequence
of monomials with degree depending on the orders of the polynomials used to fit
the treatment model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>create_nested_sequence</code></td>
<td>
<p>logical. If <code>TRUE</code>, the violation space candidates (in form of matrices)
are defined sequentially starting with an empty violation matrix and subsequently
adding the next element of <code>vio_space</code> to the current violation matrix.
If <code>FALSE,</code> the violation space candidates (in form of matrices) are defined as the empty space and the elements of <code>vio_space</code>.
See Details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sel_method</code></td>
<td>
<p>The selection method used to estimate the treatment effect. Either "comparison" or "conservative". See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_order</code></td>
<td>
<p>either a single integer value or a vector of integer values of length s specifying
the smallest order of polynomials to use in the selection of the treatment model. If a
single integer value is provided, the polynomials of all instrumental variables use this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_order</code></td>
<td>
<p>either a single integer value or a vector of integer values of length s specifying
the largest order of polynomials to use in the selection of the treatment model. If a
single integer value is provided, the polynomials of all instrumental variables use this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact_order</code></td>
<td>
<p>either a single integer value or a vector of integer values of length s specifying
the exact order of polynomials to use in the treatment model. If a
single integer value is provided, the polynomials of all instrumental variables use this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_selection_method</code></td>
<td>
<p>method used to select the best fitting order of polynomials
for the treatment model. Must be either 'grid search' or 'backfitting'.
'grid search' can be very slow if the number of instruments is large.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_iter</code></td>
<td>
<p>number of iterations used in the backfitting algorithm if <code>order_selection_method</code> is 'backfitting'.
Has to be a positive integer value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv_tol</code></td>
<td>
<p>tolerance of convergence in the backfitting algorithm if <code>order_selection_method</code> is 'backfitting'.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gcv</code></td>
<td>
<p>logical. If <code>TRUE</code>, the generalized cross-validation mean squared error is used
to determine the best fitting order of polynomials for the treatment model.
If <code>FALSE</code>, k-fold cross-validation is used instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfolds</code></td>
<td>
<p>number of folds used for the k-fold cross-validation if <code>gcv</code> is <code>FALSE</code>.
Has to be a positive integer value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the standard error using a bootstrap approach.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iv_threshold</code></td>
<td>
<p>a numeric value specifying the minimum of the threshold of IV strength test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the threshold of the IV strength using a bootstrap approach.
If <code>FALSE</code>, it does not perform a bootstrap. See Details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>the significance level. Has to be a numeric value between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>logical. If <code>TRUE</code>, an intercept is included in the outcome model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>number of bootstrap samples. Has to be a positive integer value.
Bootstrap methods are used to calculate the iv strength threshold if <code>threshold_boot</code> is <code>TRUE</code> and for the violation space selection.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The treatment and outcome models are assumed to be of the following forms:
</p>
<p style="text-align: center;"><code class="reqn">D_i = f(Z_i, X_i) + \delta_i</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_i = \beta \cdot D_i + h(Z_i, X_i) + \phi(X_i) + \epsilon_i</code>
</p>

<p>where <code class="reqn">f(Z_i, X_i)</code> is estimated using a polynomial basis expansion of the instrumental variables
and a linear combination of the baseline covariates,
<code class="reqn">h(Z_i X_i)</code> is approximated using the violation space candidates and <code class="reqn">\phi(X_i)</code> is approximated by
a linear combination of the columns in <code>W</code>. The errors are allowed to be heteroscedastic. <br><br>
The violation space candidates should be in a nested sequence as the violation space selection is performed
by comparing the treatment estimate obtained by each violation space candidate with the estimates of all
violation space candidates further down the list <code>vio_space</code> that provide enough IV strength. Only if no
significant difference was found in all of those comparisons, the violation space
candidate will be selected. If <code>sel_method</code> is 'comparison', the treatment effect estimate of this
violation space candidate will be returned. If <code>sel_method</code> is 'conservative', the treatment effect estimate
of the successive violation space candidate will be returned provided that the IV strength is large enough.
If <code>vio_space</code> is <code>NULL</code> the violation space candidates are chosen to be a nested sequence
of polynomials of the instrumental variables up to the degrees used to fit the treatment model.
This guarantees that the possible spaces of the violation will be tested.
If the functional form of the outcome model is not well-known it is advisable to use the default values
for <code>W</code> and <code>vio_space</code>. <br><br>
The instrumental variable(s) are considered strong enough for violation space candidate <code class="reqn">V_q</code> if the estimated IV strength using this
violation space candidate is larger than the obtained value of the threshold of the IV strength.
The formula of the threshold of the IV strength has the form
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \} + S (V_q), 40 \}</code> if <code>threshold_boot</code> is <code>TRUE</code>, and
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \}, 40 \}</code> if <code>threshold_boot</code> is <code>FALSE</code>. The matrix
<code class="reqn">\mathrm{M} (V_q)</code> depends on the hat matrix obtained from estimating <code class="reqn">f(Z_i, X_i)</code>, the violation space candidate <code class="reqn">V_q</code> and
the variables to include in the outcome model <code>W</code>. <code class="reqn">S (V_q)</code> is obtained using a bootstrap and aims to adjust for the estimation error
of the IV strength.
Usually, the value of the threshold of the IV strength obtained using the bootstrap approach is larger.
Thus, using <code>threshold_boot</code> equals <code>TRUE</code> leads to a more conservative IV strength test.
For more information see subsection 3.3 in Guo and Buehlmann (2022). <br><br>
See also Carl et al. (2023) for more details.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>Coef_all</code></dt>
<dd>
<p>a series of point estimates of the treatment effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>sd_all</code></dt>
<dd>
<p>standard errors of the estimates of the treatmnet effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>pval_all</code></dt>
<dd>
<p>p-values of the treatment effect estimates obtained by the
different violation space candidates.</p>
</dd>
<dt><code>CI_all</code></dt>
<dd>
<p>confidence intervals for the treatment effect obtained by the
different violation space candidates.</p>
</dd>
<dt><code>Coef_sel</code></dt>
<dd>
<p>the point estimator of the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>sd_sel</code></dt>
<dd>
<p>the standard error of Coef_sel.</p>
</dd>
<dt><code>pval_sel</code></dt>
<dd>
<p>p-value of the treatment effect estimate obtained by the
selected violation space candidate(s).</p>
</dd>
<dt><code>CI_sel</code></dt>
<dd>
<p>confidence interval for the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>iv_str</code></dt>
<dd>
<p>IV strength using the different violation space candidates.</p>
</dd>
<dt><code>iv_thol</code></dt>
<dd>
<p>the threshold for the IV strength using the different violation space candidates.</p>
</dd>
<dt><code>Qmax</code></dt>
<dd>
<p>the violation space candidate that was the largest violation space candidate
for which the IV strength was considered large enough determined by the IV strength test.
If 0, the IV Strength test failed for the first violation space candidate.
Otherwise, violation space selection was performed.</p>
</dd>
<dt><code>q_comp</code></dt>
<dd>
<p>the violation space candidate that was selected by the comparison method over the multiple data splits.</p>
</dd>
<dt><code>q_cons</code></dt>
<dd>
<p>the violation space candidate that was selected by the conservative method over the multiple data splits.</p>
</dd>
<dt><code>invalidity</code></dt>
<dd>
<p>shows whether the instrumental variable(s) were considered valid, invalid or too weak to test for violations.
The instrumental variables are considered too weak to test for violations if the IV strength is already too weak using the first
violation space candidate (besides the empty violation space). Testing for violations is always performed by using the comparison method.</p>
</dd>
<dt><code>mse</code></dt>
<dd>
<p>the out-of-sample mean squared error of the treatment model.</p>
</dd>
</dl>
<h3>References</h3>


<ul>
<li>
<p>Zijian Guo, and Peter Buehlmann. Two Stage Curvature Identification with
Machine Learning: Causal Inference with Possibly Invalid Instrumental Variables.
<em>arXiv:2203.12808</em>, 2022
</p>
</li>
<li>
<p>David Carl, Corinne Emmenegger, Peter Buehlmann, and Zijian Guo. TSCI:
two stage curvature identification for causal inference with invalid instruments.
<em>arXiv:2304.00513</em>, 2023
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>tsci_forest</code> for TSCI with random forest. <br><br><code>tsci_boosting</code> for TSCI with boosting. <br><br><code>tsci_secondstage</code> for TSCI with user provided hat matrix. <br><br></p>


<h3>Examples</h3>

<pre><code class="language-R">### a small example without baseline covariates
if (require("MASS")) {
  # sample size
  n &lt;- 100
  # the IV strength
  a &lt;- 1
  # the violation strength
  tau &lt;- 1
  # true effect
  beta &lt;- 1
  # treatment model
  f &lt;- function(x) {1 + a * (x + x^2)}
  # outcome model
  g &lt;- function(x) {1 + tau * x}

  # generate data
  mu_error &lt;- rep(0, 2)
  Cov_error &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
  Error &lt;- MASS::mvrnorm(n, mu_error, Cov_error)
  # instrumental variable
  Z &lt;- rnorm(n)
  # treatment variable
  D &lt;- f(Z) + Error[, 1]
  # outcome variable
  Y &lt;- beta * D + g(Z) + Error[, 2]

  # Two Stage Polynomials
  output_PO &lt;- tsci_poly(Y, D, Z, max_order = 3, max_iter = 20, B = 100)
  summary(output_PO)
}
</code></pre>


</div>