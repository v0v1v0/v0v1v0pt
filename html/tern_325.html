<div class="container">

<table style="width: 100%;"><tr>
<td>prune_occurrences</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Occurrence table pruning</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt="[Stable]"></a>
</p>
<p>Family of constructor and condition functions to flexibly prune occurrence tables.
The condition functions always return whether the row result is higher than the threshold.
Since they are of class <code>CombinationFunction()</code> they can be logically combined with other condition
functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">keep_rows(row_condition)

keep_content_rows(content_row_condition)

has_count_in_cols(atleast, ...)

has_count_in_any_col(atleast, ...)

has_fraction_in_cols(atleast, ...)

has_fraction_in_any_col(atleast, ...)

has_fractions_difference(atleast, ...)

has_counts_difference(atleast, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>row_condition</code></td>
<td>
<p>(<code>CombinationFunction</code>)<br> condition function which works on individual
analysis rows and flags whether these should be kept in the pruned table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>content_row_condition</code></td>
<td>
<p>(<code>CombinationFunction</code>)<br> condition function which works on individual
first content rows of leaf tables and flags whether these leaf tables should be kept in the pruned table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>atleast</code></td>
<td>
<p>(<code>numeric(1)</code>)<br> threshold which should be met in order to keep the row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments for row or column access, see <code>rtables_access</code>: either <code>col_names</code> (<code>character</code>) including
the names of the columns which should be used, or alternatively <code>col_indices</code> (<code>integer</code>) giving the indices
directly instead.</p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul><li> <p><code>keep_rows()</code> returns a pruning function that can be used with <code>rtables::prune_table()</code>
to prune an <code>rtables</code> table.
</p>
</li></ul>
<ul><li> <p><code>keep_content_rows()</code> returns a pruning function that checks the condition on the first content
row of leaf tables in the table.
</p>
</li></ul>
<ul><li> <p><code>has_count_in_cols()</code> returns a condition function that sums the counts in the specified column.
</p>
</li></ul>
<ul><li> <p><code>has_count_in_any_col()</code> returns a condition function that compares the counts in the
specified columns with the threshold.
</p>
</li></ul>
<ul><li> <p><code>has_fraction_in_cols()</code> returns a condition function that sums the counts in the
specified column, and computes the fraction by dividing by the total column counts.
</p>
</li></ul>
<ul><li> <p><code>has_fraction_in_any_col()</code> returns a condition function that looks at the fractions
in the specified columns and checks whether any of them fulfill the threshold.
</p>
</li></ul>
<ul><li> <p><code>has_fractions_difference()</code> returns a condition function that extracts the fractions of each
specified column, and computes the difference of the minimum and maximum.
</p>
</li></ul>
<ul><li> <p><code>has_counts_difference()</code> returns a condition function that extracts the counts of each
specified column, and computes the difference of the minimum and maximum.
</p>
</li></ul>
<h3>Functions</h3>


<ul>
<li> <p><code>keep_rows()</code>: Constructor for creating pruning functions based on
a row condition function. This removes all analysis rows (<code>TableRow</code>) that should be
pruned, i.e., don't fulfill the row condition. It removes the sub-tree if there are no
children left.
</p>
</li>
<li> <p><code>keep_content_rows()</code>: Constructor for creating pruning functions based on
a condition for the (first) content row in leaf tables. This removes all leaf tables where
the first content row does not fulfill the condition. It does not check individual rows.
It then proceeds recursively by removing the sub tree if there are no children left.
</p>
</li>
<li> <p><code>has_count_in_cols()</code>: Constructor for creating condition functions on total counts in the specified columns.
</p>
</li>
<li> <p><code>has_count_in_any_col()</code>: Constructor for creating condition functions on any of the counts in
the specified columns satisfying a threshold.
</p>
</li>
<li> <p><code>has_fraction_in_cols()</code>: Constructor for creating condition functions on total fraction in
the specified columns.
</p>
</li>
<li> <p><code>has_fraction_in_any_col()</code>: Constructor for creating condition functions on any fraction in
the specified columns.
</p>
</li>
<li> <p><code>has_fractions_difference()</code>: Constructor for creating condition function that checks the difference
between the fractions reported in each specified column.
</p>
</li>
<li> <p><code>has_counts_difference()</code>: Constructor for creating condition function that checks the difference
between the counts reported in each specified column.
</p>
</li>
</ul>
<h3>Note</h3>

<p>Since most table specifications are worded positively, we name our constructor and condition
functions positively, too. However, note that the result of <code>keep_rows()</code> says what
should be pruned, to conform with the <code>rtables::prune_table()</code> interface.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
tab &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE") %&gt;%
  split_rows_by("STRATA1") %&gt;%
  summarize_row_groups() %&gt;%
  analyze_vars("COUNTRY", .stats = "count_fraction") %&gt;%
  build_table(DM)



# `keep_rows`
is_non_empty &lt;- !CombinationFunction(all_zero_or_na)
prune_table(tab, keep_rows(is_non_empty))


# `keep_content_rows`

more_than_twenty &lt;- has_count_in_cols(atleast = 20L, col_names = names(tab))
prune_table(tab, keep_content_rows(more_than_twenty))



more_than_one &lt;- has_count_in_cols(atleast = 1L, col_names = names(tab))
prune_table(tab, keep_rows(more_than_one))



# `has_count_in_any_col`
any_more_than_one &lt;- has_count_in_any_col(atleast = 1L, col_names = names(tab))
prune_table(tab, keep_rows(any_more_than_one))



# `has_fraction_in_cols`
more_than_five_percent &lt;- has_fraction_in_cols(atleast = 0.05, col_names = names(tab))
prune_table(tab, keep_rows(more_than_five_percent))



# `has_fraction_in_any_col`
any_atleast_five_percent &lt;- has_fraction_in_any_col(atleast = 0.05, col_names = names(tab))
prune_table(tab, keep_rows(any_atleast_five_percent))



# `has_fractions_difference`
more_than_five_percent_diff &lt;- has_fractions_difference(atleast = 0.05, col_names = names(tab))
prune_table(tab, keep_rows(more_than_five_percent_diff))



more_than_one_diff &lt;- has_counts_difference(atleast = 1L, col_names = names(tab))
prune_table(tab, keep_rows(more_than_one_diff))


</code></pre>


</div>