<div class="container">

<table style="width: 100%;"><tr>
<td>SOBIboot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Second-order Separation Sub-White-Noise Bootstrap Testing with SOBI
</h2>

<h3>Description</h3>

<p>The function uses SOBI (Second Order Blind Identification) to test whether the last <code>p-k</code> latent series are pure white noise, assuming a p-variate second-order stationary blind source separation (BSS) model. Four different bootstrapping strategies are available and the function can be run in parallel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">SOBIboot(X, ...)

## Default S3 method:
SOBIboot(X, k, tau = 1:12, n.boot = 200, s.boot = c("p", "np1", "np2", "np3"),
         ncores = NULL, iseed = NULL, eps = 1e-06, maxiter = 200, ...)
## S3 method for class 'ts'
SOBIboot(X, ...)
## S3 method for class 'xts'
SOBIboot(X, ...)
## S3 method for class 'zoo'
SOBIboot(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code>ts</code>, <code>xts</code> or <code>zoo</code>. Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of latent series that are not white noise. Can be between <code class="reqn">0</code> and <code class="reqn">p-1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The vector of lags for the SOBI autocovariance matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.boot</code></td>
<td>
<p>The number of bootstrapping samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.boot</code></td>
<td>
<p>Bootstrapping strategy to be used. Possible values are <code>"p"</code> (default), <code>"np1"</code>, <code>"np2"</code>, <code>"np3"</code>. See details for further information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>The number of cores to be used. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <code>makeCluster</code> with <code>type = "PSOCK"</code> is used. It is the users repsonsibilty to choose a reasonable value for <code>ncores</code>. The function <code>detectCores</code> might be useful in this context.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iseed</code></td>
<td>
<p>If parallel computation is used, the seed passed on to <code>clusterSetRNGStream</code>. Default is <code>NULL</code> which means no fixed seed is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>The convergence tolerance for the joint diagonalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>The maximum number of iterations for the joint diagonalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>SOBI standardizes <code>X</code> with <code class="reqn">n</code> samples and jointly diagonalizes the autocovariance matrices of the standardized data for a chosen set of lags <code>tau</code>, yielding a transformation <code class="reqn">\bf W</code> giving the latent variables as <code class="reqn">{\bf S} = {\bf X} {\bf W}</code>. Assume, without loss of generality, that the latent components are ordered in decreasing order with respect to the sums of squares of the corresponding "eigenvalues" produced by the joint diagonalization. Under the null hypothesis the final <code class="reqn">p - k</code> "eigenvalues" of each of the autocovariance matrices equal zero, <code class="reqn">\lambda^\tau_{p-k} = \cdots = \lambda^\tau_{p} = 0</code>, and their mean square <code class="reqn">m</code> over all lags can be used as a test statistic in bootstrap-based inference on the true number of latent white noise series.
</p>
<p>The function offers four different bootstrapping strategies for generating samples for which the null hypothesis approximately holds, and they are all based on the following general formula:
</p>

<ol>
<li>
<p> Decompose the SOBI-estimated latent series <code class="reqn">\bf S</code> into the postulated signal <code class="reqn">{\bf S}_1</code> and white noise <code class="reqn">{\bf S}_2</code>.
</p>
</li>
<li>
<p> Take <code class="reqn">n</code> bootstrap samples <code class="reqn">{\bf S}_2^*</code> of <code class="reqn">{\bf S}_2</code>, see the different strategies below.
</p>
</li>
<li>
<p> Recombine <code class="reqn">\bf S^* = ({\bf S}_1, {\bf S}_2^*)</code> and back-transform <code class="reqn">{\bf X}^*= {\bf S}^* {\bf W}^{-1}</code>.
</p>
</li>
<li>
<p> Compute the test statistic based on <code class="reqn">{\bf X}^*</code>.
</p>
</li>
</ol>
<p>The four different bootstrapping strategies are:
</p>

<ol>
<li> <p><code>s.boot = "p"</code>: 
The first strategy is parametric and simply generates all boostrap samples independently and identically from the standard normal distribution.
</p>
</li>
<li> <p><code>s.boot = "np1"</code>: 
The second strategy is non-parametric and pools all observed <code class="reqn">n(p - k)</code> white noise observations together and draws the bootstrap samples from amongst them.
</p>
</li>
<li> <p><code>s.boot = "np2"</code>: 
The third strategy is non-parametric and proceeds otherwise as the second strategy but acts component-wise. That is, separately for each of the <code class="reqn">p - k</code> white noise series it pools the observed <code class="reqn">n</code> white noise observations together and draws the bootstrap samples of that particular latent series from amongst them.
</p>
</li>
<li> <p><code>s.boot = "np3"</code>: 
The third strategy is non-parametric and instead of drawing the samples univariately as in the second and third strategies, proceeds by resampling <code class="reqn">n</code> vectors of size <code class="reqn">p - k</code> from amongst all the observed <code class="reqn">n</code> white noise vectors.
</p>
</li>
</ol>
<p>The function can be run in parallel by setting <code>ncores</code> to the desired number of cores (should be less than the number of cores available - 1). When running code in parallel the standard random seed of R is overridden and if a random seed needs to be set it should be passed via the argument <code>iseed</code>. The argument <code>iseed</code> has no effect in case <code>ncores</code> equals 1 (the default value).
</p>
<p>This function uses for the joint diagonalization the function <code>frjd.int</code>, which does not fail in case of failed convergence but returns the estimate from the final step.
</p>


<h3>Value</h3>

<p>A list of class ictest, inheriting from class htest, containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>The value of the test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>The p-value of the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>The number of bootstrap samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>Character string specifying the alternative hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of latent series that are not white noise used in the testing problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>The transformation matrix to the latent series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Multivariate time series with the centered source components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>The underlying eigenvalues of the autocovariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MU</code></td>
<td>
<p>The location of the data which was subtracted before calculating SOBI.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The used set of lags.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character string indicating which test was performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.name</code></td>
<td>
<p>Character string giving the name of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.boot</code></td>
<td>
<p>Character string denoting which bootstrapping test version was used.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen, Joni Virta
</p>


<h3>References</h3>

<p>Matilainen, M., Nordhausen, K. and Virta, J. (2018), <em>On the Number of Signals in Multivariate Time Series</em>. In Deville, Y., Gannot, S., Mason, R., Plumbley, M.D. and  Ward, D. (editors) "International Conference on Latent Variable Analysis and Signal Separation", LNCS 10891, 248â€“258. Springer, Cham., &lt;doi:10.1007/978-3-319-93764-9_24&gt;.
</p>


<h3>See Also</h3>

<p><code>AMUSE</code>, <code>AMUSEboot</code>, <code>SOBI</code>, <code>tsboot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  n &lt;- 1000
  
  A &lt;- matrix(rnorm(16), 4, 4)
  s1 &lt;- arima.sim(list(ar = c(0, 0, 0.3, 0.6)), n)
  s2 &lt;- arima.sim(list(ma = c(0, 0, -0.3, 0.3)), n)
  s3 &lt;- rnorm(n)
  s4 &lt;- rnorm(n)
  
  S &lt;- cbind(s1, s2, s3, s4)
  X &lt;- S %*% t(A)
  
  boot_res_1 &lt;- SOBIboot(X, k = 1)
  boot_res_1
  
  boot_res_2 &lt;- SOBIboot(X, k = 2)
  boot_res_2

  # Plots of the estimated sources, the last two are white noise
  plot(boot_res_2)

  # Note that AMUSEboot with lag 1 does not work due to the lack of short range dependencies
  AMUSEboot(X, k = 1)
  
  # xts series as input
  library("xts")
  data(sample_matrix)
  X2 &lt;- as.xts(sample_matrix)
  boot_res_xts &lt;- SOBIboot(X2, k = 2)
  plot(boot_res_xts, multi.panel = TRUE)

  # zoo series as input
  X3 &lt;- as.zoo(X)
  boot_res_zoo &lt;- SOBIboot(X3, k = 2)
  plot(boot_res_zoo)

</code></pre>


</div>