<div class="container">

<table style="width: 100%;"><tr>
<td>tfd_variational_gaussian_process</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Posterior predictive of a variational Gaussian process</h2>

<h3>Description</h3>

<p>This distribution implements the variational Gaussian process (VGP), as
described in Titsias (2009) and Hensman (2013). The VGP is an
inducing point-based approximation of an exact GP posterior.
Ultimately, this Distribution class represents a marginal distribution over function values at a
collection of <code>index_points</code>. It is parameterized by
</p>

<ul>
<li>
<p> a kernel function,
</p>
</li>
<li>
<p> a mean function,
</p>
</li>
<li>
<p> the (scalar) observation noise variance of the normal likelihood,
</p>
</li>
<li>
<p> a set of index points,
</p>
</li>
<li>
<p> a set of inducing index points, and
</p>
</li>
<li>
<p> the parameters of the (full-rank, Gaussian) variational posterior
distribution over function values at the inducing points, conditional on some observations.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">tfd_variational_gaussian_process(
  kernel,
  index_points,
  inducing_index_points,
  variational_inducing_observations_loc,
  variational_inducing_observations_scale,
  mean_fn = NULL,
  observation_noise_variance = 0,
  predictive_noise_variance = 0,
  jitter = 1e-06,
  validate_args = FALSE,
  allow_nan_stats = FALSE,
  name = "VariationalGaussianProcess"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p><code>PositiveSemidefiniteKernel</code>-like instance representing the
GP's covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_points</code></td>
<td>
<p><code>float</code> <code>Tensor</code> representing finite (batch of) vector(s) of
points in the index set over which the VGP is defined. Shape has the
form <code style="white-space: pre;">⁠[b1, ..., bB, e1, f1, ..., fF]⁠</code> where <code>F</code> is the number of feature
dimensions and must equal <code>kernel$feature_ndims</code> and <code>e1</code> is the number
(size) of index points in each batch (we denote it <code>e1</code> to distinguish
it from the numer of inducing index points, denoted <code>e2</code> below).
Ultimately the VariationalGaussianProcess distribution corresponds to an
<code>e1</code>-dimensional multivariate normal. The batch shape must be
broadcastable with <code>kernel$batch_shape</code>, the batch shape of
<code>inducing_index_points</code>, and any batch dims yielded by <code>mean_fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inducing_index_points</code></td>
<td>
<p><code>float</code> <code>Tensor</code> of locations of inducing points in
the index set. Shape has the form <code style="white-space: pre;">⁠[b1, ..., bB, e2, f1, ..., fF]⁠</code>, just
like <code>index_points</code>. The batch shape components needn't be identical to
those of <code>index_points</code>, but must be broadcast compatible with them.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variational_inducing_observations_loc</code></td>
<td>
<p><code>float</code> <code>Tensor</code>; the mean of the
(full-rank Gaussian) variational posterior over function values at the
inducing points, conditional on observed data. Shape has the form <code style="white-space: pre;">⁠[b1, ..., bB, e2]⁠</code>,
where <code style="white-space: pre;">⁠b1, ..., bB⁠</code> is broadcast compatible with other
parameters' batch shapes, and <code>e2</code> is the number of inducing points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variational_inducing_observations_scale</code></td>
<td>
<p><code>float</code> <code>Tensor</code>; the scale
matrix of the (full-rank Gaussian) variational posterior over function
values at the inducing points, conditional on observed data. Shape has
the form <code style="white-space: pre;">⁠[b1, ..., bB, e2, e2]⁠</code>, where <code style="white-space: pre;">⁠b1, ..., bB⁠</code> is broadcast
compatible with other parameters and <code>e2</code> is the number of inducing points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_fn</code></td>
<td>
<p>function that acts on index points to produce a (batch
of) vector(s) of mean values at those index points. Takes a <code>Tensor</code> of
shape <code style="white-space: pre;">⁠[b1, ..., bB, f1, ..., fF]⁠</code> and returns a <code>Tensor</code> whose shape is
(broadcastable with) <code style="white-space: pre;">⁠[b1, ..., bB]⁠</code>. Default value: <code>NULL</code> implies constant zero function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observation_noise_variance</code></td>
<td>
<p><code>float</code> <code>Tensor</code> representing the variance
of the noise in the Normal likelihood distribution of the model. May be
batched, in which case the batch shape must be broadcastable with the
shapes of all other batched parameters (<code>kernel$batch_shape</code>, <code>index_points</code>, etc.).
Default value: <code>0.</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>predictive_noise_variance</code></td>
<td>
<p><code>float</code> <code>Tensor</code> representing additional
variance in the posterior predictive model. If <code>NULL</code>, we simply re-use
<code>observation_noise_variance</code> for the posterior predictive noise. If set
explicitly, however, we use the given value. This allows us, for
example, to omit predictive noise variance (by setting this to zero) to
obtain noiseless posterior predictions of function values, conditioned
on noisy observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p><code>float</code> scalar <code>Tensor</code> added to the diagonal of the covariance
matrix to ensure positive definiteness of the covariance matrix. Default value: <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validate_args</code></td>
<td>
<p>Logical, default FALSE. When TRUE distribution parameters are checked
for validity despite possibly degrading runtime performance. When FALSE invalid inputs may
silently render incorrect outputs. Default value: FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_nan_stats</code></td>
<td>
<p>Logical, default TRUE. When TRUE, statistics (e.g., mean, mode, variance)
use the value NaN to indicate the result is undefined. When FALSE, an exception is raised if
one or more of the statistic's batch members are undefined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>name prefixed to Ops created by this class.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A VGP is "trained" by selecting any kernel parameters, the locations of the
inducing index points, and the variational parameters. Titsias (2009) and
Hensman (2013) describe a variational lower bound on the marginal log
likelihood of observed data, which this class offers through the
<code>variational_loss</code> method (this is the negative lower bound, for convenience
when plugging into a TF Optimizer's <code>minimize</code> function).
Training may be done in minibatches.
</p>
<p>Titsias (2009) describes a closed form for the optimal variational
parameters, in the case of sufficiently small observational data (ie,
small enough to fit in memory but big enough to warrant approximating the GP
posterior). A method to compute these optimal parameters in terms of the full
observational data set is provided as a staticmethod,
<code>optimal_variational_posterior</code>. It returns a
<code>MultivariateNormalLinearOperator</code> instance with optimal location and scale parameters.
</p>
<p>Mathematical Details
</p>
<p>Notation
We will in general be concerned about three collections of index points, and
it'll be good to give them names:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠x[1], ..., x[N]⁠</code>: observation index points – locations of our observed data.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠z[1], ..., z[M]⁠</code>: inducing index points  – locations of the
"summarizing" inducing points
</p>
</li>
<li> <p><code style="white-space: pre;">⁠t[1], ..., t[P]⁠</code>: predictive index points – locations where we are
making posterior predictions based on observations and the variational
parameters.
</p>
</li>
</ul>
<p>To lighten notation, we'll use <code style="white-space: pre;">⁠X, Z, T⁠</code> to denote the above collections.
Similarly, we'll denote by <code>f(X)</code> the collection of function values at each of
the <code>x[i]</code>, and by <code>Y</code>, the collection of (noisy) observed data at each <code>x[i]</code>.
We'll denote kernel matrices generated from pairs of index points as <code>K_tt</code>,
<code>K_xt</code>, <code>K_tz</code>, etc, e.g.,
</p>
<div class="sourceCode"><pre>K_tz =
| k(t[1], z[1])    k(t[1], z[2])  ...  k(t[1], z[M]) |
| k(t[2], z[1])    k(t[2], z[2])  ...  k(t[2], z[M]) |
|      ...              ...                 ...      |
| k(t[P], z[1])    k(t[P], z[2])  ...  k(t[P], z[M]) |

</pre></div>
<p>Preliminaries
A Gaussian process is an indexed collection of random variables, any finite
collection of which are jointly Gaussian. Typically, the index set is some
finite-dimensional, real vector space, and indeed we make this assumption in
what follows. The GP may then be thought of as a distribution over functions
on the index set. Samples from the GP are functions <em>on the whole index set</em>;
these can't be represented in finite compute memory, so one typically works
with the marginals at a finite collection of index points. The properties of
the GP are entirely determined by its mean function <code>m</code> and covariance
function <code>k</code>. The generative process, assuming a mean-zero normal likelihood
with stddev <code>sigma</code>, is
</p>
<div class="sourceCode"><pre>f ~ GP(m, k)
Y | f(X) ~ Normal(f(X), sigma),   i = 1, ... , N
</pre></div>
<p>In finite terms (ie, marginalizing out all but a finite number of f(X), sigma),
we can write
</p>
<div class="sourceCode"><pre>f(X) ~ MVN(loc=m(X), cov=K_xx)
Y | f(X) ~ Normal(f(X), sigma),   i = 1, ... , N
</pre></div>
<p>Posterior inference is possible in analytical closed form but becomes
intractible as data sizes get large. See Rasmussen (2006) for details.
</p>
<p>The VGP
</p>
<p>The VGP is an inducing point-based approximation of an exact GP posterior,
where two approximating assumptions have been made:
</p>

<ol>
<li>
<p> function values at non-inducing points are mutually independent
conditioned on function values at the inducing points,
</p>
</li>
<li>
<p> the (expensive) posterior over function values at inducing points
conditional on obseravtions is replaced with an arbitrary (learnable)
full-rank Gaussian distribution,
</p>
</li>
</ol>
<div class="sourceCode"><pre>q(f(Z)) = MVN(loc=m, scale=S),
</pre></div>
<p>where <code>m</code> and <code>S</code> are parameters to be chosen by optimizing an evidence
lower bound (ELBO).
The posterior predictive distribution becomes
</p>
<div class="sourceCode"><pre>q(f(T)) = integral df(Z) p(f(T) | f(Z)) q(f(Z)) = MVN(loc = A @ m, scale = B^(1/2))
</pre></div>
<p>where
</p>
<div class="sourceCode"><pre>A = K_tz @ K_zz^-1
B = K_tt - A @ (K_zz - S S^T) A^T
</pre></div>
<p>The approximate posterior predictive distribution <code>q(f(T))</code> is what the
<code>VariationalGaussianProcess</code> class represents.
</p>
<p>Model selection in this framework entails choosing the kernel parameters,
inducing point locations, and variational parameters. We do this by optimizing
a variational lower bound on the marginal log likelihood of observed data. The
lower bound takes the following form (see Titsias (2009) and
Hensman (2013) for details on the derivation):
</p>
<div class="sourceCode"><pre>L(Z, m, S, Y) = MVN(loc=
(K_zx @ K_zz^-1) @ m, scale_diag=sigma).log_prob(Y) -
(Tr(K_xx - K_zx @ K_zz^-1 @ K_xz) +
Tr(S @ S^T @ K_zz^1 @ K_zx @ K_xz @ K_zz^-1)) / (2 * sigma^2) -
KL(q(f(Z)) || p(f(Z))))
</pre></div>
<p>where in the final KL term, <code>p(f(Z))</code> is the GP prior on inducing point
function values. This variational lower bound can be computed on minibatches
of the full data set <code style="white-space: pre;">⁠(X, Y)⁠</code>. A method to compute the <em>negative</em> variational
lower bound is implemented as <code>VariationalGaussianProcess$variational_loss</code>.
</p>
<p>Optimal variational parameters
</p>
<p>As described in Titsias (2009), a closed form optimum for the variational
location and scale parameters, <code>m</code> and <code>S</code>, can be computed when the
observational data are not prohibitively voluminous. The
<code>optimal_variational_posterior</code> function to computes the optimal variational
posterior distribution over inducing point function values in terms of the GP
parameters (mean and kernel functions), inducing point locations, observation
index points, and observations. Note that the inducing index point locations
must still be optimized even when these parameters are known functions of the
inducing index points. The optimal parameters are computed as follows:
</p>
<div class="sourceCode"><pre>C = sigma^-2 (K_zz + K_zx @ K_xz)^-1
optimal Gaussian covariance: K_zz @ C @ K_zz
optimal Gaussian location: sigma^-2 K_zz @ C @ K_zx @ Y
</pre></div>


<h3>Value</h3>

<p>a distribution instance.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="http://proceedings.mlr.press/v5/titsias09a/titsias09a.pdf">Titsias, M. "Variational Model Selection for Sparse Gaussian Process Regression", 2009.</a>
</p>
</li>
<li> <p><a href="https://arxiv.org/abs/1309.6835">Hensman, J., Lawrence, N. "Gaussian Processes for Big Data", 2013.</a>
</p>
</li>
<li> <p><a href="http://gaussianprocess.org/gpml/">Carl Rasmussen, Chris Williams. Gaussian Processes For Machine Learning, 2006.</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p>For usage examples see e.g. <code>tfd_sample()</code>, <code>tfd_log_prob()</code>, <code>tfd_mean()</code>.
</p>
<p>Other distributions: 
<code>tfd_autoregressive()</code>,
<code>tfd_batch_reshape()</code>,
<code>tfd_bates()</code>,
<code>tfd_bernoulli()</code>,
<code>tfd_beta_binomial()</code>,
<code>tfd_beta()</code>,
<code>tfd_binomial()</code>,
<code>tfd_categorical()</code>,
<code>tfd_cauchy()</code>,
<code>tfd_chi2()</code>,
<code>tfd_chi()</code>,
<code>tfd_cholesky_lkj()</code>,
<code>tfd_continuous_bernoulli()</code>,
<code>tfd_deterministic()</code>,
<code>tfd_dirichlet_multinomial()</code>,
<code>tfd_dirichlet()</code>,
<code>tfd_empirical()</code>,
<code>tfd_exp_gamma()</code>,
<code>tfd_exp_inverse_gamma()</code>,
<code>tfd_exponential()</code>,
<code>tfd_gamma_gamma()</code>,
<code>tfd_gamma()</code>,
<code>tfd_gaussian_process_regression_model()</code>,
<code>tfd_gaussian_process()</code>,
<code>tfd_generalized_normal()</code>,
<code>tfd_geometric()</code>,
<code>tfd_gumbel()</code>,
<code>tfd_half_cauchy()</code>,
<code>tfd_half_normal()</code>,
<code>tfd_hidden_markov_model()</code>,
<code>tfd_horseshoe()</code>,
<code>tfd_independent()</code>,
<code>tfd_inverse_gamma()</code>,
<code>tfd_inverse_gaussian()</code>,
<code>tfd_johnson_s_u()</code>,
<code>tfd_joint_distribution_named_auto_batched()</code>,
<code>tfd_joint_distribution_named()</code>,
<code>tfd_joint_distribution_sequential_auto_batched()</code>,
<code>tfd_joint_distribution_sequential()</code>,
<code>tfd_kumaraswamy()</code>,
<code>tfd_laplace()</code>,
<code>tfd_linear_gaussian_state_space_model()</code>,
<code>tfd_lkj()</code>,
<code>tfd_log_logistic()</code>,
<code>tfd_log_normal()</code>,
<code>tfd_logistic()</code>,
<code>tfd_mixture_same_family()</code>,
<code>tfd_mixture()</code>,
<code>tfd_multinomial()</code>,
<code>tfd_multivariate_normal_diag_plus_low_rank()</code>,
<code>tfd_multivariate_normal_diag()</code>,
<code>tfd_multivariate_normal_full_covariance()</code>,
<code>tfd_multivariate_normal_linear_operator()</code>,
<code>tfd_multivariate_normal_tri_l()</code>,
<code>tfd_multivariate_student_t_linear_operator()</code>,
<code>tfd_negative_binomial()</code>,
<code>tfd_normal()</code>,
<code>tfd_one_hot_categorical()</code>,
<code>tfd_pareto()</code>,
<code>tfd_pixel_cnn()</code>,
<code>tfd_poisson_log_normal_quadrature_compound()</code>,
<code>tfd_poisson()</code>,
<code>tfd_power_spherical()</code>,
<code>tfd_probit_bernoulli()</code>,
<code>tfd_quantized()</code>,
<code>tfd_relaxed_bernoulli()</code>,
<code>tfd_relaxed_one_hot_categorical()</code>,
<code>tfd_sample_distribution()</code>,
<code>tfd_sinh_arcsinh()</code>,
<code>tfd_skellam()</code>,
<code>tfd_spherical_uniform()</code>,
<code>tfd_student_t_process()</code>,
<code>tfd_student_t()</code>,
<code>tfd_transformed_distribution()</code>,
<code>tfd_triangular()</code>,
<code>tfd_truncated_cauchy()</code>,
<code>tfd_truncated_normal()</code>,
<code>tfd_uniform()</code>,
<code>tfd_vector_diffeomixture()</code>,
<code>tfd_vector_exponential_diag()</code>,
<code>tfd_vector_exponential_linear_operator()</code>,
<code>tfd_vector_laplace_diag()</code>,
<code>tfd_vector_laplace_linear_operator()</code>,
<code>tfd_vector_sinh_arcsinh_diag()</code>,
<code>tfd_von_mises_fisher()</code>,
<code>tfd_von_mises()</code>,
<code>tfd_weibull()</code>,
<code>tfd_wishart_linear_operator()</code>,
<code>tfd_wishart_tri_l()</code>,
<code>tfd_wishart()</code>,
<code>tfd_zipf()</code>
</p>


</div>