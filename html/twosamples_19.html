<div class="container">

<table style="width: 100%;"><tr>
<td>wass_test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Wasserstein Distance Test</h2>

<h3>Description</h3>

<p>A two-sample test based on Wasserstein's distance (<code>wass_stat</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">wass_test(a, b, nboots = 2000, p = default.p, keep.boots = T, keep.samples = F)

wass_stat(a, b, power = def_power)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>a vector of numbers (or factors – see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a vector of numbers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboots</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>power to raise test stat to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.boots</code></td>
<td>
<p>Should the bootstrap values be saved in the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep.samples</code></td>
<td>
<p>Should the samples be saved in the output?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>power</code></td>
<td>
<p>power to raise test stat to</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Wasserstein test compares two ECDFs by looking at the Wasserstein distance between the two. This is of course the area between the two ECDFs. Formally – if E is the ECDF of sample 1 and F is the ECDF of sample 2, then </p>
<p style="text-align: center;"><code class="reqn">WASS = \int_{x \in R} |E(x)-F(x)|^p</code>
</p>
<p> across all x. The test p-value is calculated by randomly resampling two samples of the same size using the combined sample. Intuitively the Wasserstein test improves on CVM by allowing more extreme observations to carry more weight. At a higher level – CVM/AD/KS/etc only require ordinal data. Wasserstein gains its power because it takes advantages of the properties of interval data – i.e. the distances have some meaning.
</p>
<p>In the example plot below, the Wasserstein statistic is the shaded area between the ECDFs.
</p>
<p><img src="../help/figures/wass.png" alt="Example Wasserstein stat plot"></p>
<p>Inputs <code>a</code> and <code>b</code> can also be vectors of ordered (or unordered) factors, so long as both have the same levels and orderings. When possible, ordering factors will substantially increase power. <code>wass_test</code> will assume the distance between adjacent factors is 1.
</p>


<h3>Value</h3>

<p>Output is a length 2 Vector with test stat and p-value in that order. That vector has 3 attributes – the sample sizes of each sample, and the number of bootstraps performed for the pvalue.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>wass_test()</code>: Permutation based two sample test using Wasserstein metric
</p>
</li>
<li> <p><code>wass_stat()</code>: Permutation based two sample test using Wasserstein metric
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>dts_test()</code> for a more powerful test statistic. See <code>cvm_test()</code> for the predecessor to this test statistic. See <code>dts_test()</code> for the natural successor of this test statistic.
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(314159)
vec1 = rnorm(20)
vec2 = rnorm(20,0.5)
out = wass_test(vec1,vec2)
out
summary(out)
plot(out)

# Example using ordered factors
vec1 = factor(LETTERS[1:5],levels = LETTERS,ordered = TRUE)
vec2 = factor(LETTERS[c(1,2,2,2,4)],levels = LETTERS, ordered=TRUE)
wass_test(vec1,vec2)
</code></pre>


</div>