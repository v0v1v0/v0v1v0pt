<div class="container">

<table style="width: 100%;"><tr>
<td>TreeInfo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Information content of splits within a tree</h2>

<h3>Description</h3>

<p>Sum the entropy (<code>ClusteringEntropy()</code>), clustering information content
(<code>ClusteringInfo()</code>), or phylogenetic information content (<code>SplitwiseInfo()</code>)
across each split within a phylogenetic tree,
or the consensus of a set of phylogenetic trees (<code>ConsensusInfo()</code>).
This value will be greater than the total information
content of the tree where a tree contains multiple splits, as
these splits are not independent and thus contain mutual information that is
counted more than once
</p>


<h3>Usage</h3>

<pre><code class="language-R">SplitwiseInfo(x, p = NULL, sum = TRUE)

ClusteringEntropy(x, p = NULL, sum = TRUE)

ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'phylo'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'list'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'multiPhylo'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'Splits'
ClusteringEntropy(x, p = NULL, sum = TRUE)

## S3 method for class 'phylo'
ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'list'
ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'multiPhylo'
ClusteringInfo(x, p = NULL, sum = TRUE)

## S3 method for class 'Splits'
ClusteringInfo(x, p = NULL, sum = TRUE)

ConsensusInfo(trees, info = "phylogenetic", p = 0.5, check.tips = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A tree of class <code>phylo</code>, a list of trees, or a <code>multiPhylo</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>Scalar from 0.5 to 1 specifying minimum proportion of trees that
must contain a split for it to appear within the consensus.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sum</code></td>
<td>
<p>Logical: if <code>TRUE</code>, sum the information content of each split to
provide the total splitwise information content of the tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trees</code></td>
<td>
<p>List of <code>phylo</code> objects, optionally with class <code>multiPhylo</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>Abbreviation of "phylogenetic" or "clustering", specifying
the concept of information to employ.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check.tips</code></td>
<td>
<p>Logical specifying whether to renumber leaves such that
leaf numbering is consistent in all trees.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>SplitwiseInfo()</code>, <code>ClusteringInfo()</code> and <code>ClusteringEntropy()</code>
return the splitwise information content of the tree – or of each split
in turn, if <code>sum = FALSE</code> – in bits.
</p>
<p><code>ConsensusInfo()</code> returns the splitwise information content of the
majority rule consensus of <code>trees</code>.
</p>


<h3>Clustering information</h3>

<p>Clustering entropy addresses the question "how much information is contained
in the splits within a tree". Its approach is complementary to the
phylogenetic information content, used in <code>SplitwiseInfo()</code>.
In essence, it asks, given a split that subdivides the leaves of a tree into
two partitions, how easy it is to predict which partition a randomly drawn
leaf belongs to (Meila2007; Vinh et al. 2010).
</p>
<p>Formally, the entropy of a split <em>S</em> that divides <em>n</em> leaves into two
partitions of sizes <em>a</em> and <em>b</em> is given by
<em>H(S)</em> = - <em>a/n</em> log <em>a/n</em> - <em>b/n</em> log <em>b/n</em>.
</p>
<p>Base 2 logarithms are conventionally used, such that entropy is measured in
bits.
Entropy denotes the number of bits that are necessary to encode the outcome
of a random variable: here, the random variable is "what partition does a
randomly selected leaf belong to".
</p>
<p>An even split has an entropy of 1 bit: there is no better way of encoding
an outcome than using one bit to specify which of the two partitions the
randomly selected leaf belongs to.
</p>
<p>An uneven split has a lower entropy: membership of the larger partition is
common, and thus less surprising; it can be signified using fewer bits in an
optimal compression system.
</p>
<p>If this sounds confusing, let's consider creating a code to transmit the
cluster label of two randomly selected leaves.  One straightforward
option would be to use
</p>

<ul>
<li> <p><code>00</code> = "Both leaves belong to partition A"
</p>
</li>
<li> <p><code>11</code> = "Both leaves belong to partition B"
</p>
</li>
<li> <p><code>01</code> = 'First leaf in A, second in B'
</p>
</li>
<li> <p><code>10</code> = 'First leaf in B, second in A'
</p>
</li>
</ul>
<p>This code uses two bits to transmit the partition labels of two leaves.
If partitions A and B are equiprobable, this is the optimal code; our
entropy – the average information content required per leaf – is 1 bit.
</p>
<p>Alternatively, we could use the (suboptimal) code
</p>

<ul>
<li> <p><code>0</code> = "Both leaves belong to partition A"
</p>
</li>
<li> <p><code>111</code> = "Both leaves belong to partition B"
</p>
</li>
<li> <p><code>101</code> = 'First leaf in A, second in B'
</p>
</li>
<li> <p><code>110</code> = 'First leaf in B, second in A'
</p>
</li>
</ul>
<p>If A is much larger than B, then most pairs of leaves will require just
a single bit (code <code>0</code>). The additional bits when 1+ leaf belongs to B
may be required sufficiently rarely that the average message
requires fewer than two bits for two leaves, so the entropy is less than
1 bit.  (The optimal coding strategy will depend on the exact sizes
of A and B.)
</p>
<p>As entropy measures the bits required to transmit the cluster label of each
leaf (Vinh2010: p. 2840), the information content of
a split is its entropy multiplied by the number of leaves.
</p>


<h3>Phylogenetic information</h3>

<p>Phylogenetic information expresses the information content of a split
in terms of the probability that a uniformly selected tree will contain it
(Thorley et al. 1998).
</p>


<h3>Consensus information</h3>

<p>The information content of splits in a consensus tree is calculated by
interpreting support values (i.e. the proportion of trees containing
each split in the consensus) as probabilities that the true tree contains
that split, following Smith (2022).
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>Smith MR (2022).
“Using information theory to detect rogue taxa and improve consensus trees.”
<em>Systematic Biology</em>, syab099.
<a href="https://doi.org/10.1093/sysbio/syab099">doi:10.1093/sysbio/syab099</a>.<br><br> Thorley JL, Wilkinson M, Charleston M (1998).
“The information content of consensus trees.”
In Rizzi A, Vichi M, Bock H (eds.), <em>Advances in Data Science and Classification</em>, 91–98.
Springer, Berlin.
<a href="https://doi.org/10.1007/978-3-642-72253-0_12">doi:10.1007/978-3-642-72253-0_12</a>.<br><br> Vinh NX, Epps J, Bailey J (2010).
“Information theoretic measures for clusterings comparison: variants, properties, normalization and correction for chance.”
<em>Journal of Machine Learning Research</em>, <b>11</b>, 2837–2854.
<a href="https://doi.org/10.1145/1553374.1553511">doi:10.1145/1553374.1553511</a>.
</p>


<h3>See Also</h3>

<p>An introduction to the phylogenetic information content of a split is given
in <a href="https://ms609.github.io/TreeTools/reference/SplitInformation.html"><code>SplitInformation()</code></a>
and in a <a href="https://ms609.github.io/TreeDist/articles/information.html">package vignette</a>.
</p>
<p>Other information functions: 
<code>SplitEntropy()</code>,
<code>SplitSharedInformation()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("TreeTools", quietly = TRUE)

SplitwiseInfo(PectinateTree(8))
tree &lt;- read.tree(text = "(a, b, (c, (d, e, (f, g)0.8))0.9);")
SplitwiseInfo(tree)
SplitwiseInfo(tree, TRUE)

# Clustering entropy of an even split = 1 bit
ClusteringEntropy(TreeTools::as.Splits(c(rep(TRUE, 4), rep(FALSE, 4))))

# Clustering entropy of an uneven split &lt; 1 bit
ClusteringEntropy(TreeTools::as.Splits(c(rep(TRUE, 2), rep(FALSE, 6))))

tree1 &lt;- TreeTools::BalancedTree(8)
tree2 &lt;- TreeTools::PectinateTree(8)

ClusteringInfo(tree1)
ClusteringEntropy(tree1)
ClusteringInfo(list(one = tree1, two = tree2))

ClusteringInfo(tree1) + ClusteringInfo(tree2)
ClusteringEntropy(tree1) + ClusteringEntropy(tree2)
ClusteringInfoDistance(tree1, tree2)
MutualClusteringInfo(tree1, tree2)

# Clustering entropy with uncertain splits
tree &lt;- ape::read.tree(text = "(a, b, (c, (d, e, (f, g)0.8))0.9);")
ClusteringInfo(tree)
ClusteringInfo(tree, TRUE)

# Support-weighted information content of a consensus tree
set.seed(0)
trees &lt;- list(RandomTree(8), RootTree(BalancedTree(8), 1), PectinateTree(8))
cons &lt;- consensus(trees, p = 0.5)
p &lt;- SplitFrequency(cons, trees) / length(trees)
plot(cons)
LabelSplits(cons, signif(SplitwiseInfo(cons, p, sum = FALSE), 4))
ConsensusInfo(trees)
LabelSplits(cons, signif(ClusteringInfo(cons, p, sum = FALSE), 4))
ConsensusInfo(trees, "clustering")
</code></pre>


</div>