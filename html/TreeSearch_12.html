<div class="container">

<table style="width: 100%;"><tr>
<td>NNI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nearest neighbour interchange (NNI)</h2>

<h3>Description</h3>

<p><code>NNI()</code>performs a single iteration of the nearest-neighbour interchange
algorithm; <code>RootedNNI()</code> retains the position of the root.
These functions are based on equivalents in the <span class="pkg">phangorn</span> package.
<code>cNNI()</code> is an equivalent function coded in C, that runs much faster.
</p>


<h3>Usage</h3>

<pre><code class="language-R">NNI(tree, edgeToBreak = NULL)

cNNI(tree, edgeToBreak = NULL, whichSwitch = NULL)

NNISwap(parent, child, nTips = (length(parent)/2L) + 1L, edgeToBreak = NULL)

RootedNNI(tree, edgeToBreak = NULL)

RootedNNISwap(
  parent,
  child,
  nTips = (length(parent)/2L) + 1L,
  edgeToBreak = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>A tree of class <code>phylo</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edgeToBreak</code></td>
<td>
<p>In (<code>Rooted</code>)<code>NNI()</code>, an optional integer specifying the
index of an edge to bisect/prune, generated randomly if not specified.
If <code>-1</code>, a complete list of all trees one step from the input tree
will be returned.
In <code>cNNI()</code>, an integer from zero to <code>nEdge(tree) - nTip(tree) - 2</code>,
specifying which internal edge to break.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>whichSwitch</code></td>
<td>
<p>Integer from zero to one, specifying which way to re-build
the broken internal edge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parent</code></td>
<td>
<p>Integer vector corresponding to the first column of the edge
matrix of a tree of class <code>phylo</code>, i.e. <code>tree$edge[, 1]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>child</code></td>
<td>
<p>Integer vector corresponding to the second column of the edge
matrix of a tree of class <code>phylo</code>, i.e. <code>tree$edge[, 2]</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nTips</code></td>
<td>
<p>(optional) Number of tips.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Branch lengths are not supported.
</p>
<p>All nodes in a tree must be bifurcating; <code>ape::collapse.singles()</code> and
<code>ape::multi2di()</code> may help.
</p>


<h3>Value</h3>

<p>Returns a tree with class <code>phylo</code> (if <code>returnAll = FALSE</code>) or
a set of trees, with class <code>multiPhylo</code> (if <code>returnAll = TRUE</code>).
</p>
<p><code>cNNI()</code> returns a tree of class <code>phylo</code>, rooted on the same leaf,
on which the specified rearrangement has been conducted.
</p>
<p><code>NNISwap()</code> returns a list containing two elements, corresponding in
turn to the  rearranged parent and child parameters.
</p>
<p>a list containing two elements, corresponding in turn to the rearranged parent and child parameters
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>NNISwap()</code>: faster version that takes and returns parent and child parameters
</p>
</li>
<li> <p><code>RootedNNI()</code>: Perform <abbr><span class="acronym">NNI</span></abbr> rearrangement, retaining position of root
</p>
</li>
<li> <p><code>RootedNNISwap()</code>: faster version that takes and returns parent and child parameters
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p><a href="https://smithlabdurham.github.io/">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>The algorithm is summarized in
Felsenstein J (2004).
<em>Inferring phylogenies</em>.
Sinauer Associates, Sunderland, Massachusetts.
</p>


<h3>See Also</h3>

<p>Other tree rearrangement functions: 
<code>SPR()</code>,
<code>TBR()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">tree &lt;- TreeTools::BalancedTree(8)
# A random rearrangement
NNI(tree)
cNNI(tree)

# All trees one NNI rearrangement away
NNI(tree, edgeToBreak = -1)

# Manual random sampling
cNNI(tree, sample.int(14 - 8 - 1, 1), sample.int(2, 1))

# A specified rearrangement
cNNI(tree, 0, 0)

# If a tree may not be binary, collapse nodes with
tree &lt;- TreeTools::MakeTreeBinary(tree)

# If a tree may be improperly rooted, use
tree &lt;- TreeTools::RootTree(tree, 1)

# If a tree may exhibit unusual node ordering, this can be addressed with
tree &lt;- TreeTools::Preorder(tree)
</code></pre>


</div>