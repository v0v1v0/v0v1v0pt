<div class="container">

<table style="width: 100%;"><tr>
<td>tar_meta</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Read a project's metadata.</h2>

<h3>Description</h3>

<p>Read the metadata of all recorded targets and global objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tar_meta(
  names = NULL,
  fields = NULL,
  targets_only = FALSE,
  complete_only = FALSE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Optional, names of the targets. If supplied, <code>tar_meta()</code>
only returns metadata on these targets.
You can supply symbols
or <code>tidyselect</code> helpers like <code>any_of()</code> and <code>starts_with()</code>.
If <code>NULL</code>, all names are selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fields</code></td>
<td>
<p>Optional, names of columns/fields to select. If supplied,
<code>tar_meta()</code> only returns the selected metadata columns.
If <code>NULL</code>, all fields are selected.
You can supply symbols or <code>tidyselect</code> helpers
like <code>any_of()</code> and <code>starts_with()</code>.
The <code>name</code> column is always included first
no matter what you select. Choices:
</p>

<ul>
<li> <p><code>name</code>: name of the target or global object.
</p>
</li>
<li> <p><code>type</code>: type of the object: either <code>"function"</code> or <code>"object"</code>
for global objects, and <code>"stem"</code>, <code>"branch"</code>,
<code>"map"</code>, or <code>"cross"</code> for targets.
</p>
</li>
<li> <p><code>data</code>: hash of the output data.
</p>
</li>
<li> <p><code>command</code>: hash of the target's deparsed command.
</p>
</li>
<li> <p><code>depend</code>: hash of the immediate upstream dependencies of the target.
</p>
</li>
<li> <p><code>seed</code>: random number generator seed with which the target ran.
A target's random number generator seed
is a deterministic function of its name. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code>tar_seed_set()</code>
on the result to locally recreate the target's initial RNG state.
</p>
</li>
<li> <p><code>path</code>: A list column of paths to target data. Usually, each element
is a single path, but there could be multiple paths per target
for dynamic files (i.e. <code>tar_target(format = "file")</code>).
</p>
</li>
<li> <p><code>time</code>: <code>POSIXct</code> object with the time the target's data in storage
was last modified. If the target stores no local file,
then the time stamp corresponds to the time the target last
ran successfully. Only targets that run commands have time stamps:
just non-branching targets and individual dynamic branches.
Displayed in the current time zone of the system.
If there are multiple outputs for that target, as with file targets,
then the maximum time is shown.
</p>
</li>
<li> <p><code>size</code>: hash of the sum of all the bytes of the files at <code>path</code>.
</p>
</li>
<li> <p><code>bytes</code>: total file size in bytes of all files in <code>path</code>.
</p>
</li>
<li> <p><code>format</code>: character, one of the admissible data storage formats.
See the <code>format</code> argument in the <code>tar_target()</code> help file for details.
</p>
</li>
<li> <p><code>iteration</code>: character, either <code>"list"</code> or <code>"vector"</code>
to describe the iteration and aggregation mode of the target. See the
<code>iteration</code> argument in the <code>tar_target()</code> help file for details.
</p>
</li>
<li> <p><code>parent</code>: for branches, name of the parent pattern.
</p>
</li>
<li> <p><code>children</code>: list column, names of the children of targets that
have them. These include buds of stems and branches of patterns.
</p>
</li>
<li> <p><code>seconds</code>: number of seconds it took to run the target.
</p>
</li>
<li> <p><code>warnings</code>: character string of warning messages
from the last run of the target.
Only the first 50 warnings are available,
and only the first 2048 characters of the concatenated warning messages.
</p>
</li>
<li> <p><code>error</code>: character string of the error message if the target errored.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>targets_only</code></td>
<td>
<p>Logical, whether to just show information about targets
or also return metadata on functions and other global objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete_only</code></td>
<td>
<p>Logical, whether to return only complete rows
(no <code>NA</code> values).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">⁠_targets/⁠</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code>tar_config_get()</code> and <code>tar_config_set()</code> for details
about how to set the data store path persistently
for a project.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A metadata row only updates when the target completes.
<code>tar_progress()</code> shows information on targets that are running.
That is why the number of branches may disagree between <code>tar_meta()</code>
and <code>tar_progress()</code> for actively running pipelines.
</p>


<h3>Value</h3>

<p>A data frame with one row per target/object and the selected fields.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud metadata</h3>

<p>Metadata files help <code>targets</code>
read data objects and decide if the pipeline is up to date.
Usually, these metadata files live in files in the local
<code style="white-space: pre;">⁠_targets/meta/⁠</code> folder in your project, e.g. <code style="white-space: pre;">⁠_targets/meta/meta⁠</code>.
But in addition, if you set <code>repository</code> to anything other than
<code>"local"</code> in <code>tar_option_set()</code> in <code style="white-space: pre;">⁠_targets.R⁠</code>, then <code>tar_make()</code>
continuously uploads the metadata files to the bucket you specify
in <code>resources</code>. <code>tar_meta_delete()</code> will delete those files from the
cloud, and so will <code>tar_destroy()</code> if <code>destroy</code> is
set to either <code>"all"</code> or <code>"cloud"</code>.
</p>
<p>Other functions in <code>targets</code>, such as <code>tar_meta()</code>,
<code>tar_visnetwork()</code>, <code>tar_outdated()</code>, and <code>tar_invalidate()</code>,
use the local metadata only and ignore the copies on the cloud.
So if you are working on a different computer than the
one running the pipeline, you will need to download the cloud metadata
to your current machine using <code>tar_meta_download()</code>. Other functions
<code>tar_meta_upload()</code>, <code>tar_meta_sync()</code>, and <code>tar_meta_delete()</code>
also manage metadata across the cloud and the local file system.
</p>
<p>Remarks:
</p>

<ul>
<li>
<p> The <code>repository_meta</code> option in <code>tar_option_set()</code> is actually
what controls where the metadata lives in the cloud, but it defaults
to <code>repository</code>.
</p>
</li>
<li>
<p> Like <code>tar_make()</code>, <code>tar_make_future()</code> and <code>tar_make_clustermq()</code>
also continuously upload metadata files to the cloud bucket
specified in <code>resources</code>.
</p>
</li>
<li> <p><code>tar_meta_download()</code> and related functions need to run <code style="white-space: pre;">⁠_targets.R⁠</code>
to detect <code>tar_option_set()</code> options <code>repository_meta</code> and <code>resources</code>,
so please be aware of side effects that may happen running your
custom <code style="white-space: pre;">⁠_targets.R⁠</code> file.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other metadata: 
<code>tar_meta_delete()</code>,
<code>tar_meta_download()</code>,
<code>tar_meta_sync()</code>,
<code>tar_meta_upload()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  library(targets)
  library(tarchetypes)
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_meta()
tar_meta(starts_with("y_")) # see also any_of()
})
}
</code></pre>


</div>