<div class="container">

<table style="width: 100%;"><tr>
<td>add_epred_rvars</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Add <code>rvar</code>s for the linear predictor, posterior expectation, posterior predictive, or residuals of a model to a data frame</h2>

<h3>Description</h3>

<p>Given a data frame and a model, adds <code>rvar</code>s of draws from the linear/link-level predictor,
the expectation of the posterior predictive, or the posterior predictive to
the data frame.
</p>


<h3>Usage</h3>

<pre><code class="language-R">add_epred_rvars(
  newdata,
  object,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## Default S3 method:
epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  seed = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'stanreg'
epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'brmsfit'
epred_rvars(
  object,
  newdata,
  ...,
  value = ".epred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

add_linpred_rvars(
  newdata,
  object,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## Default S3 method:
linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  seed = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'stanreg'
linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

## S3 method for class 'brmsfit'
linpred_rvars(
  object,
  newdata,
  ...,
  value = ".linpred",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  dpar = NULL,
  columns_to = NULL
)

add_predicted_rvars(
  newdata,
  object,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)

predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)

## Default S3 method:
predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  seed = NULL,
  columns_to = NULL
)

## S3 method for class 'stanreg'
predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)

## S3 method for class 'brmsfit'
predicted_rvars(
  object,
  newdata,
  ...,
  value = ".prediction",
  ndraws = NULL,
  seed = NULL,
  re_formula = NULL,
  columns_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>Data frame to generate predictions from.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>A supported Bayesian model fit that can provide fits and predictions. Supported models
are listed in the second section of tidybayes-models: <em>Models Supporting Prediction</em>. While other
functions in this package (like <code>spread_rvars()</code>) support a wider range of models, to work with
<code>add_epred_rvars()</code>, <code>add_predicted_rvars()</code>, etc. a model must provide an interface for generating
predictions, thus more generic Bayesian modeling interfaces like <code>runjags</code> and <code>rstan</code> are not directly
supported for these functions (only wrappers around those languages that provide predictions, like <code>rstanarm</code>
and <code>brm</code>, are supported here).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to the underlying prediction method for the type of
model given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>The name of the output column:
</p>

<ul>
<li>
<p> for <code style="white-space: pre;">⁠[add_]epred_rvars()⁠</code>, defaults to <code>".epred"</code>.
</p>
</li>
<li>
<p> for <code style="white-space: pre;">⁠[add_]predicted_rvars()⁠</code>, defaults to <code>".prediction"</code>.
</p>
</li>
<li>
<p> for <code style="white-space: pre;">⁠[add_]linpred_rvars()⁠</code>, defaults to <code>".linpred"</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in the prediction.
If <code>NULL</code> (default), include all group-level effects; if <code>NA</code>, include no group-level effects.
Some model types (such as brms::brmsfit and rstanarm::stanreg-objects) allow
marginalizing over grouping factors by specifying new levels of a factor in <code>newdata</code>. In the case of
<code>brms::brm()</code>, you must also pass <code>allow_new_levels = TRUE</code> here to include new levels (see
<code>brms::posterior_predict()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dpar</code></td>
<td>
<p>For <code>add_epred_rvars()</code> and <code>add_linpred_rvars()</code>: Should distributional regression
parameters be included in the output? Valid only for models that support distributional regression parameters,
such as submodels for variance parameters (as in <code>brms::brm()</code>). If <code>TRUE</code>, distributional regression
parameters are included in the output as additional columns named after each parameter
(alternative names can be provided using a list or named vector, e.g. <code>c(sigma.hat = "sigma")</code>
would output the <code>"sigma"</code> parameter from a model as a column named <code>"sigma.hat"</code>).
If <code>NULL</code> or <code>FALSE</code> (the default), distributional regression parameters are not included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>columns_to</code></td>
<td>
<p>For <em>some</em> models, such as ordinal, multinomial, and multivariate models (notably, <code>brms::brm()</code> models but
<em>not</em> <code>rstanarm::stan_polr()</code> models), the column of predictions in the resulting data frame may include nested columns.
For example, for ordinal/multinomial models, these columns correspond to different categories of the response variable.
It may be more convenient to turn these nested columns into rows in the output; if this is desired, set
<code>columns_to</code> to a string representing the name of a column you would like the column names to be placed in.
In this case, a <code>.row</code> column will also be added to the result indicating which rows of the output
correspond to the same row in <code>newdata</code>.
See <code>vignette("tidy-posterior")</code> for examples of dealing with output ordinal models.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Consider a model like:
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{rcl}
y &amp;\sim&amp; \textrm{SomeDist}(\theta_1, \theta_2)\\
f_1(\theta_1) &amp;=&amp; \alpha_1 + \beta_1 x\\
f_2(\theta_2) &amp;=&amp; \alpha_2 + \beta_2 x
\end{array}</code>
</p>

<p>This model has:
</p>

<ul>
<li>
<p> an outcome variable, <code class="reqn">y</code>
</p>
</li>
<li>
<p> a response distribution, <code class="reqn">\textrm{SomeDist}</code>, having parameters <code class="reqn">\theta_1</code>
(with link function <code class="reqn">f_1</code>) and <code class="reqn">\theta_2</code> (with link function <code class="reqn">f_2</code>)
</p>
</li>
<li>
<p> a single predictor, <code class="reqn">x</code>
</p>
</li>
<li>
<p> coefficients <code class="reqn">\alpha_1</code>, <code class="reqn">\beta_1</code>, <code class="reqn">\alpha_2</code>, and <code class="reqn">\beta_2</code>
</p>
</li>
</ul>
<p>We fit this model to some observed data, <code class="reqn">y_\textrm{obs}</code>, and predictors,
<code class="reqn">x_\textrm{obs}</code>. Given new values of predictors, <code class="reqn">x_\textrm{new}</code>,
supplied in the data frame <code>newdata</code>, the functions for posterior draws are
defined as follows:
</p>

<ul>
<li> <p><code>add_predicted_rvars()</code> adds <code>rvar</code>s containing draws from the <strong>posterior predictive distribution</strong>,
<code class="reqn">p(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code>rstanarm::posterior_predict()</code> or <code>brms::posterior_predict()</code>.
</p>
</li>
<li> <p><code>add_epred_rvars()</code> adds <code>rvar</code>s containing draws from the <strong>expectation of the posterior predictive
distribution</strong>, aka the conditional expectation,
<code class="reqn">E(y_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>,
to the data.
It corresponds to <code>rstanarm::posterior_epred()</code> or <code>brms::posterior_epred()</code>.
Not all models support this function.
</p>
</li>
<li> <p><code>add_linpred_rvars()</code> adds <code>rvar</code>s containing draws from the <strong>posterior linear predictors</strong> to the data.
It corresponds to <code>rstanarm::posterior_linpred()</code> or <code>brms::posterior_linpred()</code>.
Depending on the model type and additional parameters passed, this may be:
</p>

<ul>
<li>
<p> The untransformed linear predictor, e.g.
<code class="reqn">p(f_1(\theta_1) | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(\alpha_1 + \beta_1 x_\textrm{new} | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_rvars(transform = FALSE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "link"</code> in <code>predict.glm()</code>.
</p>
</li>
<li>
<p> The inverse-link transformed linear predictor, e.g.
<code class="reqn">p(\theta_1 | x_\textrm{new}, y_\textrm{obs})</code> =
<code class="reqn">p(f_1^{-1}(\alpha_1 + \beta_1 x_\textrm{new}) | x_\textrm{new}, y_\textrm{obs})</code>.
This is returned by <code>add_linpred_rvars(transform = TRUE)</code> for <span class="pkg">brms</span> and <span class="pkg">rstanarm</span> models.
It is analogous to <code>type = "response"</code> in <code>predict.glm()</code>.
</p>
</li>
</ul>
<p><strong>NOTE:</strong> <code>add_linpred_rvars(transform = TRUE)</code> and <code>add_epred_rvars()</code> may be equivalent but
are not guaranteed to be. They are equivalent when the expectation of the response
distribution is equal to its first parameter, i.e. when <code class="reqn">E(y) = \theta_1</code>. Many
distributions have this property (e.g. Normal distributions, Bernoulli distributions),
but not all. If you want the expectation of the posterior predictive, it is best to
use <code>add_epred_rvars()</code> if available, and if not available, verify this property holds prior
to using <code>add_linpred_rvars()</code>.
</p>
</li>
</ul>
<p>The corresponding functions without <code>add_</code> as a prefix are alternate spellings
with the opposite order of the first two arguments: e.g. <code>add_predicted_rvars(newdata, object)</code>
versus <code>predicted_rvars(object, newdata)</code>. This facilitates use in data
processing pipelines that start either with a data frame or a model.
</p>
<p>Given equal choice between the two, the spellings prefixed with <code>add_</code>
are preferred.
</p>


<h3>Value</h3>

<p>A data frame (actually, a tibble) equal to the input <code>newdata</code> with
additional columns added containing <code>rvar</code>s representing the requested predictions or fits.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code>add_predicted_draws()</code> for the analogous functions that use a long-data-frame-of-draws
format instead of a data-frame-of-<code>rvar</code>s format. See <code>spread_rvars()</code> for manipulating posteriors directly.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

library(ggplot2)
library(dplyr)
library(posterior)
library(brms)
library(modelr)

theme_set(theme_light())

m_mpg = brm(mpg ~ hp * cyl, data = mtcars, family = lognormal(),
  # 1 chain / few iterations just so example runs quickly
  # do not use in practice
  chains = 1, iter = 500)

# Look at mean predictions for some cars (epred) and compare to
# the exponeniated mu parameter of the lognormal distribution (linpred).
# Notice how they are NOT the same. This is because exp(mu) for a
# lognormal distribution is equal to its median, not its mean.
mtcars %&gt;%
  select(hp, cyl, mpg) %&gt;%
  add_epred_rvars(m_mpg) %&gt;%
  add_linpred_rvars(m_mpg, value = "mu") %&gt;%
  mutate(expmu = exp(mu), .epred - expmu)

# plot intervals around conditional means (epred_rvars)
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  add_epred_rvars(m_mpg) %&gt;%
  ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
  stat_lineribbon(aes(dist = .epred), .width = c(.95, .8, .5), alpha = 1/3) +
  geom_point(aes(y = mpg), data = mtcars) +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Set2")

# plot posterior predictive intervals (predicted_rvars)
mtcars %&gt;%
  group_by(cyl) %&gt;%
  data_grid(hp = seq_range(hp, n = 101)) %&gt;%
  add_predicted_rvars(m_mpg) %&gt;%
  ggplot(aes(x = hp, color = ordered(cyl), fill = ordered(cyl))) +
  stat_lineribbon(aes(dist = .prediction), .width = c(.95, .8, .5), alpha = 1/3) +
  geom_point(aes(y = mpg), data = mtcars) +
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Set2")


## End(Not run)
</code></pre>


</div>