<div class="container">

<table style="width: 100%;"><tr>
<td>trafotree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Transformation Trees</h2>

<h3>Description</h3>

<p>Partitioned transformation models
</p>


<h3>Usage</h3>

<pre><code class="language-R">trafotree(object, parm = 1:length(coef(object)), reparm = NULL,
          intercept = c("none", "shift", "scale", "shift-scale"),
          min_update = length(coef(object)) * 2,
          mltargs = list(), ...)
## S3 method for class 'trafotree'
predict(object, newdata, K = 20, q = NULL,
    type = c("node", "coef", "trafo", "distribution", "survivor", "density",
             "logdensity", "hazard", "loghazard", "cumhazard", "quantile"),
    perm = NULL, ...)
## S3 method for class 'trafotree'
logLik(object, newdata, weights = NULL, perm = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an object of class <code>ctm</code> or <code>mlt</code> specifying the
abstract model to be partitioned. For <code>predict</code> and
<code>logLik</code>, <code>object</code> is an object of class <code>trafotree</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>parameters of <code>object</code> those corresponding score is
used for finding partitions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reparm</code></td>
<td>
<p>optional matrix of contrasts for reparameterisation of the scores.
<code>teststat = "quadratic"</code> is invariant to this operation
but <code>teststat = "max"</code> might be more powerful for
example when formulating an implicit into an explicit intercept term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intercept</code></td>
<td>
<p>add optional intercept parameters (constraint to zero) to
the model. It may make sense to restrict attention to
scores corresponding to those intercept parameters, the additional argument
<code>parm = NULL</code> is needed in this case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_update</code></td>
<td>
<p>number of observations necessary to refit the model in a
node. If less observations are available, the parameters from the parent
node will be reused.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mltargs</code></td>
<td>
<p>arguments to <code>mlt</code> for fitting the
transformation models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>an optional data frame of observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of grid points to generate (in the absence of <code>q</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q</code></td>
<td>
<p>quantiles at which to evaluate the model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of prediction or plot to generate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>an optional vector of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perm</code></td>
<td>
<p>a vector of integers specifying the variables to be permuted
prior before splitting (i.e., for computing permutation
variable importances). The default <code>NULL</code> doesn't alter the
data, see <code>fitted_node</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments to <code>ctree</code>, at least
<code>formula</code> and <code>data</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Conditional inference trees are used for partitioning likelihood-based transformation
models as described in Hothorn and Zeileis (2017). The method can be seen
in action in Hothorn (2018) and the corresponding code is available as
<code>demo("BMI")</code>. <code>demo("applications")</code> performs transformation
tree analyses for some standard benchmarking problems.
</p>


<h3>Value</h3>

<p>An object of class <code>trafotree</code> with corresponding <code>plot</code>, <code>logLik</code> and
<code>predict</code> methods.</p>


<h3>References</h3>

<p>Torsten Hothorn and Achim Zeileis (2021). Predictive Distribution 
Modelling Using Transformation Forests. 
<em>Journal of Computational and Graphical Statistics</em>,
<a href="https://doi.org/10.1080/10618600.2021.1872581">doi:10.1080/10618600.2021.1872581</a>.
</p>
<p>Torsten Hothorn (2018). Top-Down Transformation Choice. <em>Statistical
Modelling</em>, <b>3-4</b>, 274-298. <a href="https://doi.org/10.1177/1471082X17748081">doi:10.1177/1471082X17748081</a>
</p>
<p>Natalia Korepanova, Heidi Seibold, Verena Steffen and Torsten Hothorn
(2019).  Survival Forests under Test: Impact of the Proportional Hazards
Assumption on Prognostic and Predictive Forests for ALS Survival.
<a href="https://doi.org/10.1177/0962280219862586">doi:10.1177/0962280219862586</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
### Example: Stratified Medicine Using Partitioned Cox-Models
### A combination of &lt;DOI:10.1515/ijb-2015-0032&gt; and &lt;arXiv:1701.02110&gt;
### based on infrastructure in the mlt R add-on package described in
### https://cran.r-project.org/web/packages/mlt.docreg/vignettes/mlt.pdf

library("trtf")
library("survival")
### German Breast Cancer Study Group 2 data set
data("GBSG2", package = "TH.data")
GBSG2$y &lt;- with(GBSG2, Surv(time, cens))

### set-up Cox model with overall treatment effect in hormonal therapy
cmod &lt;- Coxph(y ~ horTh, data = GBSG2, support = c(100, 2000), order = 5)

### overall log-hazard ratio
coef(cmod)
### roughly the same as 
coef(coxph(y ~ horTh, data = GBSG2))

### partition the model, ie both the baseline hazard function AND the
### treatment effect
(part_cmod &lt;- trafotree(cmod, formula = y ~ horTh | age + menostat + tsize + 
    tgrade + pnodes + progrec + estrec, data = GBSG2))

### compare the log-likelihoods
logLik(cmod)
logLik(part_cmod)

### stronger effects in nodes 2 and 4 and no effect in node 5
coef(part_cmod)[, "horThyes"]

### plot the conditional survivor functions; blue is untreated
### and green is hormonal therapy
nd &lt;- data.frame(horTh = sort(unique(GBSG2$horTh)))
plot(part_cmod, newdata = nd, 
     tp_args = list(type = "survivor", col = c("cadetblue3", "chartreuse4")))

### same model, but with explicit intercept term and max-type statistic
### for _variable_ selection
(part_cmod_max &lt;- trafotree(cmod, formula = y ~ horTh | age + menostat + tsize + 
    tgrade + pnodes + progrec + estrec, data = GBSG2, intercept = "shift",
    control = ctree_control(teststat = "max")))
logLik(part_cmod_max)
coef(part_cmod_max)[, "horThyes"]

### the trees (and log-likelihoods are the same) but the
### p-values are sometimes much smaller in the latter tree
cbind(format.pval(info_node(node_party(part_cmod))$criterion["p.value",]),
      format.pval(info_node(node_party(part_cmod_max))$criterion["p.value",]))

</code></pre>


</div>