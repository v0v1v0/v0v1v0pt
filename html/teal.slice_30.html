<div class="container">

<table style="width: 100%;"><tr>
<td>FilterStates</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
<code>FilterStates</code> <code>R6</code> class</h2>

<h3>Description</h3>

<p>Abstract class that manages adding and removing <code>FilterState</code> objects
and builds a <em>subset expression</em>.
</p>
<p>A <code>FilterStates</code> object tracks all condition calls
(logical predicates that limit observations) associated with a given dataset
and composes them into a single reproducible <code>R</code> expression
that will assign a subset of the original data to a new variable.
This expression is hereafter referred to as <em>subset expression</em>.
</p>
<p>The <em>subset expression</em> is constructed differently for different
classes of the underlying data object and <code>FilterStates</code> sub-classes.
Currently implemented for <code>data.frame</code>, <code>matrix</code>,
<code>SummarizedExperiment</code>, and <code>MultiAssayExperiment</code>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FilterStates-new"><code>FilterStates$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-format"><code>FilterStates$format()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-get_call"><code>FilterStates$get_call()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-print"><code>FilterStates$print()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-remove_filter_state"><code>FilterStates$remove_filter_state()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-get_filter_state"><code>FilterStates$get_filter_state()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-set_filter_state"><code>FilterStates$set_filter_state()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-clear_filter_states"><code>FilterStates$clear_filter_states()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-ui_active"><code>FilterStates$ui_active()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-srv_active"><code>FilterStates$srv_active()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-ui_add"><code>FilterStates$ui_add()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-srv_add"><code>FilterStates$srv_add()</code></a>
</p>
</li>
<li> <p><a href="#method-FilterStates-clone"><code>FilterStates$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-FilterStates-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Initializes <code>FilterStates</code> object by setting
<code>dataname</code>, and <code>datalabel</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$new(
  data,
  data_reactive = function(sid = "") NULL,
  dataname,
  datalabel = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>(<code>data.frame</code> or <code>MultiAssayExperiment</code> or <code>SummarizedExperiment</code> or <code>matrix</code>)
the <code>R</code> object which <code>subset</code> function is applied on.</p>
</dd>
<dt><code>data_reactive</code></dt>
<dd>
<p>(<code style="white-space: pre;">⁠function(sid)⁠</code>)
should return an object of the same type as <code>data</code> object or <code>NULL</code>.
This object is needed for the <code>FilterState</code> counts being updated
on a change in filters. If function returns <code>NULL</code> then filtered counts are not shown.
Function has to have <code>sid</code> argument being a character.</p>
</dd>
<dt><code>dataname</code></dt>
<dd>
<p>(<code>character(1)</code>)
name of the dataset, used in the subset expression.
Passed to the function argument attached to this <code>FilterStates</code>.</p>
</dd>
<dt><code>datalabel</code></dt>
<dd>
<p>(<code>character(1)</code>) optional
text label.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Object of class <code>FilterStates</code>, invisibly.
</p>


<hr>
<a id="method-FilterStates-format"></a>



<h4>Method <code>format()</code>
</h4>

<p>Returns a formatted string representing this <code>FilterStates</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$format(show_all = FALSE, trim_lines = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>show_all</code></dt>
<dd>
<p>(<code>logical(1)</code>) passed to <code>format.teal_slices</code></p>
</dd>
<dt><code>trim_lines</code></dt>
<dd>
<p>(<code>logical(1)</code>) passed to <code>format.teal_slices</code></p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>character(1)</code> the formatted string
</p>


<hr>
<a id="method-FilterStates-get_call"></a>



<h4>Method <code>get_call()</code>
</h4>

<p>Filter call
</p>
<p>Builds <em>subset expression</em> from condition calls generated by <code>FilterState</code>.
The <code>lhs</code> of the expression is a <code>dataname_prefixed</code>, where word prefixed refers to
situation when call is evaluated on elements of the original data, for example <code>dataname[[x]]</code>.
By default <code>dataname_prefixed = dataname</code> and it's not alterable through class methods.
Customization of <code>private$dataname_prefixed</code> is done through inheriting classes.
</p>
<p>The <code>rhs</code> is a call to <code>private$fun</code> with following arguments:
</p>

<ul>
<li> <p><code>dataname_prefixed</code>
</p>
</li>
<li>
<p> list of logical expressions generated by <code>FilterState</code> objects
stored in <code>private$state_list</code>. Each logical predicate is combined with <code>&amp;</code> operator.
Variables in these logical expressions by default are not prefixed but this can be changed
by setting <code>private$extract_type</code> (change in the similar way as <code>dataname_prefixed</code>)
Possible call outputs depending on a custom fields/options:
</p>
</li>
</ul>
<div class="sourceCode"><pre># default
dataname &lt;- subset(dataname, col == "x")

# fun = dplyr::filter
dataname &lt;- dplyr::filter(dataname, col == "x")

# fun = MultiAssayExperiment::subsetByColData; extract_type = "list"
dataname &lt;- MultiAssayExperiment::subsetByColData(dataname, dataname$col == "x")

# teal_slice objects having `arg = "subset"` and `arg = "select"`
dataname &lt;- subset(dataname, subset = row_col == "x", select = col_col == "x")

# dataname = dataname[[element]]
dataname[[element]] &lt;- subset(dataname[[element]], subset = col == "x")
</pre></div>
<p>If no filters are applied, <code>NULL</code> is returned to avoid no-op calls such as <code>dataname &lt;- dataname</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$get_call(sid = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sid</code></dt>
<dd>
<p>(<code>character</code>)
when specified then method returns code containing condition calls (logical predicates) of
<code>FilterState</code> objects which <code>"sid"</code> attribute is different than this <code>sid</code> argument.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>call</code> or <code>NULL</code>
</p>


<hr>
<a id="method-FilterStates-print"></a>



<h4>Method <code>print()</code>
</h4>

<p>Prints this <code>FilterStates</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>additional arguments passed to <code>format</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-FilterStates-remove_filter_state"></a>



<h4>Method <code>remove_filter_state()</code>
</h4>

<p>Remove one or more <code>FilterState</code>s from the <code>state_list</code> along with their UI elements.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$remove_filter_state(state)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt>
<dd>
<p>(<code>teal_slices</code>)
specifying <code>FilterState</code> objects to remove;
<code>teal_slice</code>s may contain only <code>dataname</code> and <code>varname</code>, other elements are ignored</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>NULL</code>, invisibly.
</p>


<hr>
<a id="method-FilterStates-get_filter_state"></a>



<h4>Method <code>get_filter_state()</code>
</h4>

<p>Gets reactive values from active <code>FilterState</code> objects.
</p>
<p>Get active filter state from <code>FilterState</code> objects stored in <code>state_list</code>(s).
The output is a list compatible with input to <code>self$set_filter_state</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$get_filter_state()</pre></div>



<h5>Returns</h5>

<p>Object of class <code>teal_slices</code>.
</p>


<hr>
<a id="method-FilterStates-set_filter_state"></a>



<h4>Method <code>set_filter_state()</code>
</h4>

<p>Sets active <code>FilterState</code> objects.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$set_filter_state(state)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt>
<dd>
<p>(<code>teal_slices</code>)</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>Function that raises an error.
</p>


<hr>
<a id="method-FilterStates-clear_filter_states"></a>



<h4>Method <code>clear_filter_states()</code>
</h4>

<p>Remove all <code>FilterState</code> objects from this <code>FilterStates</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$clear_filter_states(force = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>force</code></dt>
<dd>
<p>(<code>logical(1)</code>)
flag specifying whether to include anchored filter states.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>NULL</code>, invisibly.
</p>


<hr>
<a id="method-FilterStates-ui_active"></a>



<h4>Method <code>ui_active()</code>
</h4>

<p><code>shiny</code> UI definition that stores <code>FilterState</code> UI elements.
Populated with elements created with <code>renderUI</code> in the module server.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$ui_active(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p>(<code>character(1)</code>)
<code>shiny</code> module instance id.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>shiny.tag</code>
</p>


<hr>
<a id="method-FilterStates-srv_active"></a>



<h4>Method <code>srv_active()</code>
</h4>

<p><code>shiny</code> server module.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$srv_active(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p>(<code>character(1)</code>)
<code>shiny</code> module instance id.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>NULL</code>.
</p>


<hr>
<a id="method-FilterStates-ui_add"></a>



<h4>Method <code>ui_add()</code>
</h4>

<p><code>shiny</code> UI module to add filter variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$ui_add(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p>(<code>character(1)</code>)
<code>shiny</code> module instance id.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>shiny.tag</code>
</p>


<hr>
<a id="method-FilterStates-srv_add"></a>



<h4>Method <code>srv_add()</code>
</h4>

<p><code>shiny</code> server module to add filter variable.
</p>
<p>This module controls available choices to select as a filter variable.
Once selected, a variable is removed from available choices.
Removing a filter variable adds it back to available choices.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$srv_add(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt>
<dd>
<p>(<code>character(1)</code>)
<code>shiny</code> module instance id.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p><code>NULL</code>.
</p>


<hr>
<a id="method-FilterStates-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FilterStates$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




</div>