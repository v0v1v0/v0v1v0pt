<div class="container">

<table style="width: 100%;"><tr>
<td>tdROC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimate time-dependent prediction accuracy measures, including the ROC, AUC, Brier score,
and survival difference, with right-censored survival data.</h2>

<h3>Description</h3>

<p>This is a core function of the ‘tdROC‘ package. It uses the nonparametric weights proposed by Li (Li et al., 2015)
to estimate a number of time-dependent prediction accuracy measures for right-censored survival outcomes,
including ROC curve, AUC, Brier score, and survival difference. For each measure, the variance can be estimated
through bootstrap resampling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tdROC(
  X,
  Y,
  delta,
  tau,
  span = 0.1,
  h = NULL,
  type = "uniform",
  n.grid = 1000,
  X.min = NULL,
  X.max = NULL,
  cut.off = NULL,
  nboot = 0,
  alpha = 0.05,
  epsilon = NULL,
  method = "both",
  output = "both"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>a numeric vector of risk score in the same length as <code>Y</code> and <code>delta</code>, such as biomarker or predicted probability. A higher value indicates higher risk of the event.
The calibration results (Brier score, survival difference) are applicable only when the risk score has the predicted probability interpretation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Y</code></td>
<td>
<p>a numeric vector of time to event in the same length as <code>X</code> and <code>delta</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>a vector of binary indicator of event (1) or censoring (0) in the same length as <code>X</code> and <code>Y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>a scalar, the prediction horizon at which the prediction is evaluated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>span</code></td>
<td>
<p>a numeric value, the proportion of neighbour observations used in nearest neighbor method, default to 0.1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>a numeric value, the bandwidth of kernel weights, the defualt is <code>NULL</code>. If not specified, the function will use the value of
<code>span</code> to calculate kernel weights. In case both <code>span</code> and <code>h</code> are specified, the function will use <code>h</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>a character value, indicating the type of kernel function used to calculate kernel weights. The default is <code>"uniform"</code> kernel. Other options are <code>"Epanechnikov"</code> and <code>"normal"</code>.
It will only be used when the bandwidth <code>h</code> is specified.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.grid</code></td>
<td>
<p>a positive integer, the number of grid points used when calculating the ROC curve. The default is <code>1000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.min</code></td>
<td>
<p>the lower boundary of grid cut-off points for biomarker <code>X</code>. The default is the minimum of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>X.max</code></td>
<td>
<p>the upper boundary of grid cut-off points for biomarker <code>X</code>. The default is the maximum of <code>X</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut.off</code></td>
<td>
<p>a vector of <code>X</code> cut-off values at which sensitivity and specificity will be calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nboot</code></td>
<td>
<p>the number of bootstrap replications to be used for variance estimation. The default is <code>nboot = 0</code>, corresponding to no variance estimation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>It is (1 - level of confidence interval)/2, default is <code>0.05</code>. It is used only when <code>nboot &gt; 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>The precision parameter used in an approximation to the weight calculation when the sample size is large. If a weight corresponding to a specific risk score is already calculated,
then the weights corresponding to adjacent risk scores, within the distance specified by epsilon, will be the same under the approximation. This approximation avoids repeated
calculation of weights that are almost the same, and hence increases the speed of computation in this situation. The default is NULL, which means no approximation is used. A higher
value indicates less precision.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>It is used to specify which method you would like to use to estimate AUC, default to <code>"both"</code>. Other options are <code>"integral"</code> and <code>"empirical"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>It is used to specify which kind of output you want, default to <code>"both"</code>. Other options are <code>"AUC"</code>, including AUC, sensitivity, and specificity are included,
and <code>"calibration"</code> including Brier Score and survival difference.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function takes the risk score value <code>X</code>, the time-to-event data <code>Y</code> and censoring indicator <code>delta</code> as input to estimate
a number of time-dependent prediction accuracy measures for right-censored survival outcomes, including ROC curve, AUC, Brier score, and survival difference.
The confidence intervals of above quantities will be estimated by bootstrap.
</p>
<p>This function offer two options to estimate AUC. The first one make use of estimated sensitivity and specificity to calculate the AUC via trapezoidal integration
by setting a series of cutoff point. The output will also include corresponding sensitivity and specificity for our plot function. The other one estimate AUC by the empirical estimator
of the proportion of concordance pairs with proposed weight estimator (Li et al, 2015). These two methods will generate quite similar estimates. The option can be set by argument <code>method</code>.
</p>
<p>We also include Brier Score and survival difference to evaluate the calibration metrics. Their definitions are included below.
They can be estimated with the proposed conditional probability weight (Wu and Li, 2018).
Both of them are measures to assess the accuracy of probabilistic predictions <code>X</code>. The calibration result makes sense only
when the risk score <code>X</code> is a predicted probability, and should be ignored otherwise.
</p>
<p style="text-align: center;"><code class="reqn">
 \text{Brier Score} = E{[1(T \le \tau, \delta = 1) - X]^2}
 </code>
</p>

<p style="text-align: center;"><code class="reqn">
 \text{Survival difference} = E[1(T \le \tau, \delta = 1) - X]
 </code>
</p>

<p>As mentioned in arguments, we introduced a small precision parameter <code>epsilon</code> to speed up the computation when the sample size is large.
For each subject with a risk score, <code class="reqn">X_i</code>, we assess whether there exists a previously processed grid point, <code class="reqn">X_{grid,m}</code> where <code class="reqn">1\le m \le j</code>,
within the proximity of <code class="reqn">X_i</code> such that <code class="reqn">|X_i - X_{grid,m}| &lt; \epsilon</code>. In the absence of such a point, we designate <code class="reqn">X_i</code> as a new grid point,
<code class="reqn">X_{grid,j+1}</code>, and store the corresponding <code>survfit</code> object for subsequent weight estimation and mark it as a processed grid point. Conversely,
if a previously processed grid point is found, we directly utilize the stored <code>survfit</code> object associated with it for weight calculation.
Given that the most time-consuming step in our estimation process is the <code>survfit</code> computation, this method significantly reduces computing time
without incurring notable bias especially when dealing with large sample sizes.
</p>


<h3>Value</h3>

<p>Returns a list of the following items:
</p>
<p><code>main_res:</code> a list of <code>AUC.integral</code> estimated by trapezoidal integration, <code>AUC.empirical</code> estimated by empirical estimator of the proportion of concordance pairs.
and a data frame <code>ROC</code> with dimension <code>(2+n.grid) x 3</code> with columns <code>cut.off</code>, <code>sens</code>, and <code>spec</code>.
</p>
<p><code>calibration_res:</code> brier score and survival difference estimated based on the formula similar to Wu and Li (2018). When the risk score <code>X</code>
is a biomarker value instead of a predicted cumulative incidence probability, the brier score and survival difference cannot be calculated. In this case, please disregard the calibration results.
</p>
<p><code>boot_res:</code> a list of bootstrap results, including <code>bAUC</code>, <code>bAUC2</code>, <code>bBS</code>, <code>bSurvDiff</code>, <code>bROC</code>.
For <code>bAUC</code>, <code>bAUC2</code>, <code>bBS</code>, <code>bSurvDiff</code>, each one is a list including corresponding mean, standard deviation, and confidence interval.
<code>bROC</code> is a data frame with colomns <code>sens.mean</code>, <code>sens.sd</code>, <code>sens.lower</code>, <code>sens.upper</code>, <code>spec.mean</code>, <code>spec.sd</code>, <code>spec.lower</code>, <code>spec.upper</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(survival)
data(mayo)
dat &lt;- mayo[, c("time", "censor", "mayoscore5")]
fm &lt;- tdROC(
  X = dat$mayoscore5, Y = dat$time, delta = dat$censor,
  tau = 365 * 6, span = 0.1, nboot = 0, alpha = 0.05,
  n.grid = 1000, cut.off = 5:9
)
# In the following example, We use biomarker mayoscore5 to estimate predicted probability
# tipycally a monotone transformation function such as expit() is used to transform biomarker
# with range out of range into estimated probability between 0 and 1
expit &lt;- function(x){ 1/(1+exp(-x)) }

tdROC(
  X = expit(dat$mayoscore5), Y = dat$time, delta = dat$censor,
  tau = 365 * 6, span = 0.1, nboot = 0, alpha = 0.05,
  n.grid = 1000, cut.off = 5:9
)

tdROC(
  X = expit(dat$mayoscore5), Y = dat$time, delta = dat$censor,
  tau = 365 * 6, span = 0.1, nboot = 0, alpha = 0.05,
  n.grid = 1000, cut.off = 5:9, epsilon = 0.05
)


</code></pre>


</div>