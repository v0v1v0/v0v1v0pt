<div class="container">

<table style="width: 100%;"><tr>
<td>tableschema.r-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Table Schema Package</h2>

<h3>Description</h3>

<p>Table class for working with data and schema
</p>


<h3>Introduction</h3>

<p>Table Schema is a simple language- and implementation-agnostic way to declare a schema for tabular data. 
Table Schema is well suited for use cases around handling and validating tabular data in text formats 
such as CSV, but its utility extends well beyond this core usage, towards a range of applications 
where data benefits from a portable schema format.
</p>


<h3>Concepts</h3>

<p>#
</p>


<h3>Tabular data</h3>

<p>Tabular data consists of a set of rows. Each row has a set of fields (columns). 
We usually expect that each row has the same set of fields and thus we can talk about 
the fields for the table as a whole.
</p>
<p>In case of tables in spreadsheets or CSV files we often interpret the first row as a header row, 
giving the names of the fields. By contrast, in other situations, e.g. tables in SQL databases, 
the field names are explicitly designated.
</p>


<h3>Physical and logical representation</h3>

<p>In order to talk about the representation and processing of tabular data from text-based sources, 
it is useful to introduce the concepts of the <em>physical</em> and the <em>logical</em> representation of data.
</p>
<p>The <em>physical representation</em> of data refers to the representation of data as text on disk, 
for example, in a CSV or JSON file. This representation may have some type information 
(JSON, where the primitive types that JSON supports can be used) or not 
(CSV, where all data is represented in string form).
</p>
<p>The <em>logical representation</em> of data refers to the "ideal" representation of the data 
in terms of primitive types, data structures, and relations, all as defined by the specification. 
We could say that the specification is about the logical representation of data, 
as well as about ways in which to handle conversion of a physical representation to a logical one.
</p>
<p>In this document, we'll explicitly refer to either the <em>physical</em> or <em>logical</em> representation 
in places where it prevents ambiguity for those engaging with the specification, especially implementors.
</p>
<p>For example, <code>constraints</code> should be tested on the logical representation of data, 
whereas a property like <code>missingValues</code> applies to the physical representation of the data.
</p>


<h3>Descriptor</h3>

<p>A Table Schema is represented by a descriptor. The descriptor <code>MUST</code> be a JSON <code>object</code> 
(JSON is defined in <a href="https://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>).
</p>
<p>It <code>MUST</code> contain a property <code>fields</code>. <code>fields</code> <code>MUST</code> be an array/list where each entry 
in the array/list is a field descriptor (as defined below). The order of elements in <code>fields</code> array/list 
<code>MUST</code> be the order of fields in the CSV file. The number of elements in <code>fields</code> array/list 
<code>SHOULD</code> be exactly the same as the number of fields in the CSV file.
</p>
<p>The descriptor <code>MAY</code> have the additional properties set out below and <code>MAY</code> contain 
any number of other properties (not defined in this specification).
</p>


<h3>Field Descriptors</h3>

<p>See <code>Field</code> Class
</p>


<h3>Types and Formats</h3>

<p>See <code>Types</code> Class
</p>


<h3>Constraints</h3>

<p>See <code>Constraints</code> Class
</p>


<h3>Other Properties</h3>

<p>In additional to field descriptors, there are the following "table level" properties.
</p>


<h3>Missing Values</h3>

<p>Many datasets arrive with missing data values, either because a value was not collected or 
it never existed. Missing values may be indicated simply by the value being empty in other 
cases a special value may have been used e.g. -, NaN, 0, -9999 etc.
</p>
<p><code>missingValues</code> dictates which string values should be treated as null values. 
This conversion to null is done before any other attempted type-specific string conversion. 
The default value <code>list("")</code> means that empty strings will be converted to null before any other 
processing takes place. Providing the empty list means that no conversion to null will 
be done, on any value.
</p>
<p><code>missingValues</code> <code>MUST</code> be a list where each entry is a string.
</p>
<p><strong>Why strings</strong>: <code>missingValues</code> are strings rather than being the data type of the particular field. 
This allows for comparison prior to casting and for fields to have missing value which are not 
of their type, for example a <code>number</code> field to have missing values indicated by -.
</p>
<p>Examples:
</p>

<ul>
<li>
<p>missingValues = list("")
</p>
</li>
<li>
<p>missingValues = list("-")
</p>
</li>
<li>
<p>missingValues = list("NaN", "-")
</p>
</li>
</ul>
<h3>Primary Key</h3>

<p>A primary key is a field or set of fields that uniquely identifies each row in the table.
</p>
<p>The <code>primaryKey</code> entry in the schema <code>object</code> is optional. If present it specifies the primary key for this table.
</p>
<p>The <code>primaryKey</code>, if present, <code>MUST</code> be:
</p>

<ul>
<li>
<p>Either: an array of strings with each string corresponding to one of the field <code>name</code> values in the <code>fields</code> array 
(denoting that the primary key is made up of those fields). It is acceptable to have an array with a single value 
(indicating just one field in the primary key). Strictly, order of values in the array does not matter. 
However, it is RECOMMENDED that one follow the order the fields in the <code>fields</code> has as client applications may 
utitlize the order of the primary key list (e.g. in concatenating values together).

</p>
</li>
<li>
<p>Or: a single string corresponding to one of the field <code>name</code> values in the <code>fields</code> array/list 
(indicating that this field is the primary key). Note that this version corresponds to the array form 
with a single value (and can be seen as simply a more convenient way of specifying a single field primary key).

</p>
</li>
</ul>
<h3>Foreign Keys</h3>

<p>A foreign key is a reference where values in a field (or fields) on the table ('resource' in data package terminology) 
described by this Table Schema connect to values a field (or fields) on this or a separate table (resource). 
They are directly modelled on the concept of foreign keys in SQL.
</p>
<p>The <code>foreignKeys</code> property, if present, <code>MUST</code> be a list Each entry in the array must be a <code>foreignKey</code>. 
A <code>foreignKey</code> <code>MUST</code> be a object and <code>MUST</code> have the following properties:
</p>

<ul>
<li>
<p><code>fields</code> - <code>fields</code> is a string or array specifying the field or fields on this resource that form the source part 
of the foreign key. The structure of the string or array is as per <code>primaryKey</code> above.
</p>
</li>
<li>
<p><code>reference</code> - <code>reference</code> <code>MUST</code> be a object. The object
</p>

<ul>
<li>
<p><code>MUST</code> have a property <code>resource</code> which is the name of the resource within the current data package 
(i.e. the data package within which this Table Schema is located). For self-referencing foreign keys, 
i.e. references between fields in this Table Schema, the value of <code>resource</code> <code>MUST</code> be <code>""</code> (i.e. the empty string).
</p>
</li>
<li>
<p><code>MUST</code> have a property <code>fields</code> which is a string if the outer <code>fields</code> is a string, 
else an array of the same length as the outer <code>fields</code>, describing the field (or fields) references 
on the destination resource. The structure of the string or array is as per <code>primaryKey</code> above.
</p>
</li>
</ul>
</li>
</ul>
<p><strong>Comment</strong>: Foreign Keys create links between one Table Schema and another Table Schema, 
and implicitly between the data tables described by those Table Schemas. If the foreign key is referring to 
another Table Schema how is that other Table Schema discovered? The answer is that a Table Schema will 
usually be embedded inside some larger descriptor for a dataset, in particular as the schema for a resource 
in the resources array of a hrefhttp://frictionlessdata.io/specs/data-package/Data Package. 
It is the use of Table Schema in this way that permits a meaningful use of a non-empty <code>resource</code> 
property on the foreign key.
</p>


<h3>Details</h3>

<p><a href="https://CRAN.R-project.org/package=jsonlite">Jsolite package</a> is internally used to convert json data to list objects. The input parameters of functions could be json strings, 
files or lists and the outputs are in list format to easily further process your data in R environment and exported as desired. 
More details about handling json you can see jsonlite documentation or vignettes <a href="https://CRAN.R-project.org/package=jsonlite">here</a>.
</p>
<p><a href="https://CRAN.R-project.org/package=future">Future package</a> is also used to load and create Table and Schema classes asynchronously. 
To retrieve the actual result of the loaded Table or Schema you have to use <code>value</code> function to the variable you stored the loaded Table/Schema. 
More details about future package and sequential and parallel processing you can find <a href="https://CRAN.R-project.org/package=future">here</a>.
</p>
<p>Examples section of each function show how to use <code>jsonlite</code> and <code>future</code> packages with <code>tableschema.r</code>. 
</p>
<p>Term array refers to json arrays which if converted in R will be <code>list objects</code>.
</p>


<h3>Language</h3>

<p>The key words <code>MUST</code>, <code>MUST NOT</code>, <code>REQUIRED</code>, <code>SHALL</code>, <code>SHALL NOT</code>, 
<code>SHOULD</code>, <code>SHOULD NOT</code>, <code>RECOMMENDED</code>, <code>MAY</code>, and <code>OPTIONAL</code> 
in this package documents are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>


<h3>See Also</h3>

<p><a href="https://specs.frictionlessdata.io//table-schema/">Table Schema Specifications</a>
</p>


</div>