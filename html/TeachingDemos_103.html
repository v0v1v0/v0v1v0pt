<div class="container">

<table style="width: 100%;"><tr>
<td>slider</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>slider / button control widgets</h2>

<h3>Description</h3>

<p><code>slider</code> constructs a Tcl/Tk-widget with sliders and buttons
automated calculation and plotting. For example slider allows complete
all axes rotation of objects in a plot.
</p>


<h3>Usage</h3>

<pre><code class="language-R">slider(sl.functions, sl.names, sl.mins, sl.maxs, sl.deltas, sl.defaults,
but.functions, but.names, no, set.no.value, obj.name, obj.value,
reset.function, title) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sl.functions</code></td>
<td>
<p>set of functions or function connected to the slider(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sl.names</code></td>
<td>
<p>labels of the sliders</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sl.mins</code></td>
<td>
<p>minimum values of the sliders' ranges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sl.maxs</code></td>
<td>
<p>maximum values of the sliders' ranges</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sl.deltas</code></td>
<td>
<p>change of step per click</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sl.defaults</code></td>
<td>
<p>default values for the sliders</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>but.functions</code></td>
<td>
<p>function or list of functions
that are assigned to the button(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>but.names</code></td>
<td>
<p>labels of the buttons</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no</code></td>
<td>
<p><code>slider(no=i)</code> requests slider <code>i</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set.no.value</code></td>
<td>
<p><code>slider(set.no.value=c(i,val))</code> sets slider <code>i</code> to value <code>val</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj.name</code></td>
<td>
<p><code>slider(obj.name=name)</code> requests the value of
variable <code>name</code> from environment <code>slider.env</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj.value</code></td>
<td>
<p><code>slider(obj.name=name,obj.value=value)</code> assigns <code>value</code>
to variable <code>name</code> in environment <code>slider.env</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reset.function</code></td>
<td>
<p>function that comprises the commands of the
<code>reset.button</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>title</code></td>
<td>
<p>title of the control window</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>With slider you can:
a. define (multiple) sliders and buttons,
b. request or set slider values, and
c. request or set variables in the environment <code>slider.env</code>.
Slider function management takes place in the
environment <code>slider.env</code>. If <code>slider.env</code>
is not found it is generated.
</p>
<p>Definition: ... of sliders: First of all you have to define sliders, buttons and the attributes of them.
Sliders are established by six arguments:
<code>sl.functions, sl.names, sl.minima, sl.maxima,sl.deltas</code>, and <code>sl.defaults</code>.
The first argument,
<code>sl.functions</code>, is either a list of functions or a single function that
entails the commands for the sliders.
If there are three sliders and slider 2 is moved with the mouse the function stored in
<code>sl.functions[[2]]</code> (or in case of one function for all sliders the function <code>sl.functions</code>)
is called.
</p>
<p>Definition:  ... of buttons: Buttons are defined by a vector of labels <code>but.names</code> and a list of functions:
<code>but.functions</code>. If button <code>i</code> is pressed the function stored in <code>but.functions[[i]]</code> is called.
</p>
<p>Requesting: ... a slider:
<code>slider(no=1)</code> returns the actual value of slider 1,
<code>slider(no=2)</code> returns the value of slider 2, etc.
You are allowed to include expressions of the type
<code>slider(no=i)</code> in functions describing the effect of
sliders or buttons.
</p>
<p>Setting: ... a slider: <code>slider(set.no.value=c(2,333))</code> sets slider <code>2</code> to value 333.
<code>slider(set.no.value=c(i,value))</code> can be included in the functions
defining the effects of moving sliders or pushing buttons.
</p>
<p>Variables: ... of the environment <code>slider.env</code>: Sometimes information
has to be trransferred back and forth between functions defining the effects of sliders and buttons.
Imagine for example two sliders: one to control <code>p</code> and another one to control <code>q</code>,
but they should satisfy: <code>p+q=1</code>. Consequently, you have to correct the value of the first slider
after the second one was moved. To prevent the creation of  global
variables store them in the environment <code>slider.env</code>.
Use <code>slider(obj.name="p.save",obj.value=1-slider(no=2))</code>
to assign value  <code>1-slider(no=2)</code> to the variable <code>p.save</code> .
<code>slider(obj.name=p.save)</code> returns the value of variable <code>p.save</code>.
</p>


<h3>Value</h3>

<p>Using <code>slider</code> in definition mode <code>slider</code> returns the value of new created the top level widget.
<code>slider(no=i)</code> returns the actual value of slider <code>i</code>.
<code>slider(obj.name=name)</code> returns the value of variable <code>name</code> in environment <code>slider.env</code>.
</p>


<h3>Note</h3>

<p>You can move the slider in 3 different ways:  You can left click
and drag the slider itself, you can left click in the trough to either
side of the slider and the slider will move 1 unit in the direction
you clicked, or you can right click in the trough and the slider will
jump to the location you clicked at.
</p>
<p>This function may not stay in this package (consider it
semi-depricated), the original of the slider function is in the relax
package and can be used from there.  In TeachingDemos the
<code>tkexamp</code>
function is taking the place of <code>slider</code> and gives a possibly
more general approach.
</p>


<h3>Author(s)</h3>

<p>Hans Peter Wolf</p>


<h3>See Also</h3>

<p><code>tkexamp</code>, <code>sliderv</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
# example 1, sliders only
## Not run: 
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm&lt;-function(){
 refresh.code&lt;-function(...){
   mu&lt;-slider(no=1); sd&lt;-slider(no=1); n&lt;-slider(no=3)
   x&lt;-rnorm(n,mu,sd)
   plot(x)
 }
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(+10,50,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20))
}
plot.sample.norm()

## End(Not run)

# example 2, sliders and buttons
## Not run: 
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm.2&lt;-function(){
 refresh.code&lt;-function(...){
   mu&lt;-slider(no=1); sd&lt;-slider(no=2); n&lt;-slider(no=3)
   type=  slider(obj.name="type")
   x&lt;-rnorm(n,mu,sd)
   plot(seq(x),x,ylim=c(-20,20),type=type)
 }
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(10,10,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20),
       but.functions=list(
              function(...){slider(obj.name="type",obj.value="l");refresh.code()},
              function(...){slider(obj.name="type",obj.value="p");refresh.code()},
              function(...){slider(obj.name="type",obj.value="b");refresh.code()}
       ),
       but.names=c("lines","points","both"))
  slider(obj.name="type",obj.value="l")
}
plot.sample.norm.2()

## End(Not run)

# example 3, dependent sliders
## Not run: 
## This example cannot be run by examples() but should work in an interactive R session
print.of.p.and.q&lt;-function(){
 refresh.code&lt;-function(...){
   p.old&lt;-slider(obj.name="p.old")
   p&lt;-slider(no=1); if(abs(p-p.old)&gt;0.001) {slider(set.no.value=c(2,1-p))}
   q&lt;-slider(no=2); if(abs(q-(1-p))&gt;0.001) {slider(set.no.value=c(1,1-q))}
   slider(obj.name="p.old",obj.value=p)
   cat("p=",p,"q=",1-p,"\n")
 }
 slider(refresh.code,sl.names=c("value of p","value of q"),
       sl.mins=c(0,0),sl.maxs=c(1,1),sl.deltas=c(.01,.01),sl.defaults=c(.2,.8))
 slider(obj.name="p.old",obj.value=slider(no=1))
}
print.of.p.and.q()

## End(Not run)

# example 4, rotating a surface
## Not run: 
## This example cannot be run by examples() but should work in an interactive R session
R.veil.in.the.wind&lt;-function(){
  # Mark Hempelmann / Peter Wolf
  par(bg="blue4", col="white", col.main="white",
      col.sub="white", font.sub=2, fg="white") # set colors and fonts
  samp  &lt;- function(N,D) N*(1/4+D)/(1/4+D*N)
  z&lt;-outer(seq(1, 800, by=10), seq(.0025, 0.2, .0025)^2/1.96^2, samp) # create 3d matrix
  h&lt;-100
  z[10:70,20:25]&lt;-z[10:70,20:25]+h; z[65:70,26:45]&lt;-z[65:70,26:45]+h
  z[64:45,43:48]&lt;-z[64:45,43:48]+h; z[44:39,26:45]&lt;-z[44:39,26:45]+h
  x&lt;-26:59; y&lt;-11:38; zz&lt;-outer(x,y,"+"); zz&lt;-zz*(65&lt;zz)*(zz&lt;73)
  cz&lt;-10+col(zz)[zz&gt;0];rz&lt;-25+row(zz)[zz&gt;0]; z[cbind(cz,rz)]&lt;-z[cbind(cz,rz)]+h
  refresh.code&lt;-function(...){
    theta&lt;-slider(no=1); phi&lt;-slider(no=2)
    persp(x=seq(1,800,by=10),y=seq(.0025,0.2,.0025),z=z,theta=theta,phi=phi,
          scale=T, shade=.9, box=F, ltheta = 45,
          lphi = 45, col="aquamarine", border="NA",ticktype="detailed")
  }
  slider(refresh.code, c("theta", "phi"), c(0, 0),c(360, 360),c(.2, .2),c(85, 270)  )
}
R.veil.in.the.wind()

## End(Not run)



</code></pre>


</div>