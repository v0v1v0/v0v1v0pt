<div class="container">

<table style="width: 100%;"><tr>
<td>trust.optim</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Nonlinear optimizers using trust regions.</h2>

<h3>Description</h3>

<p>Run nonlinear minimizer using trust region algorithm with conjugate
gradient search directions and quasi-Hessian updates.
</p>


<h3>Usage</h3>

<pre><code class="language-R">trust.optim(
  x,
  fn,
  gr,
  hs = NULL,
  method = c("SR1", "BFGS", "Sparse"),
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A numeric vector of starting values for the optimizer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>An R function that takes <code>x</code> as its first argument.
Returns the value of the objective function at <code>x</code>.
Note that the optimizer will <em>minimize</em> <code>fn</code> (see
function.scale.factor under control)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gr</code></td>
<td>
<p>An R function that takes x as its first argument.  Returns a
numeric vector that is the gradient of <code>fn</code> at <code>x</code>. The length of the gradient must be the same as the length of <code>x</code>.  The user must supply this function.  If an analytic gradient is not available, and the method is <code>SR1</code> or <code>BFGS</code>, the user should consider a numerical approximation using finite differencing (see the numDeriv package).  Do not use a finite-differenced gradient with the <code>Sparse</code> method.  That will cause a world of hurt.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hs</code></td>
<td>
<p>An R function that takes x as its first argument.
It returns a Hessian matrix object of class <code>dgCMatrix</code> (see the <span class="pkg">Matrix</span> package).
This function is called only if the selected method is <code>Sparse</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Valid arguments are <code>SR1</code>,<code>BFGS</code>,and <code>Sparse</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>A list containing control parameters for the optimizer.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code>, <code>gr</code> and <code>hs</code>.
All arguments must be named.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>List containing the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>fval</code></td>
<td>
<p>Value of the objective function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solution</code></td>
<td>
<p>Parameter vector at the optimum</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gradient</code></td>
<td>
<p>Gradient at the optimum</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hessian</code></td>
<td>
<p>Estimate of the Hessian at the optimum (as class
<code>symmetricMatrix</code>, returned only for <code>Sparse</code> method).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>Number of iterations before stopping</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>status</code></td>
<td>
<p>A message describing the last state of the iterator</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nnz</code></td>
<td>
<p>For the Sparse method only, the number of nonzero elements in the lower triangle of the Hessian</p>
</td>
</tr>
</table>
<p>.
</p>


<h3>Details</h3>

<p>The following sections explain how to use the package as a whole.
</p>


<h3>Control parameters</h3>

<p>The control list should include the following parameters.
</p>

<dl>
<dt>start.trust.radius</dt>
<dd>
<p>Initial radius of the trust region. Default is 5.  If the algorithm returns non-finite values of the objective function early in the process, try a lower number.</p>
</dd>
<dt>stop.trust.radius</dt>
<dd>
<p>Minimum radius of trust region.  Algorithm will terminate if radius is below this value.  This is because it may not be possible to get the norm of the gradient smaller than prec, and this is another way to get the algorithm to stop.</p>
</dd>
<dt>cg.tol</dt>
<dd>
<p>tolerance for the conjugate gradient algorithm that is used for the trust region subproblem.  Set it to something very small.  Default is sqrt(.Machine$double.eps)</p>
</dd>
<dt>prec</dt>
<dd>
<p>Precision for how close the norm of the gradient at the
solution should be to zero, before the algorithm halts.  It is possible that the algorithm
will not get that far, so it will also stop when the radius of the
trust region is smaller thanstop.trust.radius.  If the trust
region radius collapses, but the norm of the gradient really isn't
close to zero, then something terrible has happened.</p>
</dd>
<dt>report.freq</dt>
<dd>
<p>An integer. The frequency at which the algorithm
will display the current iteration number or function value, among
other things (see <code>report.level</code>).  Defaults to 1.</p>
</dd>
<dt>report.level</dt>
<dd>
<p>The amount of detail in each report.  Defaults to 2.</p>
</dd>
<dt>report.precision</dt>
<dd>
<p>The number of significant digits used in each
report. Defaults to 5.</p>
</dd>
<dt>report.header.freq</dt>
<dd>
<p>The number of lines of iterations before the report column headers are reprinted.  Defaults to 25.</p>
</dd>
<dt>maxit</dt>
<dd>
<p>Maximum number of iterations.  Defaults to 100.</p>
</dd>
<dt>contract.factor</dt>
<dd>
<p>When the algorithm decides to shrink the trust region, it will multiply the trust radius by this factor. Defaults to 0.5.</p>
</dd>
<dt>expand.factor</dt>
<dd>
<p>When the algorithm decides to expand the trust
region, it will multiply the algorithm by this factor. Defaults to 3.</p>
</dd>
<dt>contract.threshold</dt>
<dd>
<p>The algorithm with accept a proposed move if the ratio of the actual improvement in the objective function, to the predicted improvement from the trust region subproblem, is greater than this amount.  Otherwise, the trust region will contract.  Default is 0.25.</p>
</dd>
<dt>expand.threshold.ap</dt>
<dd>
<p>First criterion to determine if the trust region should expand.  If the ratio of the actual and proposed improvements in the objective function is less than this factor, the algorithm will consider expanding the trust region.  See <code>expand.threshold.radius</code>. Default is 0.8.</p>
</dd>
<dt>expand.threshold.radius</dt>
<dd>
<p>If the ratio of the actual and proposed improvement in the objective function is less than <code>expand.threshold.ap</code>, then, if the normed distance of the proposed move is greater than <code>expand.threshold.radius</code>, times the current trust region radius, the trust region will expand.  Default is 0.8.</p>
</dd>
<dt>function.scale.factor</dt>
<dd>
<p>The algorithm will minimize <code>fn</code> times this
factor. If you want to maximize <code>fn</code>, this value should be negative
(usually -1).  Default is 1.</p>
</dd>
<dt>precond.refresh.freq</dt>
<dd>
<p>Frequency at which the preconditioner
for the conjugate gradiate estimation of the trust region
subproblem is reestimated.  Preconditioners can help the convergence properties of the algorithm.  Default is 1.</p>
</dd>
<dt>preconditioner</dt>
<dd>
<p>ID for choice of preconditioner.  0 is the
identity matrix (default), For the <code>Sparse</code> method, 1 is a modified Cholesky preconditioner. For the <code>BFGS</code> method, 1 is the full Cholesky decomposition.  If you select 1 for the <code>SR1</code> method, the algorithm will use the identity preconditioner instead.</p>
</dd>
<dt>trust.iter</dt>
<dd>
<p>Maximum number of conjugate gradient iterations to run when solving the trust region subproblem.  A higher number will lead to more accurate solutions to the subproblem, but may also lead to longer run times. Defaults to 2000.</p>
</dd>
</dl>
<h3>Report levels</h3>

<p>The <code>report.level</code> control parameter determines how much information is displayed each time the algorithm reports the current state.  Possible values are
</p>

<dl>
<dt>&lt;=0</dt>
<dd>
<p>No information (a quiet run)</p>
</dd>
<dt>1</dt>
<dd>
<p>Current iteration number, and current value of the objective function.</p>
</dd>
<dt>2</dt>
<dd>
<p>Information from level 1, plus the current norm of the gradient and a status message.</p>
</dd>
<dt>3</dt>
<dd>
<p>Information from levels 1 and 2, plus the current normed radius of the trust region.</p>
</dd>
<dt>4</dt>
<dd>
<p>Information from levels 1, 2, and 3, plus information from each estimate of the trust region subproblem (number of conjugate gradient iterations and how/why the CG algorithm terminated).</p>
</dd>
</dl>
<p>Default level is 2.  Levels 3 and 4 are available primarily for debugging purposes.
</p>


<h3>Stopping criteria</h3>

<p>The algorithm will stop when one of the following three conditions are met:
</p>

<ul>
<li>
<p>The norm of the gradient, divided by the square root of the number of parameters, is less than <code>prec</code>.
</p>
</li>
<li>
<p>The trust region collapse to a radius smaller than machine precision
</p>
</li>
<li>
<p>The algorithm proposes zero or negative improvement in the objective function (should never happen)
</p>
</li>
<li>
<p>The number of iterations reaches the control parameter <code>maxit</code>
</p>
</li>
</ul>
<p>If the algorithm appears to have stopped prematurely (i.e., the norm of the gradient is still too large), then one might just restart the algorithm.  For the quasi-Newton algorithms (<code>SR1</code> and <code>BFGS</code>), this will refresh the Hessian, and might allow more progress to be made.
</p>


<h3>Estimating a sparse Hessian</h3>

<p>Sometimes estimating the Hessian is easy (e.g., you have an analytic representation, or you are using some kind of algorithmic differentiation software).  If you do not know the Hessian, but you do know the sparsity structure, try the <span class="pkg">sparseHessianFD</span> package. The routines in <span class="pkg">sparseHessianFD</span> compute the Hessian using finite differencing, but in a way that exploits the sparsity structure.  In many cases, this can be faster than constructing an analytic Hessian for a large problem (e.g., when the Hessian has a block-arrow structure with a large number of blocks).
</p>
<p>To use the <span class="pkg">sparseHessianFD</span> package, you need to provide the row and column indices of the non-zero elements of the lower triangle of the Hessian. This structure cannot change during the course of the trust.optim routine.  Also, you really should provide an analytic gradient.  <span class="pkg">sparseHessianFD</span> computes finite differences of the gradient, so if the gradient itself is finite-differenced, so much error is propagated through that the Hessians are nearly worthless close to the optimum.
</p>
<p>Of course, <span class="pkg">sparseHessianFD</span> is useful only for the <code>Sparse</code> method.  That said, one may still get decent performance using these routines even if the Hessian is sparse, if the problem is not too large.  Just treat the Hessian as if it were sparse.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
data(binary)
N &lt;- length(binary$Y)
k &lt;- NROW(binary$X)
start &lt;- rep(0,(N+1)*k)
priors &lt;- list(inv.Sigma = diag(k), inv.Omega = diag(k))
opt &lt;- trust.optim(start, fn=binary.f,
                  gr = binary.grad,
                  hs = binary.hess,
                  method = "Sparse",
                  control = list(
                      report.precision=1L,
                      function.scale.factor=-1
                  ),
                  data=binary, priors=priors
                  )

## End(Not run)

</code></pre>


</div>