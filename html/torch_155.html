<div class="container">

<table style="width: 100%;"><tr>
<td>nnf_grid_sample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Grid_sample</h2>

<h3>Description</h3>

<p>Given an <code>input</code> and a flow-field <code>grid</code>, computes the
<code>output</code> using <code>input</code> values and pixel locations from <code>grid</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nnf_grid_sample(
  input,
  grid,
  mode = c("bilinear", "nearest"),
  padding_mode = c("zeros", "border", "reflection"),
  align_corners = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>(Tensor) input of shape <code class="reqn">(N, C, H_{\mbox{in}}, W_{\mbox{in}})</code> (4-D case)                    or <code class="reqn">(N, C, D_{\mbox{in}}, H_{\mbox{in}}, W_{\mbox{in}})</code> (5-D case)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grid</code></td>
<td>
<p>(Tensor) flow-field of shape <code class="reqn">(N, H_{\mbox{out}}, W_{\mbox{out}}, 2)</code> (4-D case)                   or <code class="reqn">(N, D_{\mbox{out}}, H_{\mbox{out}}, W_{\mbox{out}}, 3)</code> (5-D case)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>(str) interpolation mode to calculate output values <code>'bilinear'</code> | <code>'nearest'</code>.
Default: <code>'bilinear'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>padding_mode</code></td>
<td>
<p>(str) padding mode for outside grid values <code>'zeros'</code> | <code>'border'</code>
| <code>'reflection'</code>. Default: <code>'zeros'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>align_corners</code></td>
<td>
<p>(bool, optional) Geometrically, we consider the pixels of the
input  as squares rather than points. If set to <code>True</code>, the extrema (<code>-1</code> and
<code>1</code>) are considered as referring to the center points of the input's corner pixels.
If set to <code>False</code>, they are instead considered as referring to the corner
points of the input's corner pixels, making the sampling more resolution
agnostic. This option parallels the <code>align_corners</code> option in  <code>nnf_interpolate()</code>, and
so whichever option is used here should also be used there to resize the input
image before grid sampling. Default: <code>False</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Currently, only spatial (4-D) and volumetric (5-D) <code>input</code> are
supported.
</p>
<p>In the spatial (4-D) case, for <code>input</code> with shape
<code class="reqn">(N, C, H_{\mbox{in}}, W_{\mbox{in}})</code> and <code>grid</code> with shape
<code class="reqn">(N, H_{\mbox{out}}, W_{\mbox{out}}, 2)</code>, the output will have shape
<code class="reqn">(N, C, H_{\mbox{out}}, W_{\mbox{out}})</code>.
</p>
<p>For each output location <code style="white-space: pre;">⁠output[n, :, h, w]⁠</code>, the size-2 vector
<code>grid[n, h, w]</code> specifies <code>input</code> pixel locations <code>x</code> and <code>y</code>,
which are used to interpolate the output value <code style="white-space: pre;">⁠output[n, :, h, w]⁠</code>.
In the case of 5D inputs, <code>grid[n, d, h, w]</code> specifies the
<code>x</code>, <code>y</code>, <code>z</code> pixel locations for interpolating
<code style="white-space: pre;">⁠output[n, :, d, h, w]⁠</code>. <code>mode</code> argument specifies <code>nearest</code> or
<code>bilinear</code> interpolation method to sample the input pixels.
</p>
<p><code>grid</code> specifies the sampling pixel locations normalized by the
<code>input</code> spatial dimensions. Therefore, it should have most values in
the range of <code style="white-space: pre;">⁠[-1, 1]⁠</code>. For example, values <code style="white-space: pre;">⁠x = -1, y = -1⁠</code> is the
left-top pixel of <code>input</code>, and values  <code style="white-space: pre;">⁠x = 1, y = 1⁠</code> is the
right-bottom pixel of <code>input</code>.
</p>
<p>If <code>grid</code> has values outside the range of <code style="white-space: pre;">⁠[-1, 1]⁠</code>, the corresponding
outputs are handled as defined by <code>padding_mode</code>. Options are
</p>

<ul>
<li> <p><code>padding_mode="zeros"</code>: use <code>0</code> for out-of-bound grid locations,
</p>
</li>
<li> <p><code>padding_mode="border"</code>: use border values for out-of-bound grid locations,
</p>
</li>
<li> <p><code>padding_mode="reflection"</code>: use values at locations reflected by
the border for out-of-bound grid locations. For location far away
from the border, it will keep being reflected until becoming in bound,
e.g., (normalized) pixel location <code>x = -3.5</code> reflects by border <code>-1</code>
and becomes <code style="white-space: pre;">⁠x' = 1.5⁠</code>, then reflects by border <code>1</code> and becomes
<code style="white-space: pre;">⁠x'' = -0.5⁠</code>.
</p>
</li>
</ul>
<h3>Note</h3>

<p>This function is often used in conjunction with <code>nnf_affine_grid()</code>
to build <code style="white-space: pre;">⁠Spatial Transformer Networks⁠</code>_ .
</p>


</div>