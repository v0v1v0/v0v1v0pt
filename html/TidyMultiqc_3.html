<div class="container">

<table style="width: 100%;"><tr>
<td>load_multiqc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Loads one or more MultiQC reports into a data frame</h2>

<h3>Description</h3>

<p>Loads one or more MultiQC reports into a data frame
</p>


<h3>Usage</h3>

<pre><code class="language-R">load_multiqc(
  paths,
  plots = NULL,
  find_metadata = function(...) {     list() },
  plot_parsers = list(),
  sections = "general"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>paths</code></td>
<td>
<p>A string vector of filepaths to multiqc_data.json files</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plots</code></td>
<td>
<p>A string vector, each of which contains the ID of a plot you
want to include in the output. You can use <code>list_plots()</code> to help here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>find_metadata</code></td>
<td>
<p>A single function that will be called with a sample name and the
parsed JSON for the entire report and returns a named list of metadata fields for the sample.
Refer to the vignette for an example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_parsers</code></td>
<td>
<p><strong>Advanced</strong>. A named list of custom parser functions.
The names of the list should correspond to plotly plot types, such as "xy_line", and the values should be functions
that return a named list of named lists. For the return value, the outer list is named by the sample ID, and the inner list
is named by the name of the column. Refer to the source code for some examples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sections</code></td>
<td>
<p>A string vector of zero or more sections to include in the output.
Each section can be:
</p>

<dl>
<dt>"plot"</dt>
<dd>
<p>Parse plot data. Note that you should also provide a list of plots via the <code>plots</code> argument</p>
</dd>
<dt>"general"</dt>
<dd>
<p>parse the general stat section</p>
</dd>
<dt>"raw"</dt>
<dd>
<p>Parse the raw data section</p>
</dd>
</dl>
<p>This defaults to 'general', which tends to contain the most useful statistics</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A tibble (data.frame subclass) with QC data and metadata as columns, and samples as rows.
Columns are named according to the respective section they belong to,
and will always be listed in the following order:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>metadata.X</code></td>
<td>
<p>This column contains metadata for this sample.
By default this is only the sample ID, but if you have provided the
<code>find_metadata</code> argument, there may be more columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>general.X</code></td>
<td>
<p>This column contains a generally useful summary statistic for each sample</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.X</code></td>
<td>
<p>This column contains a data frame of plot data for each sample.
Refer to the plot parsers documentation (ie the <code>parse_X</code> functions) for more information on the output format. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>raw.X</code></td>
<td>
<p>This column contains a raw summary statistic or value relating to each sample </p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>parse_xyline_plot()</code> <code>parse_bar_graph()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">load_multiqc(system.file("extdata", "wgs/multiqc_data.json", package = "TidyMultiqc"))
</code></pre>


</div>