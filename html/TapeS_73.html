<div class="container">

<table style="width: 100%;"><tr>
<td>tprDiameterCpp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to extract diameters from Taper curve using Rcpp</h2>

<h3>Description</h3>

<p>This function uses Rcpp and C-code to implement the diameter
estimation of package TapeR to allow for faster estimation if no interval
information is required.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tprDiameterCpp(obj, Hx, bark = TRUE, cp = TRUE, mono = TRUE, Rfn = NULL)

## S4 method for signature 'tprTrees'
tprDiameterCpp(obj, Hx, bark = TRUE, cp = TRUE, mono = TRUE, Rfn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>object of class 'tprTrees'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Hx</code></td>
<td>
<p>vector of heights for which diameter are required</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bark</code></td>
<td>
<p>should diameter over or under bark be returned?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cp</code></td>
<td>
<p>cartesian product, i.e. apply all <code>Hx</code> to all trees, defaults
to TRUE</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mono</code></td>
<td>
<p>logical to decide whether a supporting diameter should be added
in case the taper curve is regarded as non-monotonic. Defaults to TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Rfn</code></td>
<td>
<p>setting for residuals error matrix, defaults to <code>"sig2"</code>, see
details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Function evaluates taper curves at required height <code>Hx</code>. By
default (<code>cp==TRUE</code>), the taper curve is evaluated at <code>Hx</code> for each
tree. If <code>cp==FALSE</code>, each tree is evaluated at exactly one Hx (recycled
if necessary). This feature is intended for situations where diameter in
relative heights are required. Then, the recycling of one height Hx (e.g.
1.3m) is not possible, since relative heights depend on absolute tree height,
which might be different for each tree. Hence a call like
<code>tprDiameter(obj, Hx=0.3*Ht(obj), cp=FALSE)</code> is necessary.
</p>


<h3>Value</h3>

<p>a vector, in case only one diameter (i.e. Hx) is required per tree
(<code>cp=FALSE</code>) or a matrix of size
<code>length(trees)</code> x <code>length(Hx)</code> (<code>cp=TRUE</code>).
</p>


<h3>Methods (by class)</h3>


<ul><li> <p><code>tprDiameterCpp(tprTrees)</code>: method for class 'tprTrees'
</p>
</li></ul>
<h3>See Also</h3>

<p><code>tprDiameter</code> if confidence or prediction intervals
are required.
</p>


<h3>Examples</h3>

<pre><code class="language-R">obj &lt;- tprTrees(spp=c(1 , 3),
                Hm=list(c(1.3, 5), c(1.3, 5)),
                Dm=list(c(27, 25), c(27, 25)),
                Ht=c(27, 27))
Hx &lt;- seq(0, 1, 0.1)
tprDiameterCpp(obj, Hx = Hx)
tprDiameterCpp(obj, Hx = Hx, bark=FALSE)
tprDiameterCpp(obj, Hx = c(1, 2), bark=FALSE, cp=FALSE)


require(rbenchmark)
benchmark(tprDiameter(obj, Hx, bark = TRUE),
          tprDiameterCpp(obj, Hx, bark = TRUE),
          replications = 10000)[,1:4]

</code></pre>


</div>