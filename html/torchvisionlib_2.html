<div class="container">

<table style="width: 100%;"><tr>
<td>ops_ps_roi_align</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Performs Position-Sensitive Region of Interest (RoI) Align operator</h2>

<h3>Description</h3>

<p>The (RoI) Align operator is mentioned in <a href="https://arxiv.org/abs/1711.07264">Light-Head R-CNN</a>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ops_ps_roi_align(
  input,
  boxes,
  output_size,
  spatial_scale = 1,
  sampling_ratio = -1
)

nn_ps_roi_align(output_size, spatial_scale = 1, sampling_ratio = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input</code></td>
<td>
<p>(<code>Tensor[N, C, H, W]</code>): The input tensor, i.e. a batch with <code>N</code> elements. Each element
contains <code>C</code> feature maps of dimensions <code style="white-space: pre;">⁠H x W⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>boxes</code></td>
<td>
<p>(<code>Tensor[K, 5]</code> or <code>List[Tensor[L, 4]]</code>): the box coordinates in (x1, y1, x2, y2)
format where the regions will be taken from.
The coordinate must satisfy <code style="white-space: pre;">⁠0 &lt;= x1 &lt; x2⁠</code> and <code style="white-space: pre;">⁠0 &lt;= y1 &lt; y2⁠</code>.
If a single Tensor is passed, then the first column should
contain the index of the corresponding element in the batch, i.e. a number in <code style="white-space: pre;">⁠[1, N]⁠</code>.
If a list of Tensors is passed, then each Tensor will correspond to the boxes for an element i
in the batch.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_size</code></td>
<td>
<p>(int or <code>Tuple[int, int]</code>): the size of the output (in bins or pixels) after the pooling
is performed, as (height, width).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>spatial_scale</code></td>
<td>
<p>(float): a scaling factor that maps the box coordinates to
the input coordinates. For example, if your boxes are defined on the scale
of a 224x224 image and your input is a 112x112 feature map (resulting from a 0.5x scaling of
the original image), you'll want to set this to 0.5. Default: 1.0</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sampling_ratio</code></td>
<td>
<p>(int): number of sampling points in the interpolation grid
used to compute the output value of each pooled output bin. If &gt; 0,
then exactly <code style="white-space: pre;">⁠sampling_ratio x sampling_ratio⁠</code> sampling points per bin are used. If
&lt;= 0, then an adaptive number of grid points are used (computed as
<code>ceil(roi_width / output_width)</code>, and likewise for height). Default: -1</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>Tensor[K, C / (output_size[1] * output_size[2]), output_size[1], output_size[2]]</code>:
The pooled RoIs
</p>


<h3>Functions</h3>


<ul><li> <p><code>nn_ps_roi_align()</code>: The <code>torch::nn_module()</code> wrapper for <code>ops_ps_roi_align()</code>.
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R">if (torchvisionlib_is_installed()) {
library(torch)
library(torchvisionlib)
input &lt;- torch_randn(1, 3, 28, 28)
boxes &lt;- list(torch_tensor(matrix(c(1,1,5,5), ncol = 4)))
roi &lt;- nn_ps_roi_align(output_size = c(1, 1))
roi(input, boxes)
}

</code></pre>


</div>