<div class="container">

<table style="width: 100%;"><tr>
<td>==.sq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compare sq objects</h2>

<h3>Description</h3>

<p>Compares input <code>sq</code> object with either
another <code>sq</code> object or <code>character</code> vector.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'sq'
e1 == e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>e1</code></td>
<td>
<p>[<code>sq</code>]<br>
An object this comparison is applied to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e2</code></td>
<td>
<p>[<code>sq</code> || <code>character</code>]<br>
An object to compare with <code>x1</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>`==`</code> compares compatible object for equality of their respective
sequences. Objects are considered compatible, when either both have same
length or one of them is a scalar value (i.e. a vector of length 1).
Moreover, not every <code>e1</code> sq type can be compared to any <code>e2</code> sq
type.
</p>
<p>To see which types are compatible, see Details of
<code>sq-concatenate</code>.
</p>
<p><code>`==`</code> returns logical vector, where each element describes whether
elements at position <code>n</code> of both <code>e1</code> and <code>e2</code> are equal in
meaning (that is, they may be represented differently, but their biological
interpretation must be identical). If one of compared objects is a scalar,
then said logical vector describes comparison for each element of the other,
longer vector.
</p>


<h3>Value</h3>

<p>A <code>logical</code> vector indicating on which positions these
objects are equal.
</p>


<h3>See Also</h3>

<p>Functions from utility module:
<code>get_sq_lengths()</code>,
<code>is.sq()</code>,
<code>sqconcatenate</code>,
<code>sqextract</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Creating objects to work on:
sq_dna_1 &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT"),
               alphabet = "dna_bsc")
sq_dna_2 &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT"),
               alphabet = "dna_bsc")
sq_dna_3 &lt;- sq(c("ACTGCTG", "CTTAGA", "GGAA"),
               alphabet = "dna_bsc")
sq_dna_4 &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "GTNANN"),
               alphabet = "dna_ext")
sq_ami_1 &lt;- sq(c("ACTGCTG", "NIKAAR", "CCCT", "CTGAATGT"),
               alphabet = "ami_bsc")
sq_unt &lt;- sq(c("AHSNLVSCTK$SH%&amp;VS", "YQTVKA&amp;#BSKJGY",
               "CCCT", "AVYI#VSV&amp;*DVGDJCFA"))

# Comparing sq object with an object of the same length:
sq_dna_1 == sq_dna_2
sq_dna_1 == c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT")

# Cannot compare sq objects of different lengths:
## Not run: 
sq_dna_1 == sq_dna_3
sq_dna_1 == c("AAA", "CCC")

## End(Not run)

# Unless comparing sq object with scalar value:
sq_dna_1 == "CTTAGA"

# It's possible to compare basic and extended types:
sq_dna_1 == sq_dna_4

# Mixing DNA, RNA and amino acid types throws an error, however:
## Not run: 
sq_dna_1 == sq_ami_1

## End(Not run)

# On the other hand, unt sq is acceptable everywhere:
sq_dna_1 == sq_unt
sq_dna_4 == sq_unt
sq_ami_1 == sq_unt

</code></pre>


</div>