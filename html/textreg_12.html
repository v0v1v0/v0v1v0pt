<div class="container">

<table style="width: 100%;"><tr>
<td>find.threshold.C</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Conduct permutation test on labeling to get null distribution of regularization parameter.</h2>

<h3>Description</h3>

<p>First determines what regularization will give null model on labeling.  Then permutes labeling
repeatidly, recording what regularization will give null model for permuted labeling.
This allows for permutation-style inference on the relationship of the labeling to the text, and
allows for appropriate selection of the tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class="language-R">find.threshold.C(corpus, labeling, banned = NULL, R = 0,
  objective.function = 2, a = 1, verbosity = 0,
  step.verbosity = verbosity, positive.only = FALSE,
  binary.features = FALSE, no.regularization = FALSE,
  positive.weight = 1, Lq = 2, min.support = 1, min.pattern = 1,
  max.pattern = 100, gap = 0, token.type = "word",
  convergence.threshold = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>corpus</code></td>
<td>
<p>A list of strings or a corpus from the <code>tm</code> package.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labeling</code></td>
<td>
<p>A vector of +1/-1 or TRUE/FALSE indicating which documents are considered relevant and
which are baseline.  The +1/-1 can contain 0 whcih means drop the document.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>banned</code></td>
<td>
<p>List of words that should be dropped from consideration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Number of times to scramble labling.  0 means use given labeling and find single C value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>objective.function</code></td>
<td>
<p>2 is hinge loss.  0 is something.  1 is something else.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>What percent of regularization should be L1 loss (a=1) vs L2 loss (a=0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbosity</code></td>
<td>
<p>Level of output.  0 is no printed output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step.verbosity</code></td>
<td>
<p>Level of output for line searches.  0 is no printed output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>positive.only</code></td>
<td>
<p>Disallow negative features if true</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>binary.features</code></td>
<td>
<p>Just code presence/absence of a feature in a document rather than count of feature in document.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no.regularization</code></td>
<td>
<p>Do not renormalize the features at all.  (Lq will be ignored.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>positive.weight</code></td>
<td>
<p>Scale weight pf all positively marked documents by this value.  (1, i.e., no scaling) is default)   NOT FULLY IMPLEMENTED</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Lq</code></td>
<td>
<p>Rescaling to put on the features (2 is standard).  Can be from 1 up.  Values above 10 invoke an infinity-norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.support</code></td>
<td>
<p>Only consider phrases that appear this many times or more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.pattern</code></td>
<td>
<p>Only consider phrases this long or longer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.pattern</code></td>
<td>
<p>Only consider phrases this short or shorter</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gap</code></td>
<td>
<p>Allow phrases that have wildcard words in them.  Number is how many wildcards in a row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>token.type</code></td>
<td>
<p>"word" or "character" as tokens.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence.threshold</code></td>
<td>
<p>How to decide if descent has converged.  (Will go for three steps at this threshold to check for flatness.)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Important: use the same parameter values as used with the original textreg call!
</p>


<h3>Value</h3>

<p>A list of numbers (the Cs) R+1 long.  The first number is always the C used for the _passed_ labeling.  The remainder are shuffles.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data( testCorpora )
find.threshold.C( testCorpora$testI$corpus, testCorpora$testI$labelI, c(), R=5, verbosity=1 )
</code></pre>


</div>