<div class="container">

<table style="width: 100%;"><tr>
<td>computePL</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A Vector Summary of the Persistence Landscape Function</h2>

<h3>Description</h3>

<p>Vectorizes the persistence landscape (PL) function constructed from a given persistence diagram. The <code class="reqn">k</code>th order landscape function of a persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\lambda_k(t) = k\hbox{max}_{1\leq i \leq N} \Lambda_i(t), \quad k\in N,</code>
</p>

<p>where <code class="reqn">k\hbox{max}</code> returns the <code class="reqn">k</code>th largest value and 
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_i(t) = \left\{
        \begin{array}{ll}
            t-b_i &amp; \quad t\in [b_i,\frac{b_i+d_i}{2}] \\
            d_i-t &amp; \quad t\in (\frac{b_i+d_i}{2},d_i]\\
            0 &amp; \quad \hbox{otherwise}
        \end{array}
    \right.</code>
</p>



<h3>Usage</h3>

<pre><code class="language-R">computePL(D, homDim, scaleSeq, k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>matrix with three columns containing the dimension, birth and death values respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>homDim</code></td>
<td>
<p>homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleSeq</code></td>
<td>
<p>numeric vector of increasing scale values used for vectorization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>order of landscape function. By default, <code>k=1</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector whose elements are the values of the <code class="reqn">k</code>th order landscape function evaluated at each point of <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">(\lambda_k(t_1),\lambda_k(t_2),\ldots,\lambda_k(t_n))</code>
</p>



<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Bubenik, P. (2015). Statistical topological data analysis using persistence landscapes. Journal of Machine Learning Research, 16(1), 77-102. 
</p>
<p>2. Chazal, F., Fasy, B. T., Lecci, F., Rinaldo, A., &amp; Wasserman, L. (2014, June). Stochastic convergence of persistence landscapes and silhouettes. In Proceedings of the thirtieth annual symposium on Computational geometry (pp. 474-483).
</p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- 100 
set.seed(123)
# sample N points uniformly from unit circle and add Gaussian noise
X &lt;- TDA::circleUnif(N,r=1) + rnorm(2*N,mean = 0,sd = 0.2)

# compute a persistence diagram using the Rips filtration built on top of X
D &lt;- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 

scaleSeq = seq(0,2,length.out=11) # sequence of scale values

# compute persistence landscape (PL) for homological dimension H_0 with order of landscape k=1
computePL(D,homDim=0,scaleSeq,k=1)

# compute persistence landscape (PL) for homological dimension H_1 with order of landscape k=1
computePL(D,homDim=1,scaleSeq,k=1)
</code></pre>


</div>