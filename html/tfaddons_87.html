<div class="container">

<table style="width: 100%;"><tr>
<td>lookahead_mechanism</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Lookahead mechanism</h2>

<h3>Description</h3>

<p>Lookahead mechanism
</p>


<h3>Usage</h3>

<pre><code class="language-R">lookahead_mechanism(
  optimizer,
  sync_period = 6,
  slow_step_size = 0.5,
  name = "Lookahead",
  clipnorm = NULL,
  clipvalue = NULL,
  decay = NULL,
  lr = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>optimizer</code></td>
<td>
<p>The original optimizer that will be used to compute and apply the gradients.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sync_period</code></td>
<td>
<p>An integer. The synchronization period of lookahead. Enable lookahead mechanism
by setting it with a positive value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slow_step_size</code></td>
<td>
<p>A floating point value. The ratio for updating the slow weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>Optional name for the operations created when applying gradients. Defaults to "Lookahead".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clipnorm</code></td>
<td>
<p>is clip gradients by norm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clipvalue</code></td>
<td>
<p>is clip gradients by value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decay</code></td>
<td>
<p>is included for backward compatibility to allow time inverse decay of learning rate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lr</code></td>
<td>
<p>is included for backward compatibility, recommended to use learning_rate instead.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The mechanism is proposed by Michael R. Zhang et.al in the paper
[Lookahead Optimizer: k steps forward, 1 step back](https://arxiv.org/abs/1907.08610v1).
The optimizer iteratively updates two sets of weights: the search directions for weights
are chosen by the inner optimizer, while the "slow weights" are updated each k steps based
on the directions of the "fast weights" and the two sets of weights are synchronized.
This method improves the learning stability and lowers the variance of its inner optimizer.
</p>


<h3>Value</h3>

<p>Optimizer for use with 'keras::compile()'
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

opt = tf$keras$optimizers$SGD(learning_rate)
opt = lookahead_mechanism(opt)


## End(Not run)
</code></pre>


</div>