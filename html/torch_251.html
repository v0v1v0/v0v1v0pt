<div class="container">

<table style="width: 100%;"><tr>
<td>nn_embedding</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Embedding module</h2>

<h3>Description</h3>

<p>A simple lookup table that stores embeddings of a fixed dictionary and size.
This module is often used to store word embeddings and retrieve them using indices.
The input to the module is a list of indices, and the output is the corresponding
word embeddings.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nn_embedding(
  num_embeddings,
  embedding_dim,
  padding_idx = NULL,
  max_norm = NULL,
  norm_type = 2,
  scale_grad_by_freq = FALSE,
  sparse = FALSE,
  .weight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>num_embeddings</code></td>
<td>
<p>(int): size of the dictionary of embeddings</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>embedding_dim</code></td>
<td>
<p>(int): the size of each embedding vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>padding_idx</code></td>
<td>
<p>(int, optional): If given, pads the output with the embedding vector at <code>padding_idx</code>
(initialized to zeros) whenever it encounters the index.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_norm</code></td>
<td>
<p>(float, optional): If given, each embedding vector with norm larger than <code>max_norm</code>
is renormalized to have norm <code>max_norm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm_type</code></td>
<td>
<p>(float, optional): The p of the p-norm to compute for the <code>max_norm</code> option. Default <code>2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_grad_by_freq</code></td>
<td>
<p>(boolean, optional): If given, this will scale gradients by the inverse of frequency of
the words in the mini-batch. Default <code>False</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sparse</code></td>
<td>
<p>(bool, optional): If <code>True</code>, gradient w.r.t. <code>weight</code> matrix will be a sparse tensor.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.weight</code></td>
<td>
<p>(Tensor) embeddings weights (in case you want to set it manually)
</p>
<p>See Notes for more details regarding sparse gradients.</p>
</td>
</tr>
</table>
<h3>Attributes</h3>


<ul><li>
<p> weight (Tensor): the learnable weights of the module of shape (num_embeddings, embedding_dim)
initialized from <code class="reqn">\mathcal{N}(0, 1)</code>
</p>
</li></ul>
<h3>Shape</h3>


<ul>
<li>
<p> Input: <code class="reqn">(*)</code>, LongTensor of arbitrary shape containing the indices to extract
</p>
</li>
<li>
<p> Output: <code class="reqn">(*, H)</code>, where <code>*</code> is the input shape and <code class="reqn">H=\mbox{embedding\_dim}</code>
</p>
</li>
</ul>
<h3>Note</h3>

<p>Keep in mind that only a limited number of optimizers support
sparse gradients: currently it's <code>optim.SGD</code> (<code>CUDA</code> and <code>CPU</code>),
<code>optim.SparseAdam</code> (<code>CUDA</code> and <code>CPU</code>) and <code>optim.Adagrad</code> (<code>CPU</code>)
</p>
<p>With <code>padding_idx</code> set, the embedding vector at
<code>padding_idx</code> is initialized to all zeros. However, note that this
vector can be modified afterwards, e.g., using a customized
initialization method, and thus changing the vector used to pad the
output. The gradient for this vector from nn_embedding
is always zero.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
# an Embedding module containing 10 tensors of size 3
embedding &lt;- nn_embedding(10, 3)
# a batch of 2 samples of 4 indices each
input &lt;- torch_tensor(rbind(c(1, 2, 4, 5), c(4, 3, 2, 9)), dtype = torch_long())
embedding(input)
# example with padding_idx
embedding &lt;- nn_embedding(10, 3, padding_idx = 1)
input &lt;- torch_tensor(matrix(c(1, 3, 1, 6), nrow = 1), dtype = torch_long())
embedding(input)
}
</code></pre>


</div>