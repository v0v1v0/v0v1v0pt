<div class="container">

<table style="width: 100%;"><tr>
<td>disstree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Dissimilarity Tree</h2>

<h3>Description</h3>

<p>Tree structured discrepancy analysis of objects described by their pairwise dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">disstree(formula, data = NULL, weights = NULL, min.size = 0.05,
  max.depth = 5, R = 1000, pval = 0.01, object = NULL,
  weight.permutation = "replicate", squared = FALSE, first = NULL,
  minSize, maxdepth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>Formula with a dissimilarity matrix as left hand side and the candidate partitioning variables on the right side.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Data frame where variables in formula will be searched for.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Optional numerical vector of weights.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min.size</code></td>
<td>
<p>Minimum number of cases in a node, will be treated as a proportion if less than 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.depth</code></td>
<td>
<p>Maximum depth of the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Number of permutations used to assess the significance of the split.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval</code></td>
<td>
<p>Maximum allowed p-value for a split</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>An optional R object represented by the dissimilarity matrix. This object may be used by the <code>print</code> method or  <code>disstree2dot</code> to render specific object type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight.permutation</code></td>
<td>
<p>Weight permutation method: <code>"diss"</code> (attach weights to the dissimilarity matrix), <code>"replicate"</code> (replicate cases using <code>weights</code>), <code>"rounded-replicate"</code> (replicate case using rounded <code>weights</code>), <code>"random-sampling"</code> (random assignment of covariate profiles to the objects using distributions defined by the weights.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>squared</code></td>
<td>
<p>Logical: Should the <code>diss</code> dissimilarities be squared?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first</code></td>
<td>
<p>One of the variable in the right-hand side of the formula. This forces the first node of the tree to be split by this variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>minSize</code></td>
<td>
<p>Deprecated. Use <code>min.size</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdepth</code></td>
<td>
<p>Deprecated. Use <code>max.depth</code> instead.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The procedure iteratively splits the data. At each step, the procedure selects the variable and split that explain the greatest part of the discrepancy,
i.e., the split for which we get the highest pseudo R2.
The significance of the retained split is assessed through a permutation test.
</p>
<p><code>seqtree</code> provides a simpler interface if you plan to use <code>disstree</code> for state sequence objects.
</p>


<h3>Value</h3>

<p>An object of class <code>disstree</code> that contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>A node object, root of the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>General information such as parameters used to build the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info$adjustment</code></td>
<td>
<p>A <code>dissassoc</code> object providing global statistics for tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>The formula used to generate the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>data used to build the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Matthias Studer (with Gilbert Ritschard for the help page)</p>


<h3>References</h3>

<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2011). Discrepancy analysis of state sequences, <em>Sociological Methods and Research</em>, Vol. 40(3), 471-510, <a href="https://doi.org/10.1177/0049124111415372">doi:10.1177/0049124111415372</a>.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2010)
Discrepancy	analysis of complex objects using dissimilarities.
In F. Guillet, G. Ritschard, D. A. Zighed and H. Briand (Eds.),
<em>Advances in Knowledge Discovery and Management</em>,
Studies in Computational Intelligence, Volume 292, pp. 3-19. Berlin: Springer.
</p>
<p>Studer, M., G. Ritschard, A. Gabadinho and N. S. Müller (2009)
Analyse de dissimilarités par arbre d'induction. In EGC 2009,
<em>Revue des Nouvelles Technologies de l'Information</em>, Vol. E-15, pp. 7-18.
</p>
<p>Anderson, M. J. (2001) A new method for non-parametric multivariate analysis of variance.
<em>Austral Ecology</em> <b>26</b>, 32-46.
</p>
<p>Batagelj, V. (1988) Generalized ward and related clustering problems. In H. Bock (Ed.),
<em>Classification and related methods of data analysis</em>, Amsterdam: North-Holland, pp. 67-74.
</p>
<p>Piccarreta, R. et F. C. Billari (2007) Clustering work and family trajectories by using a divisive
algorithm. <em>Journal of the Royal Statistical Society A</em> <b>170</b>(4), 1061–1078.
</p>


<h3>See Also</h3>

<p><code>seqtree</code> to generate a specific <code>disstree</code> objects for analyzing state sequences.
<br><code>seqtreedisplay</code> to generate graphic representation of <code>seqtree</code> objects when analyzing state sequences.
<br><code>disstreedisplay</code> is a more general interface to generate such representation for other type of objects.
<br><code>disstreeleaf</code> to get leaf membership of each case.
<br><code>disstree.get.rules</code> to get the list of classification rules as R commands.
<br><code>disstree.assign</code> for the index of the rules applying to provided profiles.
<br><code>dissvar</code> to compute discrepancy using dissimilarities and for a basic introduction to discrepancy analysis.
<br><code>dissassoc</code> to test association between objects represented by their dissimilarities and a covariate.
<br><code>dissmfacw</code> to perform multi-factor analysis of variance from pairwise dissimilarities.
<br><code>disscenter</code> to compute the distance of each object to its group center from pairwise dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(mvad)

## Defining a state sequence object
mvad.seq &lt;- seqdef(mvad[, 17:86])

## Computing dissimilarities (any dissimilarity measure can be used)
mvad.ham &lt;- seqdist(mvad.seq, method="HAM")
## Grow the tree using a low R value for illustration.
## For R=10, pval cannot be lower than 0.1
dt &lt;- disstree(mvad.ham~ male + Grammar + funemp + gcse5eq + fmpr + livboth,
               data=mvad, R = 10, pval = 0.1)
print(dt)


## Will only work if GraphViz is properly installed
## See seqtree for a simpler way to plot a sequence tree.
## Not run: 
disstreedisplay(dt, image.fun = seqdplot, image.data = mvad.seq,
                ## Additional parameters passed to seqdplot
                with.legend = FALSE, xaxis = FALSE, ylab = "", border=NA)

## End(Not run)

## Second method, using a specific function
myplotfunction &lt;- function(individuals, seqs, ...) {
  par(font.sub=2, mar=c(3,0,6,0), mgp=c(0,0,0))
  ## using mds to order sequence in seqIplot
  mds &lt;- suppressMessages(cmdscale(seqdist(seqs[individuals,], method="HAM"),k=1))
  seqIplot(seqs[individuals,], sortv=mds,...)
}

## If image.data is not set, indexes of individuals are sent to image.fun
## Not run: 
disstreedisplay(dt, image.fun = myplotfunction, cex.main = 3,
                ## additional parameters passed to myplotfunction
                seqs = mvad.seq,
                ## additional parameters passed to seqIplot (through myplotfunction)
                with.legend = FALSE, xaxis = FALSE, ylab = "")

## End(Not run)

## Retrieving terminal node membership
term.leaf &lt;- disstreeleaf(dt)
table(term.leaf)

## Retrieving classification rules
rules &lt;- disstree.get.rules(dt)

## Index of rule (terminal leaf) that applies to a specified profile
## covariates are: male, Grammar, funemp, gcse5eq, fmpr, livboth

profile &lt;- data.frame(male="no", Grammar="yes", funemp="no", gcse5eq="yes", fmpr="no", livboth="no")
rules[disstree.assign(rules, profile=profile)]

</code></pre>


</div>