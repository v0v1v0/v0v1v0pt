<div class="container">

<table style="width: 100%;"><tr>
<td>infer.analysis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Inference Performance Measures</h2>

<h3>Description</h3>

<p>False positive, false negative, discoveries, and non-discoveries of inference for sparse tensor graphical models.
</p>


<h3>Usage</h3>

<pre><code class="language-R">infer.analysis(mat.list, critical, Omega.true.list, offdiag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat.list</code></td>
<td>
<p>list of matrices. (i,j) entry in its kth element is test statistic 
value for (i,j) entry of kth true precision matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>critical</code></td>
<td>
<p>critical level of rejecting null hypothesis. If <code>critical</code> is not positive, all null hypothesis will not be rejected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega.true.list</code></td>
<td>
<p>list of true precision matrices of tensor, i.e., <code>Omega.true.list[[k]]</code> is true precision matrix 
for the kth tensor mode, <code class="reqn">k \in \{1 , \ldots, K\}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offdiag</code></td>
<td>
<p>logical; indicate if excludes diagnoal when computing performance measures. 
If <code>offdiag = TRUE</code>, diagnoal in each matrix is ingored 
when comparing two matrices. Default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes performance measures of inference for sparse tensor graphical models. 
False positive, false negative, discovery (number of rejected null hypothesis), non-discovery (number of non-rejected null hypothesis), 
and total non-zero entries of each true precision matrix is listed in output.
</p>


<h3>Value</h3>

<p>A list, named <code>Out</code>, of following performance measures:
</p>

<table>
<tr>
<td style="text-align: left;">
 <code>Out$fp</code>  </td>
<td style="text-align: left;">  vector; number of false positive of each mode </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>Out$fn</code>  </td>
<td style="text-align: left;">  vector; number of false negative of each mode </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>Out$d</code>  </td>
<td style="text-align: left;">   vector; number of all discovery of each mode </td>
</tr>
<tr>
<td style="text-align: left;">
 <code>Out$nd</code>  </td>
<td style="text-align: left;">  vector; number of all non-discovery of each mode </td>
</tr>
<tr>
<td style="text-align: left;"> 
 <code>Out$t</code>  </td>
<td style="text-align: left;">   vector; number of all true non-zero entries in true precision matrix of each mode </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Xiang Lyu, Will Wei Sun, Zhaoran Wang, Han Liu, Jian Yang, Guang Cheng.
</p>


<h3>See Also</h3>

<p><code>Tlasso.fit</code>, <code>est.analysis</code>, <code>ChainOmega</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
m.vec = c(5,5,5)  # dimensionality of a tensor 
n = 5   # sample size 
Omega.true.list = list()
Omega.true.list[[1]] = ChainOmega(m.vec[1], sd = 1)
Omega.true.list[[2]] = ChainOmega(m.vec[2], sd = 2)
Omega.true.list[[3]] = ChainOmega(m.vec[3], sd = 3)
lambda.thm = 20*c( sqrt(log(m.vec[1])/(n*prod(m.vec))), 
                   sqrt(log(m.vec[2])/(n*prod(m.vec))), 
                   sqrt(log(m.vec[3])/(n*prod(m.vec))))
DATA=Trnorm(n,m.vec,type='Chain') 
# obersavations from tensor normal distribution
out.tlasso = Tlasso.fit(DATA,T=1,lambda.vec = lambda.thm)   
# output is a list of estimation of precision matrices
mat.list=list()
for ( k in 1:3) {
  rho=covres(DATA, out.tlasso, k = k) 
  # sample covariance of residuals, including diagnoal 
  varpi2=varcor(DATA, out.tlasso, k = k)
  # variance correction term for kth mode's sample covariance of residuals
  bias_rho=biascor(rho,out.tlasso,k=k)
  # bias corrected 
  
  tautest=matrix(0,m.vec[k],m.vec[k])
  for( i in 1:(m.vec[k]-1)) {
    for ( j in (i+1):m.vec[k]){
      tautest[j,i]=tautest[i,j]=sqrt((n-1)*prod(m.vec[-k]))*
        bias_rho[i,j]/sqrt(varpi2*rho[i,i]*rho[j,j])
    }
  }
  # list of matrices of test statistic values (off-diagnoal). See Sun et al. 2016
  mat.list[[k]]=tautest
}

infer.analysis(mat.list, qnorm(0.975), Omega.true.list, offdiag=TRUE)
# inference measures (off-diagnoal) 

</code></pre>


</div>