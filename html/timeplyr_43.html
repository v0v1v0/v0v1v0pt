<div class="container">

<table style="width: 100%;"><tr>
<td>growth_rate</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast Growth Rates</h2>

<h3>Description</h3>

<p>Calculate the rate of percentage
change per unit time.
</p>


<h3>Usage</h3>

<pre><code class="language-R">growth_rate(x, na.rm = FALSE, log = FALSE, inf_fill = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Numeric vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Should missing values be removed when calculating window?
Defaults to <code>FALSE</code>. When <code>na.rm = TRUE</code> the size of the rolling windows
are adjusted to the number of non-<code>NA</code> values in each window.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>log</code></td>
<td>
<p>If <code>TRUE</code> then growth rates are calculated on the log-scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inf_fill</code></td>
<td>
<p>Numeric value to replace <code>Inf</code> values with.
Default behaviour is to keep <code>Inf</code> values.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>It is assumed that <code>x</code> is a vector of values with
a corresponding time index that increases regularly
with no gaps or missing values.
</p>
<p>The output is to be interpreted as the average percent change per unit time.
</p>
<p>For a rolling version that can calculate rates as you move through time,
see <code>roll_growth_rate</code>.
</p>
<p>For a more generalised method that incorporates
time gaps and complex time windows,
use <code>time_roll_growth_rate</code>.
</p>
<p>The growth rate can also be calculated using the
geometric mean of percent changes.
</p>
<p>The below identity should always hold:
</p>
<pre>
`tail(roll_growth_rate(x, window = length(x)), 1) == growth_rate(x)`
</pre>


<h3>Value</h3>

<p><code>numeric(1)</code>
</p>


<h3>See Also</h3>

<p>roll_growth_rate time_roll_growth_rate
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(timeplyr)

set.seed(42)
initial_investment &lt;- 100
years &lt;- 1990:2000
# Assume a rate of 8% increase with noise
relative_increases &lt;- 1.08 + rnorm(10, sd = 0.005)

assets &lt;- Reduce(`*`, relative_increases, init = initial_investment, accumulate = TRUE)
assets

# Note that this is approximately 8%
growth_rate(assets)

# We can also calculate the growth rate via geometric mean

rel_diff &lt;- exp(diff(log(assets)))
all.equal(rel_diff, relative_increases)

geometric_mean &lt;- function(x, na.rm = TRUE, weights = NULL){
  exp(collapse::fmean(log(x), na.rm = na.rm, w = weights))
}

geometric_mean(rel_diff) == growth_rate(assets)

# Weighted growth rate

w &lt;- c(rnorm(5)^2, rnorm(5)^4)
geometric_mean(rel_diff, weights = w)

# Rolling growth rate over the last n years
roll_growth_rate(assets)

# The same but using geometric means
exp(roll_mean(log(c(NA, rel_diff))))

# Rolling growth rate over the last 5 years
roll_growth_rate(assets, window = 5)
roll_growth_rate(assets, window = 5, partial = FALSE)

## Rolling growth rate with gaps in time

years2 &lt;- c(1990, 1993, 1994, 1997, 1998, 2000)
assets2 &lt;- assets[years %in% years2]

# Below does not incorporate time gaps into growth rate calculation
# But includes helpful warning
time_roll_growth_rate(assets2, window = 5, time = years2)
# Time step allows us to calculate correct rates across time gaps
time_roll_growth_rate(assets2, window = 5, time = years2, time_step = 1) # Time aware

</code></pre>


</div>