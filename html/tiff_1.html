<div class="container">

<table style="width: 100%;"><tr>
<td>readTIFF</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Read a bitmap image stored in the TIFF format
</h2>

<h3>Description</h3>

<p>Reads an image from a TIFF file/content into a raster array.
</p>


<h3>Usage</h3>

<pre><code class="language-R">readTIFF(source, native = FALSE, all = FALSE, convert = FALSE,
         info = FALSE, indexed = FALSE, as.is = FALSE,
	 payload = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>source</code></td>
<td>
<p>Either name of the file to read from or a raw vector
representing the TIFF file content.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>native</code></td>
<td>
<p>logical, determines the image representation - if
<code>FALSE</code> (the default) then the result is an array, if
<code>TRUE</code> then the result is a native raster representation
(suitable for plotting).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all</code></td>
<td>
<p>logical scalar or integer vector. TIFF files can contain
more than one image. If <code>all=TRUE</code> then all images are returned
in a list of images. If <code>all</code> is a vector, it gives the
(1-based) indices of images to return. Otherwise only the first
image is returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convert</code></td>
<td>
<p>logical, if <code>TRUE</code> then first convert the image into
8-bit RGBA samples and then to an array, see below for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>info</code></td>
<td>
<p>logical, if set to <code>TRUE</code> then the resulting image(s)
will also contain information from TIFF tags as attributes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indexed</code></td>
<td>
<p>logical, if set to <code>TRUE</code> then indexed images will be
returned in the indexed form, i.e., as a matrix of integer indices
referencing into a color map which is returned in the
<code>"color.map"</code> attribute. This flag cannot be combined with
<code>convert</code> or <code>native</code> and has no effect on images that are
not indexed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.is</code></td>
<td>
<p>logical, if <code>TRUE</code> an attempt will be made to return
the original integer values without re-scaling where possible</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>payload</code></td>
<td>
<p>logical, if <code>FALSE</code> then only metadata about the
image(s) is returned, but not the actual image. Implies
<code>info=TRUE</code> and all image-related flags are ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Most common files decompress into RGB (3 channels), RGBA (4 channels),
Grayscale (1 channel) or GA (2 channels). Note that G and GA images
cannot be directly used in <code>rasterImage</code> unless
<code>native</code> is set to <code>TRUE</code> because <code>rasterImage</code> requires
RGB or RGBA format (<code>nativeRaster</code> is always 8-bit RGBA).
</p>
<p>TIFF images can have a wide range of internal representations, but only
the most common in image processing are directly supported (8-bit, 16-bit
integer and 32-bit float samples). Other formats (color maps, sub-8-bit
images, etc.) are only supported via <code>convert=TRUE</code> which uses the
built-in facilities of the TIFF library to convert the image into RGBA
format with 8-bit samples (i.e. total of 32-bit per pixel) and then
store the relevant components from there into real arrays. This is the
same path as used by <code>native=TRUE</code> and so differs only in the
output value. Note that conversion may result in different values than
direct acccess as it is intended mainly for viewing and not computation.
</p>


<h3>Value</h3>

<p>If <code>native</code> is <code>FALSE</code> then an array of the dimensions height
x width x channels. If there is only one channel the result is a
matrix. The values are reals between 0 and 1 (except for 32-bit floating
point sample storage which are unscaled reals, and for indexed and
<code>as.is=TRUE</code> which are integers). If <code>native</code> is
<code>TRUE</code> then an object of the class <code>nativeRaster</code> is
returned instead. The latter cannot be easily computed on but is the
most efficient way to draw using <code>rasterImage</code>.
</p>
<p>If <code>all</code> is <code>TRUE</code> or a vector of image indices,
then the result is a list of the above with
zero or more elements. If <code>all</code> is a vector of indices, the result
will have exactly the same length as <code>all</code>. If an index does not
appear in the file, the corresponding list entry will be <code>NULL</code>.
</p>
<p>If <code>payload=FALSE</code> then the result is equivalent to
<code>info=TRUE</code> but without the image data and returned as a data frame.
If <code>all</code> is either <code>TRUE</code> or a vector then the result will
be a data frame with each row corresponding to one image.
</p>


<h3>Note</h3>

<p>Some non-standard formats such as 12-bit TIFFs are partially supported
(there is no standard for packing order for TIFFs beoynd 8-bit so we
assume big-endian packing similar to the default fill order and only
support single channel or indexed).
</p>
<p>The <code>as.is=TRUE</code> option is experimental, cannot be used with
<code>native</code> or <code>convert</code> and only works for integer storage
TIFFs.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
Kent Johnson
</p>


<h3>See Also</h3>

<p><code>rasterImage</code>, <code>writeTIFF</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">Rlogo &lt;- system.file("img", "Rlogo.tiff", package="tiff")

# read a sample file (R logo)
img &lt;- readTIFF(Rlogo)

# read it also in native format
img.n &lt;- readTIFF(Rlogo, native=TRUE)

# and also in converted
img.c &lt;- readTIFF(Rlogo, convert=TRUE)

# read all contained images
str(readTIFF(Rlogo, all=TRUE))

# pick some images
str(readTIFF(Rlogo, all=c(5, 1, 3)))

# only show information
str(readTIFF(Rlogo, payload=FALSE))

# if your R supports it, we'll plot it
if (exists("rasterImage")) { # can plot only in R 2.11.0 and higher
  plot(1:2, type='n')

  if (names(dev.cur()) == "windows") {
    # windows device doesn't support semi-transparency so we'll need
    # to flatten the image
    transparent &lt;- img[,,4] == 0
    img &lt;- as.raster(img[,,1:3])
    img[transparent] &lt;- NA

    # interpolate must be FALSE on Windows, otherwise R will
    # try to interpolate transparency and fail
    rasterImage(img, 1.2, 1.27, 1.8, 1.73, interpolate=FALSE)

  } else {
    # any reasonable device will be fine using alpha
    rasterImage(img, 1.2, 1.27, 1.8, 1.73)
    rasterImage(img.n, 1.5, 1.5, 1.9, 1.8)
  }
}
</code></pre>


</div>