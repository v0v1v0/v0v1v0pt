<div class="container">

<table style="width: 100%;"><tr>
<td>ops_nms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Performs non-maximum suppression (NMS) on the boxes</h2>

<h3>Description</h3>

<p>Performs non-maximum suppression (NMS) on the boxes according to their
intersection-over-union (IoU).
</p>


<h3>Usage</h3>

<pre><code class="language-R">ops_nms(boxes, scores, iou_threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>boxes</code></td>
<td>
<p><code>Tensor[N,4]</code> boxes to perform NMS on. They are expected to be
in <code style="white-space: pre;">⁠(x1, y1, x2, y2)⁠</code> format with <code style="white-space: pre;">⁠0 &lt;= x1 &lt; x2⁠</code> and <code style="white-space: pre;">⁠0 &lt;= y1 &lt; y2⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scores</code></td>
<td>
<p><code>Tensor[N]</code> scores for each one of the boxes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iou_threshold</code></td>
<td>
<p><code>float</code> discards all overlapping boxes with <code>IoU &gt; iou_threshold</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>NMS iteratively removes lower scoring boxes which have an IoU greater than
<code>iou_threshold</code> with another (higher scoring) box.
</p>
<p>If multiple boxes have the exact same score and satisfy the IoU criterion with
respect to a reference box, the selected box is not guaranteed to be the same
between CPU and GPU. This is similar to the behavior of argsort in PyTorch
when repeated values are present.
</p>


<h3>Value</h3>

<p>int64 tensor with the indices of the elements that have been kept by NMS,
sorted in decreasing order of scores
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torchvisionlib_is_installed()) {
  ops_nms(torch::torch_rand(3, 4), torch::torch_rand(3), 0.5)
}
</code></pre>


</div>