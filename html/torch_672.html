<div class="container">

<table style="width: 100%;"><tr>
<td>torch_searchsorted</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Searchsorted</h2>

<h3>Description</h3>

<p>Searchsorted
</p>


<h3>Usage</h3>

<pre><code class="language-R">torch_searchsorted(
  sorted_sequence,
  self,
  out_int32 = FALSE,
  right = FALSE,
  side = NULL,
  sorter = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sorted_sequence</code></td>
<td>
<p>(Tensor) N-D or 1-D tensor, containing monotonically increasing
sequence on the <em>innermost</em> dimension.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>self</code></td>
<td>
<p>(Tensor or Scalar) N-D tensor or a Scalar containing the search value(s).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>out_int32</code></td>
<td>
<p>(bool, optional) – indicate the output data type. <code>torch_int32()</code>
if True, <code>torch_int64()</code> otherwise. Default value is FALSE, i.e. default output
data type is <code>torch_int64()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>right</code></td>
<td>
<p>(bool, optional) – if False, return the first suitable location
that is found. If True, return the last such index. If no suitable index found,
return 0 for non-numerical value (eg. nan, inf) or the size of boundaries
(one pass the last index). In other words, if False, gets the lower bound index
for each value in input from boundaries. If True, gets the upper bound index
instead. Default value is False.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>
<p>the same as right but preferred. “left” corresponds to <code>FALSE</code> for right
and “right” corresponds to <code>TRUE</code> for right. It will error if this is set to
“left” while right is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sorter</code></td>
<td>
<p>if provided, a tensor matching the shape of the unsorted <code>sorted_sequence</code>
containing a sequence of indices that sort it in the ascending order on the
innermost dimension.</p>
</td>
</tr>
</table>
<h3>searchsorted(sorted_sequence, values, *, out_int32=FALSE, right=FALSE, out=None) -&gt; Tensor </h3>

<p>Find the indices from the <em>innermost</em> dimension of <code>sorted_sequence</code> such that, if the
corresponding values in <code>values</code> were inserted before the indices, the order of the
corresponding <em>innermost</em> dimension within <code>sorted_sequence</code> would be preserved.
Return a new tensor with the same size as <code>values</code>. If <code>right</code> is FALSE (default),
then the left boundary of <code>sorted_sequence</code> is closed.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {

sorted_sequence &lt;- torch_tensor(rbind(c(1, 3, 5, 7, 9), c(2, 4, 6, 8, 10)))
sorted_sequence
values &lt;- torch_tensor(rbind(c(3, 6, 9), c(3, 6, 9)))
values
torch_searchsorted(sorted_sequence, values)
torch_searchsorted(sorted_sequence, values, right=TRUE)
sorted_sequence_1d &lt;- torch_tensor(c(1, 3, 5, 7, 9))
sorted_sequence_1d
torch_searchsorted(sorted_sequence_1d, values)
}
</code></pre>


</div>