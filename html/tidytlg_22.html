<div class="container">

<table style="width: 100%;"><tr>
<td>nested_freq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate nested count/percent for two or three levels</h2>

<h3>Description</h3>

<p>This will call <code>freq()</code> multiple times and combine the levels together. This
is useful for adverse event and concomitant mediations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nested_freq(
  df,
  denom_df = df,
  colvar = NULL,
  tablebyvar = NULL,
  rowvar = NULL,
  rowbyvar = NULL,
  statlist = getOption("tidytlg.nested_freq.statlist.default"),
  decimal = 1,
  cutoff = NULL,
  cutoff_stat = "pct",
  subset = TRUE,
  descending_by = NULL,
  display_missing = FALSE,
  rowtext = NULL,
  row_header = NULL,
  .keep = TRUE,
  .ord = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>(required) dataframe containing the two levels to summarize</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>denom_df</code></td>
<td>
<p>(optional) dataframe containing records to use as the
denominator (default = df)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colvar</code></td>
<td>
<p>(required) treatment variable within df to use to summarize</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tablebyvar</code></td>
<td>
<p>(optional) repeat entire table by variable within df.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowvar</code></td>
<td>
<p>(required) nested levels separated by a star, for example
AEBODSYS*AEDECOD,  this can handle up to three levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowbyvar</code></td>
<td>
<p>(optional) repeat <code>rowvar</code> by variable within df</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>statlist</code></td>
<td>
<p>(optional) count/percent type to return (default = "n (x.x)")</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decimal</code></td>
<td>
<p>(optional) decimal precision root level (default = 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff</code></td>
<td>
<p>(optional) numeric value used to cut the data to a percentage
threshold, if any column meets the threshold the entire record is kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff_stat</code></td>
<td>
<p>(optional) The value to cutoff by, n or pct. (default =
'pct')</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>(optional) An R expression that will be passed to a
<code>dplyr::filter()</code> function to subset the data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>descending_by</code></td>
<td>
<p>(optional) The column or columns to sort descending
values by. Can also provide a named list to do ascending order. ex.
c("VarName1" = "asc", "VarName2" = "desc") would sort by VarName1 in
ascending order and VarName2 in descending order. If not provided, the
columns will be sorted alphabetically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>display_missing</code></td>
<td>
<p>(optional) Should the "missing" values be displayed?
(default = FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rowtext</code></td>
<td>
<p>(optional) A character vector used to rename the <code>label</code>
column. If named, names will give the new level and values will be the
replaced value. If unnamed, and the table has only one row, the <code>rowtext</code>
will rename the <code>label</code> of the row.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_header</code></td>
<td>
<p>(optional) A character vector to be added to the table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.keep</code></td>
<td>
<p>(optional) Should the <code>rowbyvar</code> and <code>tablebyvar</code> be output in the
table.  If FALSE, <code>rowbyvar</code> will still be output in the <code>label</code> column.
(default = TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.ord</code></td>
<td>
<p>Should the ordering columns be output with the table? This is
useful if a table needs to be merged or reordered in any way after build.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>(optional) Named arguments to be included as columns on the table.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A dataframe of nested results by <code>colvar</code> and optional <code>tablebyvar</code>.
There are a few additional variable sets added to support multiple
requirements. <br><br> The level variables (<code>level1_</code>, <code>level2_</code>,
<code>level3_</code>) will carry down the counts for each level to every record.  This
allows for easy sorting of nested groups. <br><br> The header variables
(<code>header1</code>, <code>header2</code>, <code>header3</code>) will flag the header for each level to
ensure each level header is sorted to the top of the level. <br><br> The n
variables ("n_<em>") provide a numeric variable containing frequency for each
<code>colvar</code>.  This can be used to sort and filter records. <br><br> The pct
variables ("pct_</em>") provide a numeric variable containing percentages for
each <code>colvar</code>.  This can be used to sort and filter records.<br><br></p>


<h3>Examples</h3>

<pre><code class="language-R">adae &lt;- data.frame(
      SITEID = c("100", "100", "100","200", "200", "200"),
      USUBJID = c("Demo1-101", "Demo1-102", "Demo1-103",
                  "Demo1-104", "Demo1-105", "Demo1-106"),
      AEBODSYS = c("Cardiac disorders", "Cardiac disorders",
                   "Respiratory, thoracic and mediastinal disorders",
                   "Infections and infestations",
                   "Skin and subcutaneous tissue disorders",
                   "Infections and infestations"),
      AEDECOD = c("Arrhythmia supraventricular", "Cardiac failure",
                  "Chronic obstructive pulmonary disease", "Pneumonia",
                  "Pustular psoriasis", "Upper respiratory tract infection"),
      colnbr = structure(
        c(1L, 2L, 3L, 1L,  2L, 3L),
        .Label = c("Active", "Placebo", "Comparator"),
        class = "factor"
      )
    )

# Frequency and percent for two levels of nesting
nested_freq(adae
           ,colvar = "colnbr"
           ,rowvar = "AEBODSYS*AEDECOD"
           ,statlist = statlist("n (x.x%)"))

# Frequency and percent for three levels of nesting (for illustrative
# purpose)
nested_freq(adae
           ,colvar = "colnbr"
          ,rowvar = "SITEID*AEBODSYS*AEDECOD"
           ,statlist = statlist("n (x.x%)"))

# Cut records where pct meets threshold for a any column
nested_freq(cdisc_adae
            ,colvar = "TRTA"
            ,rowvar = "AEBODSYS*AEDECOD"
            ,statlist = statlist("n (x.x%)", distinct = TRUE)
            ,cutoff = 2
            ,cutoff_stat = "n")

# Cut records where pct meets threshold for a specific column
nested_freq(cdisc_adae
            ,rowvar = "AEBODSYS*AEDECOD"
            ,colvar = "TRTAN"
            ,statlist = statlist("n (x.x%)", distinct = TRUE)
            ,cutoff = "54 &gt;= 2"
            ,cutoff_stat = "n")

# Frequency and percent for two levels of nesting and sort by descending
# active
nested_freq(adae
            ,colvar = "colnbr"
            ,rowvar = "AEBODSYS*AEDECOD"
            ,statlist = statlist("n (x.x%)")
            ,descending = "Active")

# Below illustrates how make the same calls to nested_freq() as above, using
# table and # column metadata along with generate_results().

column_metadata &lt;- tibble::tribble(
 ~tbltype, ~coldef,   ~decode,
 "type1",     "1", "Placebo",
 "type1",     "2",     "Low",
 "type1",     "3",    "High"
)

# Frequency and percent for two levels of nesting
table_metadata &lt;- tibble::tribble(
 ~anbr,         ~func,    ~df,       ~rowvar, ~tbltype,  ~colvar, ~statlist,
 "1", "nested_freq", "cdisc_adae", "AEBODSYS*AEDECOD",  "type1",  "TRTP",
 statlist("n (x.x%)")
)
#generate_results(table_metadata,
#column_metadata_file = tidytlg_metadata(path)


# Frequency and percent for three levels of nesting (for illustrative purpose)
table_metadata &lt;- tibble::tribble(
 ~anbr,         ~func,    ~df,                 ~rowvar, ~tbltype,  ~colvar,
 ~statlist,
 "1", "nested_freq", "cdisc_adae", "SITEID*AEBODSYS*AEDECOD","type1",
 "TRTP", statlist("n (x.x%)")
)
# Commented out because it takes too long
# generate_results(table_metadata, column_metadata)

#Cut records where pct meets threshold for a any column
column_metadata &lt;- tibble::tribble(
 ~tbltype, ~coldef,   ~decode,
 "type2",     "1", "Placebo",
 "type2",     "2",  "Active"
)
table_metadata &lt;- tibble::tibble(
 anbr = "1", func = "nested_freq", df= "cdisc_adae",
 rowvar = "AEBODSYS*AEDECOD",
 tbltype = "type2", colvar = "TRTP", statlist = statlist("n (x.x%)"),
 dotdotdot = "cutoff = 5"
)
#generate_results(table_metadata,
# column_metadata_file = tidytlg_metadata(path)

# Cut records where pct meets threshold for a specific column
table_metadata &lt;- tibble::tibble(
 anbr = "1", func = "nested_freq", df= "cdisc_adae",
 rowvar = "AEBODSYS*AEDECOD",
 tbltype = "type2", colvar = "TRTP", statlist = statlist("n (x.x%)"),
 dotdotdot = "cutoff = 'col1 &gt;= 5'"
)
#generate_results(table_metadata,
#column_metadata_file = tidytlg_metadata(path)

# Frequency and percent for two levels of nesting and sort by descending col1
table_metadata &lt;- tibble::tibble(
 anbr = "1", func = "nested_freq", df= "cdisc_adae",
 rowvar = "AEBODSYS*AEDECOD",
 tbltype = "type2", colvar = "TRTP", statlist = statlist("n (x.x%)"),
 dotdotdot = "descending = 'col1'"
)
#generate_results(table_metadata,
#column_metadata_file = tidytlg_metadata(path)
</code></pre>


</div>