<div class="container">

<table style="width: 100%;"><tr>
<td>getResults</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Functions to print and return parts of the object returned
by the fitting routines. </h2>

<h3>Description</h3>

<p>Functions to print and return parts of the object returned
by <code>fitModel</code>.  <code>onls</code> returns the output of the
<code>nls</code>
function.  <code>sumonls</code> returns the result of calling <code>summary</code>
on <code>onls</code> function.  <code>parEst</code> returns a summary of model
parameter estimates.  The remaining functions return lists
representing various aspects of the results returned by the function
fitModel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">onls(result)
sumnls(result)
parEst(result, param = "", dataset = NA, verbose = TRUE, file="",
 stderr=TRUE)
getXList(result, group = vector(), file="")
getCLPList(result, getclperr = FALSE, file="")
getX(result, group = vector(), dataset=1, file="", lreturnA = FALSE, lreturnC = FALSE)
getC(result, dataset=1, file="")
getCLP(result, getclperr = FALSE, dataset=1, file="")
getDAS(result, getclperr = FALSE, dataset=1, file="")
getData(result, dataset = 1, weighted = FALSE)
getResiduals(result, dataset = 1)
getSVDResiduals(result, numsing = 2, dataset = 1)
getTraces(result, dataset = 1, file="")
getdim1(result, dataset = 1)
getdim2(result, dataset = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>result</code></td>
<td>
<p>return value of <code>fitModel</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>character vector of the particular parameters to return;
if <code>param==""</code> then all parameters are given. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dataset</code></td>
<td>
<p>index of the dataset from which to return results; by
default <code>dataset=NA</code> in which case results from all datasets
are returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>logical that defaults to <code>TRUE</code> that determines
whether <code>parEst</code> just returns a list invisibly or prints as well. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>getclperr</code></td>
<td>
<p>logical that defaults to <code>FALSE</code> that determines
whether a list containing the standard error estimates associated with
the conditionally linear parameters, as opposed to the conditionally
linear parameters themselves</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numsing</code></td>
<td>
<p>integer that defaults to 2; determines the number of
singular vectors to return</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>logical indicating whether to return weighted or
unweighted data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lreturnA</code></td>
<td>
<p>logical indicating whether to return an A matrix instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lreturnC</code></td>
<td>
<p>logical indicating whether to return a C matrix instead</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>character vector; if not <code>""</code> writes the results to a
file with name <code>file</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>group</code></td>
<td>
<p>The value at which to determine the X matrix (maybe a
wavelength index, for example)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stderr</code></td>
<td>
<p>Whether to return standard error estimates on parameters,
if they were calculated in fitting.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>sumnls</code> returns an object of class <code>"summary.nls"</code>.
</p>
<p><code>onls</code> returns an object of class <code>"nls"</code>.
</p>
<p><code>parEst</code> returns an object of class <code>"list"</code> representing
the parameter estimates and the standard errors if <code>stderr=TRUE</code>
and they have been calculated.
</p>
<p><code>getXList</code> returns a <code>"list"</code> of length equal to the number of
datasets modeled, where each element represents the matrix determined
by the nonlinear parameters (under a kinetic model, the concentrations).
</p>
<p><code>getCLPList</code> returns a <code>"list"</code> of length equal to the number of
datasets modeled, where each element represents the matrix determined
as conditionally linear parameters (under a kinetic model, the spectra).
</p>
<p><code>getX</code> returns a numeric <code>"matrix"</code>
that represents the matrix determined
by the nonlinear parameters (under a kinetic model, the concentrations).
However, in case lreturnC = TRUE it returns the C matrix, and in case
lreturnA = TRUE it returns the A matrix that is used to compute
the C matrix in case the kinetic model differs from parallel decays.
</p>
<p><code>getC</code> returns (under a kinetic model) a numeric <code>"matrix"</code>
that represents the raw matrix of concentrations of the dataset determined
by the nonlinear parameters.
</p>
<p><code>getDAS</code> returns (under a kinetic model) a numeric <code>"matrix"</code>
that represents the Decay Associated Spectra (DAS).
</p>
<p><code>getCLPList</code> returns a numeric <code>"matrix"</code>
that represents the matrix determined
as conditionally linear parameters (under a kinetic model, the spectra).
</p>
<p><code>getSVDData</code>
returns a <code>"list"</code> of length 3 with named elements
<code>values</code>, <code>left</code> and <code>right</code>, where  <code>values</code>
contains the singular values, <code>left</code> contains <code>numsing</code>
left singular vectors, and  <code>right</code> contains <code>numsing</code>
right singular vectors, all of the unweighted data. The number of singular
vectors returned is determined by <code>numsing</code>.
</p>
<p><code>getData</code> returns the dataset specified by the
argument <code>dataset</code> (weighted data in the case
that <code>weighted=TRUE</code>) as a <code>"matrix"</code>
</p>
<p><code>getResiduals</code> returns a <code>"matrix"</code> of residuals for the
dataset with index given by the argument <code>dataset</code>; the matrix
returned has the dimension of the dataset itself.
</p>
<p><code>getSVDResiduals</code>
returns a <code>"list"</code> of length 3 with named elements
<code>values</code>, <code>left</code> and <code>right</code>, where  <code>values</code>
contains the singular values, <code>left</code> contains <code>numsing</code>
left singular vectors, and  <code>right</code> contains <code>numsing</code>
right singular vectors, all of the residuals. The number of singular
vectors returned is determined by <code>numsing</code>.
</p>
<p><code>getTraces</code>  returns a <code>"matrix"</code> of model estimates for the
dataset with index given by the argument <code>dataset</code>; the matrix
returned has the dimension of the dataset itself.
</p>
<p><code>getdim1</code>  returns a <code>"vector"</code> of
<code>x</code> values in the dataset (times for kinetic models).
</p>
<p><code>getdim2</code>  returns a  <code>"vector"</code> of
<code>x2</code> values (wavelengths for kinetic models).
</p>


<h3>Author(s)</h3>

<p>Katharine M. Mullen, Ivo H. M. van Stokkum</p>


<h3>See Also</h3>

 <p><code>fitModel</code> </p>


<h3>Examples</h3>

<pre><code class="language-R">


## Example showing the addition of non-negativity constraints to
## conditionally linear parameters (here the spectra associated with
## a kinetic model)

## For the 1st simulated dataset, the constraints offer a modest improvement
## in the estimated spectra, whereas for the 2nd simulated dataset, they
## prevent a catastrophe in which the estimated components are hugely
## compensating.

##############################
## load TIMP
##############################

require(TIMP)

##############################
## set random seed for reproducability of noise
##############################

set.seed(80)

##############################
## SIMULATE DATA, noise realization 1
##############################

 dt4 &lt;- simndecay_gen(kinpar = c(.4, .8, 2), seqmod = FALSE, tmax
     = 2, deltat = .04, specpar = list(c(25000, 3000, .01), c(22000,
     3000, .01), c(18000, 3000, .01)), lmin=350, lmax=550, deltal = 2,
     sigma=.01)

##############################
## SPECIFY INITIAL MODEL
##############################

mod1 &lt;- initModel(mod_type = "kin", kinpar = c(.4, .8, 2),
seqmod=FALSE)

##############################
## FIT INITIAL MODEL
##############################

sT &lt;- fitModel(list(dt4), list(mod1), opt=kinopt(iter=50, plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have some negative values
##############################

sTcp &lt;- getCLP(sT)

## plot the estimated spectra with the values used in
## simulation  (before adding noise) for comparison
 matplot(dt4@x2, sTcp, xlab = "wavelength (nm)", col = 2:4, type="l",
        ylab="",lty=1, main =
        paste("Estimated spectra, adding no constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)


##############################
## FIT INITIAL MODEL
## adding constraints to non-negativity of the
## spectra via the opt option nnls=TRUE
##############################

sV &lt;- fitModel(list(dt4), list(mod1), opt=kinopt(iter=50, nnls=TRUE,
                                        plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have no negative values
##############################

sVcp &lt;- getCLP(sV)

## plot the estimated spectra with the values used in
## simulation  (before adding noise) for comparison
 matplot(dt4@x2, sVcp, xlab = "wavelength (nm)", col = 2:4, type="l",
 ylab="",lty=1,
         main = paste("Estimated spectra, with non-negativity constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)

##############################
## SIMULATE DATA, noise realization 2
##############################

 dt4_2 &lt;- simndecay_gen(kinpar = c(.4, .8, 2), seqmod = FALSE, tmax
     = 2, deltat = .04, specpar = list(c(25000, 3000, .01), c(22000,
     3000, .01), c(18000, 3000, .01)), lmin=350, lmax=550, deltal = 2,
     sigma=.01)

##############################
## SPECIFY INITIAL MODEL
##############################

mod1 &lt;- initModel(mod_type = "kin", kinpar = c(.4, .8, 2),
seqmod=FALSE)

##############################
## FIT INITIAL MODEL
##############################

sT &lt;- fitModel(list(dt4_2), list(mod1), opt=kinopt(iter=50,plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have some negative values
##############################

sTcp &lt;- getCLP(sT)

## plot the estimated spectra with the values used in
## simulation (before adding noise) for comparison
 matplot(dt4@x2, sTcp, xlab = "wavelength (nm)", col = 2:4, type="l",
        ylab="",lty=1, main =
        paste("Estimated spectra, adding no constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)

##############################
## FIT INITIAL MODEL
## adding constraints to non-negativity of the
## spectra via the opt option nnls=TRUE
##############################

sV &lt;- fitModel(list(dt4_2), list(mod1), opt=kinopt(iter=50, nnls=TRUE,
                                          plot=FALSE))

##############################
## EXTRACT ESTIMATED SPECTRA
## these spectra have no negative values
##############################

sVcp &lt;- getCLP(sV)

## plot the estimated spectra with the values used in
## simulation (before adding noise) for comparison
 matplot(dt4@x2, sVcp, xlab = "wavelength (nm)", col = 2:4, type="l",
 ylab="",lty=1,
         main = paste("Estimated spectra, with non-negativity constraints\n"))
 matplot(dt4@x2,dt4@E2, add=TRUE, type="l", col=1, lty=2)
 abline(0,0)

 # end donttest

##############################
## CLEANUP GENERATED FILES
##############################
# This removes the files that were generated in this example
# (do not run this code if you wish to inspect the output)
file_list_cleanup = c(Sys.glob("*paramEst.txt"), Sys.glob("*.ps"), Sys.glob("Rplots*.pdf"))

# Iterate over the files and delete them if they exist
for (f in file_list_cleanup) {
  if (file.exists(f)) {
    unlink(f)
  }
}


</code></pre>


</div>