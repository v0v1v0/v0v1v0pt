<div class="container">

<table style="width: 100%;"><tr>
<td>tpc.cons.intern</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Utility for Conservative and Majority Rule in tpc</h2>

<h3>Description</h3>

<p>Like <code>pcalg::pc.cons.intern</code>, but takes into account the
user-specified partial node/variable ordering.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tpc.cons.intern(
  sk,
  suffStat,
  indepTest,
  alpha,
  version.unf = c(NA, NA),
  maj.rule = FALSE,
  forbEdges = NULL,
  tiers = NULL,
  context.all = NULL,
  context.tier = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sk</code></td>
<td>
<p>A skeleton object as returned from <code>pcalg::skeleton</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>Sufficient statistic: List containing all relevant elements for
the conditional independence decisions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>Pre-defined <code>function</code> for testing conditional
independence. The function is internally called as <code>indepTest(x,y,S,suffStat)</code>,
and tests conditional independence of <code>x</code> and <code>y</code> given <code>S</code>.
Here, <code>x</code> and <code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their (integer) column positions in the
adjacency matrix). The return value of <code>indepTest</code> is the p-value of the test for
conditional independence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Significance level for the individual conditional independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>version.unf</code></td>
<td>
<p>Vector of length two. If <code>version.unf[2]==1</code>, the inititial
separating set found by the PC/FCI algorithm is added to the set of separating sets;
if <code>version.unf[2]==2</code>, it is not added. In the latter case, if the set of
separating sets is empty, the triple is marked as unambiguous if <code>version.unf[1]==1</code>,
and as ambiguous if <code>version.unf[1]==2</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maj.rule</code></td>
<td>
<p>Logical indicating if the triples are checked for ambiguity using the
majority rule idea, which is less strict than the standard conservative method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forbEdges</code></td>
<td>
<p>A logical matrix of dimension <code>p*p</code>. If <code>[i,j]</code> is TRUE,
then the directed edge <code>i -&gt; j</code> is forbidden. If both <code>[i,j]</code> and <code>[j,i]</code>
are TRUE, then any type of edge between <code>i</code> and <code>j</code> is forbidden.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiers</code></td>
<td>
<p>Numeric vector specifying the tier / time point for each variable.
A smaller number corresponds to an earlier tier / time point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>context.all</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or names
of global context variables. Global context variables have no incoming edges,
i.e. no parents, and are themselves parents of all non-context variables in the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>context.tier</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or names of
tier-specific context variables. Tier-specific context variables have no incoming edges,
i.e. no parents, and are themselves parents of all non-context variables in the same tier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical asking for detailed output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>pcalg::pc.cons.intern</code> for further information on the
majority and conservative approaches to learning v-structures.
</p>
<p>Specifying a tier for each variable using the <code>tier</code> argument has the
following effects:
</p>
<p>1) Only those triples <code>x-y-z</code> are considered as potential v-structures that
satisfy <code>t(y)=max(t(x),t(z))</code>. This allows for three constellations: either <code>y</code> is
in the same tier as <code>x</code> and both are later than <code>z</code>, or <code>y</code> is in the same tier as z
and both are later than <code>x</code>, or all three are in the same tier. Triples where <code>y</code> is
earlier than one or both of <code>x</code> and <code>z</code> need not be considered, as <code>y</code> being a
collider would be against the partial ordering. Triples where <code>y</code> is later than
both <code>x</code> and <code>z</code> will be oriented later in the pc algorithm and are left out here to
minimize the number of conditional independence tests.
</p>
<p>2) Conditional independence testing is restricted such that if <code>x</code> is in tier <code>t(x)</code>
and <code>y</code> is in <code>t(y)</code>, only those variables are allowed in the conditioning set whose
tier is not larger than <code>t(x)</code>.
</p>
<p>Context variables specified via <code>context.all</code> or <code>context.tier</code> are
not considered as candidate colliders or candidate parents of colliders.
</p>


<h3>Value</h3>


<dl>
<dt>unfTripl</dt>
<dd>
<p>numeric vector of triples coded as numbers (via <code>pcalg::triple2numb</code>)
that were marked as ambiguous.</p>
</dd>
<dt>sk</dt>
<dd>
<p>The updated skeleton-object (separating sets might have been updated).</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Original code by Markus Kalisch and Diego Colombo. Modifications by Janine Witte.
</p>


</div>