<div class="container">

<table style="width: 100%;"><tr>
<td>Weighted sum</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Weighted sum</h2>

<h3>Description</h3>

<p>Computes the Hadamard product between two matrices
</p>


<h3>Usage</h3>

<pre><code class="language-R">Sum(a = 1, A, b = 1, B, IDrowA, IDrowB,
    IDcolA = NULL, IDcolB = NULL,
    make.dimnames = FALSE, drop = TRUE, 
    inplace = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>(numeric) A constant to multiply the first matrix by</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(numeric) Numeric matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>(numeric) A constant to multiply the second matrix by</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>(numeric) Numeric matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDrowA</code></td>
<td>
<p>(integer/character) Vector of length <i>m</i> with either indices or row names mapping from rows of <code>A</code> into the resulting Hadamard product. If 'missing', it is assumed to be equal to <code>1,...,nrow(A)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDrowB</code></td>
<td>
<p>(integer/character) Vector of length <i>m</i> with either indices or row names mapping from rows of <code>B</code> into the resulting Hadamard product. If 'missing', it is assumed to be equal to <code>1,...,nrow(B)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDcolA</code></td>
<td>
<p>(integer/character) (Optional) Similar to <code>IDrowA</code>, vector of length <i>n</i> for columns. If <code>NULL</code>, it is assumed to be equal to <code>IDrowA</code> if 
<i>m=n</i></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDcolB</code></td>
<td>
<p>(integer/character) (Optional) Similar to <code>IDrowB</code>, vector of length <i>n</i> for columns. If <code>NULL</code>, it is assumed to be equal to <code>IDrowB</code> if
<i>m=n</i></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Either <code>TRUE</code> or <code>FALSE</code> to whether return a uni-dimensional vector when output is a matrix with either 1 row or 1 column as per the <code>rows</code> and <code>cols</code> arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.dimnames</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether add <code>rownames</code> and <code>colnames</code> attributes to the output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inplace</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether operate directly on one input matrix (<code>A</code> or <code>B</code>) when this is used as is (i.e., is not indexed; therefore, needs to be of appropiate dimensions) in the Hadamard. When <code>TRUE</code> the output will be overwritten on the same address occupied by the non-indexed matrix. Default <code>inplace=FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes the <i>m</i> Ã— <i>n</i> weighted sum matrix between matrices 
<b>A</b> and <b>B</b>,
</p>
<p style="text-align:center"><i>a</i>(<b>R</b><sub>1</sub><b>A</b> <b>C'</b><sub>1</sub>) + <i>b</i>(<b>R</b><sub>2</sub><b>B</b> <b>C'</b><sub>2</sub>)</p>
<p>where
<b>R</b><sub>1</sub> and
<b>R</b><sub>2</sub> are incidence matrices mapping from rows of the resulting sum to rows of <b>A</b> and <b>B</b>, respectively; and 
<b>C</b><sub>1</sub> and
<b>C</b><sub>2</sub> are incidence matrices mapping from columns of the resulting sum to columns of <b>A</b> and <b>B</b>, respectively.
</p>
<p>Matrix <b>R</b><sub>1</sub><b>A</b> <b>C'</b><sub>1</sub>
can be obtained by matrix indexing as <code>A[IDrowA,IDcolA]</code>, where <code>IDrowA</code> and <code>IDcolA</code> are integer vectors whose entries are, respectively, the row and column number of 
<b>A</b> that are mapped at each row of 
<b>R</b><sub>1</sub> and 
<b>C</b><sub>1</sub>, respectively.
Likewise, matrix 
<b>R</b><sub>2</sub><b>B</b> <b>C'</b><sub>2</sub>
can be obtained as <code>B[IDrowB,IDcolB]</code>, where <code>IDrowB</code> and <code>IDcolB</code> are integer vectors whose entries are, respectively, the row and column number of 
<b>B</b> that are mapped at each row of 
<b>R</b><sub>2</sub> and 
<b>C</b><sub>2</sub>, respectively. Therefore, the weighted sum can be obtained directly as
</p>
<p style="text-align:center;font-family:courier">a*A[IDrowA,IDcolA] + b*B[IDrowB,IDcolB]</p>
<p>The function computes the Hadamard product directly from <b>A</b> and <b>B</b> without forming <b>R</b><sub>1</sub><b>A</b> <b>C'</b><sub>1</sub> or 
<b>R</b><sub>2</sub><b>B</b> <b>C'</b><sub>2</sub>
matrices. The result can be multiplied by a constant <i>a</i>.
</p>


<h3>Value</h3>

<p>Returns a matrix containing the Hadamard product.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  require(tensorEVD)
  
  # Generate rectangular matrices A (nrowA x ncolA) and B (nrowB x ncolB)
  nA = c(10,15)
  nB = c(12,8)
  A = matrix(rnorm(nA[1]*nA[2]), nrow=nA[1])
  B = matrix(rnorm(nB[1]*nB[2]), nrow=nB[1])
  
  # Define IDs for a Hadamard of size n1 x n2
  n = c(1000,500)
  IDrowA = sample(nA[1], n[1], replace=TRUE)
  IDrowB = sample(nB[1], n[1], replace=TRUE)
  IDcolA = sample(nA[2], n[2], replace=TRUE)
  IDcolB = sample(nB[2], n[2], replace=TRUE)
  
  a = rnorm(1)
  b = rnorm(1)
  
  K1 = Sum(a, A, b, B, IDrowA, IDrowB, IDcolA, IDcolB)
  
  # (it must equal to:)
  K2 = a*A[IDrowA,IDcolA] + b*B[IDrowB,IDcolB]
  all.equal(K1,K2)
</code></pre>


</div>