<div class="container">

<table style="width: 100%;"><tr>
<td>tune_K</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Select the number of clusters <code>K</code> in DEEM</h2>

<h3>Description</h3>

<p>Select the number of clusters <code>K</code> along with tuning parameter <code>lambda</code> through BIC in DEEM.</p>


<h3>Usage</h3>

<pre><code class="language-R">tune_K(X, seqK, seqlamb, initial = TRUE, vec_x = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>Input tensor (or matrix) list of length <code class="reqn">n</code>, where <code class="reqn">n</code> is the number of observations. Each element of the list is a tensor or matrix. The order of tensor can be any positive integer not less than 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seqK</code></td>
<td>
<p>A sequence of user-specified number of clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seqlamb</code></td>
<td>
<p>A sequence of user-specified <code>lambda</code> values. <code>lambda</code> is the weight of L1 penalty and a smaller <code>lambda</code> allows more variables to be nonzero</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial</code></td>
<td>
<p>Whether to initialize algorithm with K-means clustering. Default value is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vec_x</code></td>
<td>
<p>Vectorized tensor data. Default value is <code>NULL</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>tune_K</code> function runs <code>tune_lamb</code> function <code>length(seqK)</code> times to choose the tuning parameter <code class="reqn">\lambda</code> and number of clusters <code class="reqn">K</code> simultaneously. Let <code class="reqn">\widehat{\bm{\theta}}^{\{\lambda,K\}}</code> be the output of <code>DEEM</code> with the tuning parameter and number of clusters fixed at <code class="reqn">\lambda</code> and <code class="reqn">K</code> respectively, <code>tune_K</code> looks for the values of <code class="reqn">\lambda</code> and <code class="reqn">K</code> that minimizes
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{BIC}(\lambda,K)=-2\sum_{i=1}^n\log(\sum_{k=1}^K\widehat{\pi}^{\{\lambda,K\}}_kf_k(\mathbf{X}_i;\widehat{\bm{\theta}}_k^{\{\lambda,K\}}))+\log(n)\cdot |\widehat{\mathcal{D}}^{\{\lambda,K\}}|,</code>
</p>

<p>where <code class="reqn">\widehat{\mathcal{D}}^{\{\lambda,K\}}=\{(k, {\mathcal{J}}): \widehat b_{k,{\mathcal{J}}}^{\lambda} \neq 0 \}</code> is the set of nonzero elements in <code class="reqn">\widehat{\bm{B}}_2^{\{\lambda,K\}},\ldots,\widehat{\bm{B}}_K^{\{\lambda,K\}}</code>. The <code>tune_K</code> function intrinsically selects the initial point and return the optimal estimated labels.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>opt_K</code></td>
<td>
<p>Selected number of clusters that leads to optimal BIC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>opt_lamb</code></td>
<td>
<p>Tuned <code>lambda</code> that leads to optimal BIC.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Krank</code></td>
<td>
<p>A selection summary.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Kai Deng, Yuqing Pan, Xin Zhang and Qing Mai</p>


<h3>References</h3>

<p>Mai, Q., Zhang, X., Pan, Y. and Deng, K. (2021). A Doubly-Enhanced EM Algorithm for Model-Based Tensor Clustering. <em>Journal of the American Statistical Association</em>.</p>


<h3>See Also</h3>

<p><code>DEEM</code>, <code>tune_lamb</code></p>


<h3>Examples</h3>

<pre><code class="language-R">
dimen = c(5,5,5)
nvars = prod(dimen)
K = 2
n = 100
sigma = array(list(),3)

sigma[[1]] = sigma[[2]] = sigma[[3]] = diag(5)

B2=array(0,dim=dimen)
B2[1:3,1,1]=2

y = c(rep(1,50),rep(2,50))
M = array(list(),K)
M[[1]] = array(0,dim=dimen)
M[[2]] = B2

vec_x=matrix(rnorm(n*prod(dimen)),ncol=n)
X=array(list(),n)
for (i in 1:n){
  X[[i]] = array(vec_x[,i],dim=dimen)
  X[[i]] = M[[y[i]]] + X[[i]]
}

mytune = tune_K(X, seqK=2:4, seqlamb=seq(0.01,0.1,by=0.01))

</code></pre>


</div>