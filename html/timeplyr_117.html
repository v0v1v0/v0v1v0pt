<div class="container">

<table style="width: 100%;"><tr>
<td>time_seq</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Time based version of <code>base::seq()</code>
</h2>

<h3>Description</h3>

<p>Time based version of <code>base::seq()</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">time_seq(
  from,
  to,
  time_by,
  length.out = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  week_start = getOption("lubridate.week.start", 1),
  time_floor = FALSE,
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA")
)

time_seq_sizes(
  from,
  to,
  time_by,
  time_type = getOption("timeplyr.time_type", "auto")
)

time_seq_v(
  from,
  to,
  time_by,
  time_type = getOption("timeplyr.time_type", "auto"),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1)
)

time_seq_v2(
  sizes,
  from,
  time_by,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>Start date/datetime of sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>End date/datetime of sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_by</code></td>
<td>
<p>Time unit increment. <br>
Must be one of the three:
</p>

<ul>
<li>
<p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li>
<p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li>
<p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length.out</code></td>
<td>
<p>Length of the sequence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_type</code></td>
<td>
<p>If "auto", <code>periods</code> are used for
the time expansion when days, weeks,
months or years are specified, and <code>durations</code>
are used otherwise. If <code>durations</code>
are used the output is always of class <code>POSIXt</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to
the nearest unit specified through the <code>time_by</code>
argument? This is particularly useful for
starting sequences at the beginning of a week
or month for example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See <code>?timechange::time_add</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sizes</code></td>
<td>
<p>Time sequence sizes.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This works like <code>seq()</code>,
but using <code>timechange</code> for the period calculations and
<code>base::seq.POSIXT()</code> for the duration calculations.
In many ways it is improved over <code>seq</code> as
dates and/or datetimes can be supplied with no errors to
the start and end points.
Examples like,<br><code>time_seq(now(), length.out = 10, by = "0.5 days", seq_type = "dur")</code>
and <br><code>time_seq(today(), length.out = 10, by = "0.5 days", seq_type = "dur")</code><br>
produce more expected results compared to <br><code>seq(now(), length.out = 10, by = "0.5 days")</code> or <br><code>seq(today(), length.out = 10, by = "0.5 days")</code>.<br></p>
<p>For a vectorized implementation with multiple start/end times,
use <code>time_seq_v()</code>/<code>time_seq_v2()</code>
</p>
<p><code>time_seq_sizes()</code> is a convenience
function to calculate time sequence lengths, given start/end times.
</p>


<h3>Value</h3>

<p><code>time_seq</code> returns a time sequence. <br><code>time_seq_sizes</code> returns an integer vector of sequence sizes. <br><code>time_seq_v</code> returns time sequences. <br><code>time_seq_v2</code> also returns time sequences.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(timeplyr)
library(lubridate)

# Dates
today &lt;- today()
now &lt;- now()

time_seq(today, today + years(1), time_by = "day")
time_seq(today, length.out = 10, time_by = "day")
time_seq(today, length.out = 10, time_by = "hour")

time_seq(today, today + years(1), time_by = list("days" = 1)) # Alternative
time_seq(today, today + years(1), time_by = "week")
time_seq(today, today + years(1), time_by = "fortnight")
time_seq(today, today + years(1), time_by = "year")
time_seq(today, today + years(10), time_by = "year")
time_seq(today, today + years(100), time_by = "decade")

# Datetimes
time_seq(now, now + years(1), time_by = "12 hours")
time_seq(now, now + years(1), time_by = "day")
time_seq(now, now + years(1), time_by = "week")
time_seq(now, now + years(1), time_by = "fortnight")
time_seq(now, now + years(1), time_by = "year")
time_seq(now, now + years(10), time_by = "year")
time_seq(now, today + years(100), time_by = "decade")

# You can seamlessly mix dates and datetimes with no errors.
time_seq(now, today + days(3), time_by = "day")
time_seq(now, today + days(3), time_by = "hour")
time_seq(today, now + days(3), time_by = "day")
time_seq(today, now + days(3), time_by = "hour")

# Choose between durations or periods

start &lt;- dmy(31012020)
# If time_type is left as is,
# periods are used for days, weeks, months and years.
time_seq(start, time_by = "month", length.out = 12,
         time_type = "period")
time_seq(start, time_by = "month", length.out = 12,
         time_type = "duration")
# Notice how strange base R version is.
seq(start, by = "month", length.out = 12)

# Roll forward or backward impossible dates

leap &lt;- dmy(29022020) # Leap day
end &lt;- dmy(01032021)
# 3 different options
time_seq(leap, to = end, time_by = "year",
         roll_month = "NA")
time_seq(leap, to = end, time_by = "year",
         roll_month = "postday")
time_seq(leap, to = end, time_by = "year",
         roll_month = getOption("timeplyr.roll_month", "preday"))

</code></pre>


</div>