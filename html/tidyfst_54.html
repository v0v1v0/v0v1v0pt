<div class="container">

<table style="width: 100%;"><tr>
<td>in_dt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Short cut to data.table</h2>

<h3>Description</h3>

<p>To use facilities provided by <span class="pkg">data.table</span>, but do not have to
load <span class="pkg">data.table</span> package.
</p>


<h3>Usage</h3>

<pre><code class="language-R">in_dt(.data, ...)

as_dt(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>A data.frame</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Recieve <code>B</code> in data.table's <code>A[B]</code> syntax.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>as_dt</code> could turn any data frame to data.table class. If the data is
not a data frame, return error.
</p>
<p>The <code>in_dt</code> function creates a virtual environment in data.table, it could be
piped well because it still follows the principals of <span class="pkg">tidyfst</span>, which are: (1) Never
use in place replacement and (2) Always recieves a data frame (data.frame/tibble/data.table)
and returns a data.table. Therefore, the in place functions like <code>:=</code> will still
return the results.
</p>


<h3>See Also</h3>

<p><code>data.table</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">iris %&gt;% as_dt()
iris %&gt;% in_dt(order(-Sepal.Length),.SD[.N],by=Species)
</code></pre>


</div>