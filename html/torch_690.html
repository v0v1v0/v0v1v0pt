<div class="container">

<table style="width: 100%;"><tr>
<td>torch_sparse_coo_tensor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sparse_coo_tensor</h2>

<h3>Description</h3>

<p>Sparse_coo_tensor
</p>


<h3>Usage</h3>

<pre><code class="language-R">torch_sparse_coo_tensor(
  indices,
  values,
  size = NULL,
  dtype = NULL,
  device = NULL,
  requires_grad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>indices</code></td>
<td>
<p>(array_like) Initial data for the tensor. Can be a list, tuple,        NumPy <code>ndarray</code>, scalar, and other types. Will be cast to a <code>torch_LongTensor</code>        internally. The indices are the coordinates of the non-zero values in the matrix, and thus        should be two-dimensional where the first dimension is the number of tensor dimensions and        the second dimension is the number of non-zero values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>(array_like) Initial values for the tensor. Can be a list, tuple,        NumPy <code>ndarray</code>, scalar, and other types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>(list, tuple, or <code>torch.Size</code>, optional) Size of the sparse tensor. If not        provided the size will be inferred as the minimum size big enough to hold all non-zero        elements.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtype</code></td>
<td>
<p>(<code>torch.dtype</code>, optional) the desired data type of returned tensor.        Default: if NULL, infers data type from <code>values</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>device</code></td>
<td>
<p>(<code>torch.device</code>, optional) the desired device of returned tensor.        Default: if NULL, uses the current device for the default tensor type        (see <code>torch_set_default_tensor_type</code>). <code>device</code> will be the CPU        for CPU tensor types and the current CUDA device for CUDA tensor types.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>requires_grad</code></td>
<td>
<p>(bool, optional) If autograd should record operations on the        returned tensor. Default: <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>sparse_coo_tensor(indices, values, size=NULL, dtype=NULL, device=NULL, requires_grad=False) -&gt; Tensor </h3>

<p>Constructs a sparse tensors in COO(rdinate) format with non-zero elements at the given <code>indices</code>
with the given <code>values</code>. A sparse tensor can be <code>uncoalesced</code>, in that case, there are duplicate
coordinates in the indices, and the value at that index is the sum of all duplicate value entries:
<code>torch_sparse</code>_.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {

i = torch_tensor(matrix(c(1, 2, 2, 3, 1, 3), ncol = 3, byrow = TRUE), dtype=torch_int64())
v = torch_tensor(c(3, 4, 5), dtype=torch_float32())
torch_sparse_coo_tensor(i, v)
torch_sparse_coo_tensor(i, v, c(2, 4))

# create empty sparse tensors
S = torch_sparse_coo_tensor(
  torch_empty(c(1, 0), dtype = torch_int64()), 
  torch_tensor(numeric(), dtype = torch_float32()), 
  c(1)
)
S = torch_sparse_coo_tensor(
  torch_empty(c(1, 0), dtype = torch_int64()), 
  torch_empty(c(0, 2)), 
  c(1, 2)
)
}
</code></pre>


</div>