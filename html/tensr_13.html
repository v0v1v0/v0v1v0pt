<div class="container">

<table style="width: 100%;"><tr>
<td>get_isvd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate the incredible SVD (ISVD).</h2>

<h3>Description</h3>

<p>The ISVD is a generalization of the SVD to tensors. It is derived from the
incredible HOLQ.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_isvd(x_holq)
</code></pre>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>x_holq</code></td>
<td>
<p>The output from <code>holq</code>.</p>
</td>
</tr></table>
<h3>Details</h3>

<p>Let <code>sig * atrans(Z, L)</code> be the HOLQ of <code>X</code>. Then the ISVD
calculates the SVD of each <code>L[[i]]</code>, call it <code>U[[i]] %*% D[[i]]
%*% t(W[[i]])</code>. It then returns <code>l = sig</code>, <code>U</code>, <code>D</code>, and
<code>V = atrans(Z, W)</code>. These values have the property that <code>X</code> is
equal to <code>l * atrans(atrans(V, D), U)</code>, up to numerical precision.
<code>V</code> is also scaled all-orthonormal.
</p>
<p>For more details on the ISVD, see
<a href="https://doi.org/10.1016/j.laa.2016.04.033">Gerard and Hoff (2016)</a>.
</p>


<h3>Value</h3>

<p>l A numeric.
</p>
<p>U A list of orthogonal matrices.
</p>
<p>D A list of diagonal matrices with positive diagonal entries and unit
determinant. The diagonal entries are in descending order.
</p>
<p>V A scaled all-orthonormal array.
</p>


<h3>Author(s)</h3>

<p>David Gerard.
</p>


<h3>References</h3>

<p>Gerard, D., &amp; Hoff, P. (2016). A higher-order LQ
decomposition for separable covariance models.
<em>Linear Algebra and its Applications</em>, 505, 57-84.
<a href="https://doi.org/10.1016/j.laa.2016.04.033">https://doi.org/10.1016/j.laa.2016.04.033</a>
<a href="http://arxiv.org/pdf/1410.1094v1.pdf">http://arxiv.org/pdf/1410.1094v1.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#Generate random data.
p &lt;- c(4,4,4)
X &lt;- array(stats::rnorm(prod(p)), dim = p)

#Calculate HOLQ, then ISVD
holq_x &lt;- holq(X)
isvd_x &lt;- get_isvd(holq_x)
l &lt;- isvd_x$l
U &lt;- isvd_x$U
D &lt;- isvd_x$D
V &lt;- isvd_x$V

#Recover X
trim(X - l * atrans(atrans(V, D), U))

#V is scaled all-orthonormal
trim(mat(V, 1) %*% t(mat(V, 1)), epsilon = 10^-5)

trim(mat(V, 2) %*% t(mat(V, 2)), epsilon = 10^-5)

trim(mat(V, 3) %*% t(mat(V, 3)), epsilon = 10^-5)
</code></pre>


</div>