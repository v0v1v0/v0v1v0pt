<div class="container">

<table style="width: 100%;"><tr>
<td>tfd_gaussian_process</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Marginal distribution of a Gaussian process at finitely many points.</h2>

<h3>Description</h3>

<p>A Gaussian process (GP) is an indexed collection of random variables, any
finite collection of which are jointly Gaussian. While this definition applies
to finite index sets, it is typically implicit that the index set is infinite;
in applications, it is often some finite dimensional real or complex vector
space. In such cases, the GP may be thought of as a distribution over
(real- or complex-valued) functions defined over the index set.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tfd_gaussian_process(
  kernel,
  index_points,
  mean_fn = NULL,
  observation_noise_variance = 0,
  jitter = 1e-06,
  validate_args = FALSE,
  allow_nan_stats = FALSE,
  name = "GaussianProcess"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p><code>PositiveSemidefiniteKernel</code>-like instance representing the
GP's covariance function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index_points</code></td>
<td>
<p><code>float</code> <code>Tensor</code> representing finite (batch of) vector(s) of
points in the index set over which the GP is defined. Shape has the
form <code style="white-space: pre;">⁠[b1, ..., bB, e1, f1, ..., fF]⁠</code> where <code>F</code> is the number of feature
dimensions and must equal <code>kernel$feature_ndims</code> and <code>e1</code> is the number
(size) of index points in each batch (we denote it <code>e1</code> to distinguish
it from the numer of inducing index points, denoted <code>e2</code> below).
Ultimately the GaussianProcess distribution corresponds to an
<code>e1</code>-dimensional multivariate normal. The batch shape must be
broadcastable with <code>kernel$batch_shape</code>, the batch shape of
<code>inducing_index_points</code>, and any batch dims yielded by <code>mean_fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_fn</code></td>
<td>
<p>function that acts on index points to produce a (batch
of) vector(s) of mean values at those index points. Takes a <code>Tensor</code> of
shape <code style="white-space: pre;">⁠[b1, ..., bB, f1, ..., fF]⁠</code> and returns a <code>Tensor</code> whose shape is
(broadcastable with) <code style="white-space: pre;">⁠[b1, ..., bB]⁠</code>. Default value: <code>NULL</code> implies constant zero function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>observation_noise_variance</code></td>
<td>
<p><code>float</code> <code>Tensor</code> representing the variance
of the noise in the Normal likelihood distribution of the model. May be
batched, in which case the batch shape must be broadcastable with the
shapes of all other batched parameters (<code>kernel$batch_shape</code>, <code>index_points</code>, etc.).
Default value: <code>0.</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jitter</code></td>
<td>
<p><code>float</code> scalar <code>Tensor</code> added to the diagonal of the covariance
matrix to ensure positive definiteness of the covariance matrix. Default value: <code>1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validate_args</code></td>
<td>
<p>Logical, default FALSE. When TRUE distribution parameters are checked
for validity despite possibly degrading runtime performance. When FALSE invalid inputs may
silently render incorrect outputs. Default value: FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_nan_stats</code></td>
<td>
<p>Logical, default TRUE. When TRUE, statistics (e.g., mean, mode, variance)
use the value NaN to indicate the result is undefined. When FALSE, an exception is raised if
one or more of the statistic's batch members are undefined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>name prefixed to Ops created by this class.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Just as Gaussian distributions are fully specified by their first and second
moments, a Gaussian process can be completely specified by a mean and
covariance function.
Let <code>S</code> denote the index set and <code>K</code> the space in which
each indexed random variable takes its values (again, often R or C). The mean
function is then a map <code>m: S -&gt; K</code>, and the covariance function, or kernel, is
a positive-definite function <code style="white-space: pre;">⁠k: (S x S) -&gt; K⁠</code>. The properties of functions
drawn from a GP are entirely dictated (up to translation) by the form of the
kernel function.
</p>
<p>This <code>Distribution</code> represents the marginal joint distribution over function
values at a given finite collection of points <code style="white-space: pre;">⁠[x[1], ..., x[N]]⁠</code> from the
index set <code>S</code>. By definition, this marginal distribution is just a
multivariate normal distribution, whose mean is given by the vector
<code style="white-space: pre;">⁠[ m(x[1]), ..., m(x[N]) ]⁠</code> and whose covariance matrix is constructed from
pairwise applications of the kernel function to the given inputs:
</p>
<div class="sourceCode"><pre>| k(x[1], x[1])    k(x[1], x[2])  ...  k(x[1], x[N]) |
| k(x[2], x[1])    k(x[2], x[2])  ...  k(x[2], x[N]) |
|      ...              ...                 ...      |
| k(x[N], x[1])    k(x[N], x[2])  ...  k(x[N], x[N]) |
</pre></div>
<p>For this to be a valid covariance matrix, it must be symmetric and positive
definite; hence the requirement that <code>k</code> be a positive definite function
(which, by definition, says that the above procedure will yield PD matrices).
</p>
<p>We also support the inclusion of zero-mean Gaussian noise in the model, via
the <code>observation_noise_variance</code> parameter. This augments the generative model
to
</p>
<div class="sourceCode"><pre>f ~ GP(m, k)
(y[i] | f, x[i]) ~ Normal(f(x[i]), s)
</pre></div>
<p>where
</p>

<ul>
<li> <p><code>m</code> is the mean function
</p>
</li>
<li> <p><code>k</code> is the covariance kernel function
</p>
</li>
<li> <p><code>f</code> is the function drawn from the GP
</p>
</li>
<li> <p><code>x[i]</code> are the index points at which the function is observed
</p>
</li>
<li> <p><code>y[i]</code> are the observed values at the index points
</p>
</li>
<li> <p><code>s</code> is the scale of the observation noise.
</p>
</li>
</ul>
<p>Note that this class represents an <em>unconditional</em> Gaussian process; it does
not implement posterior inference conditional on observed function
evaluations. This class is useful, for example, if one wishes to combine a GP
prior with a non-conjugate likelihood using MCMC to sample from the posterior.
</p>
<p>Mathematical Details
</p>
<p>The probability density function (pdf) is a multivariate normal whose
parameters are derived from the GP's properties:
</p>
<div class="sourceCode"><pre>pdf(x; index_points, mean_fn, kernel) = exp(-0.5 * y) / Z
K = (kernel.matrix(index_points, index_points) +
    (observation_noise_variance + jitter) * eye(N))
y = (x - mean_fn(index_points))^T @ K @ (x - mean_fn(index_points))
Z = (2 * pi)**(.5 * N) |det(K)|**(.5)
</pre></div>
<p>where:
</p>

<ul>
<li> <p><code>index_points</code> are points in the index set over which the GP is defined,
</p>
</li>
<li> <p><code>mean_fn</code> is a callable mapping the index set to the GP's mean values,
</p>
</li>
<li> <p><code>kernel</code> is <code>PositiveSemidefiniteKernel</code>-like and represents the covariance
function of the GP,
</p>
</li>
<li> <p><code>observation_noise_variance</code> represents (optional) observation noise.
</p>
</li>
<li> <p><code>jitter</code> is added to the diagonal to ensure positive definiteness up to
machine precision (otherwise Cholesky-decomposition is prone to failure),
</p>
</li>
<li> <p><code>eye(N)</code> is an N-by-N identity matrix.
</p>
</li>
</ul>
<h3>Value</h3>

<p>a distribution instance.
</p>


<h3>See Also</h3>

<p>For usage examples see e.g. <code>tfd_sample()</code>, <code>tfd_log_prob()</code>, <code>tfd_mean()</code>.
</p>
<p>Other distributions: 
<code>tfd_autoregressive()</code>,
<code>tfd_batch_reshape()</code>,
<code>tfd_bates()</code>,
<code>tfd_bernoulli()</code>,
<code>tfd_beta_binomial()</code>,
<code>tfd_beta()</code>,
<code>tfd_binomial()</code>,
<code>tfd_categorical()</code>,
<code>tfd_cauchy()</code>,
<code>tfd_chi2()</code>,
<code>tfd_chi()</code>,
<code>tfd_cholesky_lkj()</code>,
<code>tfd_continuous_bernoulli()</code>,
<code>tfd_deterministic()</code>,
<code>tfd_dirichlet_multinomial()</code>,
<code>tfd_dirichlet()</code>,
<code>tfd_empirical()</code>,
<code>tfd_exp_gamma()</code>,
<code>tfd_exp_inverse_gamma()</code>,
<code>tfd_exponential()</code>,
<code>tfd_gamma_gamma()</code>,
<code>tfd_gamma()</code>,
<code>tfd_gaussian_process_regression_model()</code>,
<code>tfd_generalized_normal()</code>,
<code>tfd_geometric()</code>,
<code>tfd_gumbel()</code>,
<code>tfd_half_cauchy()</code>,
<code>tfd_half_normal()</code>,
<code>tfd_hidden_markov_model()</code>,
<code>tfd_horseshoe()</code>,
<code>tfd_independent()</code>,
<code>tfd_inverse_gamma()</code>,
<code>tfd_inverse_gaussian()</code>,
<code>tfd_johnson_s_u()</code>,
<code>tfd_joint_distribution_named_auto_batched()</code>,
<code>tfd_joint_distribution_named()</code>,
<code>tfd_joint_distribution_sequential_auto_batched()</code>,
<code>tfd_joint_distribution_sequential()</code>,
<code>tfd_kumaraswamy()</code>,
<code>tfd_laplace()</code>,
<code>tfd_linear_gaussian_state_space_model()</code>,
<code>tfd_lkj()</code>,
<code>tfd_log_logistic()</code>,
<code>tfd_log_normal()</code>,
<code>tfd_logistic()</code>,
<code>tfd_mixture_same_family()</code>,
<code>tfd_mixture()</code>,
<code>tfd_multinomial()</code>,
<code>tfd_multivariate_normal_diag_plus_low_rank()</code>,
<code>tfd_multivariate_normal_diag()</code>,
<code>tfd_multivariate_normal_full_covariance()</code>,
<code>tfd_multivariate_normal_linear_operator()</code>,
<code>tfd_multivariate_normal_tri_l()</code>,
<code>tfd_multivariate_student_t_linear_operator()</code>,
<code>tfd_negative_binomial()</code>,
<code>tfd_normal()</code>,
<code>tfd_one_hot_categorical()</code>,
<code>tfd_pareto()</code>,
<code>tfd_pixel_cnn()</code>,
<code>tfd_poisson_log_normal_quadrature_compound()</code>,
<code>tfd_poisson()</code>,
<code>tfd_power_spherical()</code>,
<code>tfd_probit_bernoulli()</code>,
<code>tfd_quantized()</code>,
<code>tfd_relaxed_bernoulli()</code>,
<code>tfd_relaxed_one_hot_categorical()</code>,
<code>tfd_sample_distribution()</code>,
<code>tfd_sinh_arcsinh()</code>,
<code>tfd_skellam()</code>,
<code>tfd_spherical_uniform()</code>,
<code>tfd_student_t_process()</code>,
<code>tfd_student_t()</code>,
<code>tfd_transformed_distribution()</code>,
<code>tfd_triangular()</code>,
<code>tfd_truncated_cauchy()</code>,
<code>tfd_truncated_normal()</code>,
<code>tfd_uniform()</code>,
<code>tfd_variational_gaussian_process()</code>,
<code>tfd_vector_diffeomixture()</code>,
<code>tfd_vector_exponential_diag()</code>,
<code>tfd_vector_exponential_linear_operator()</code>,
<code>tfd_vector_laplace_diag()</code>,
<code>tfd_vector_laplace_linear_operator()</code>,
<code>tfd_vector_sinh_arcsinh_diag()</code>,
<code>tfd_von_mises_fisher()</code>,
<code>tfd_von_mises()</code>,
<code>tfd_weibull()</code>,
<code>tfd_wishart_linear_operator()</code>,
<code>tfd_wishart_tri_l()</code>,
<code>tfd_wishart()</code>,
<code>tfd_zipf()</code>
</p>


</div>