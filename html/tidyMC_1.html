<div class="container">

<table style="width: 100%;"><tr>
<td>future_mc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run a Parallelized Monte Carlo Simulation</h2>

<h3>Description</h3>

<p><code>future_mc</code> runs a Monte Carlo simulation study
for a user-specified function and the
desired parameter grids.
</p>


<h3>Usage</h3>

<pre><code class="language-R">future_mc(
  fun,
  repetitions,
  param_list = NULL,
  param_table = NULL,
  parallelisation_plan = list(strategy = future::multisession),
  parallelisation_options = list(),
  check = TRUE,
  parallel = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>The function to be evaluated. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetitions</code></td>
<td>
<p>An integer that
specifies the number of Monte Carlo iterations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param_list</code></td>
<td>
<p>A list whose components are
named after the parameters of <code>fun</code> which should vary
for the different Monte Carlo Simulations.
Each component is a vector containing the desired grid
values for that parameter.
The Monte Carlo Simulation is run for all possible combinations of
that parameter list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param_table</code></td>
<td>
<p>Alternative to <code>param_list</code>.
A <code>data.frame</code> or <code>data.table</code> containing a pre-built
grid of values, where the columns are the parameters of <code>fun</code>
which should vary for the different Monte Carlo
Simulations.
This is useful if you only want to run a Monte Carlo Simulation
for a subset of all possible combinations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallelisation_plan</code></td>
<td>
<p>A list whose components are named
after possible parameters
of <code>future::plan()</code> specifying the
parallelisation plan which should be used in the
Monte Carlo Simulation. Default is <code>strategy = multisession</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallelisation_options</code></td>
<td>
<p>A list whose components are named
after possible parameters
of <code>furrr::furrr_options()</code> for fine tuning functions,
such as <code>furrr::future_map()</code>. Default is
<code>seed = TRUE</code> as long as not specified differently
in order to assure reproducibility.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check</code></td>
<td>
<p>Boolean that specifies whether a single test-iteration
should be run for each parameter
combination in order to check for possible
occuring errors in <code>fun</code>. Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel</code></td>
<td>
<p>Boolean that specifies whether
the Monte Carlo simulation should be run in parallel.
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters that are passed on to <code>fun</code>
and which are not part of the parameter
grid.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The user defined function <code>fun</code> handles
(if specified) the generation of data, the
application of the method of interest and the evaluation of the result for a
single repetition and parameter combination.
<code>future_mc</code> handles the generation of loops over the desired parameter grids
and the repetition of the Monte Carlo experiment
for each of the parameter constellations.
</p>
<p>There are four formal requirements that <code>fun</code> has to fulfill:
</p>

<ul>
<li>
<p> The arguments of <code>fun</code> which are present in <code>param_list</code>
need to be scalar values.
</p>
</li>
<li>
<p> The value returned by <code>fun</code> has to be a named list
and must have the same components for each
iteration and parameter combination.
</p>
</li>
<li>
<p> The names of the returned values and
those of the arguments contained in <code>param_list</code> need to
be different.
Moreover, they cannot be <code>"params"</code>, <code>"repetitions"</code> or <code>"setup"</code>
</p>
</li>
<li>
<p> Every variable used inside <code>fun</code> has either to be defined inside <code>fun</code>
or given as an argument through the <code>...</code> argument.
In particular, <code>fun</code> cannot use variables which are only defined
in the global environment.
</p>
</li>
</ul>
<p>In order to use the comfort functions
<code>plot.mc()</code>, <code>summary.mc()</code>, <code>plot.summary.mc()</code>, and
<code>tidy_mc_latex()</code> the value returned by <code>fun</code>
has to be a named list of scalars.
</p>


<h3>Value</h3>

<p>A list of type <code>mc</code> containing the following objects:
</p>

<ul>
<li>
<p> output: A tibble containing the return value of <code>fun</code>
for each iteration and
parameter combination
</p>
</li>
<li>
<p> parameter: A tibble which shows the different parameter combinations
</p>
</li>
<li>
<p> simple_output: A boolean value indicating
whether the return value of <code>fun</code> is a named list of
scalars or not
</p>
</li>
<li>
<p> nice_names: A character vector containing "nice names"
for the different parameter setups
</p>
</li>
<li>
<p> calculation_time: The calculation time needed
to run the whole Monte Carlo Simulation
</p>
</li>
<li>
<p> n_results: A numeric value indicating the number of results
</p>
</li>
<li>
<p> seed: The value which is used for
the parameter <code>seed</code> in <code>furrr::furrr_options()</code>
</p>
</li>
<li>
<p> fun: The user-defined function <code>fun</code>
</p>
</li>
<li>
<p> repetitions: The number of repetitions run for each parameter setup
</p>
</li>
<li>
<p> parallel: Boolean whether the Monte Carlo Simulation
was run in parallel or not
</p>
</li>
<li>
<p> plan: A list that specified the parallelisation plan via <code>future::plan()</code>
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">
test_func &lt;- function(param = 0.1, n = 100, x1 = 1, x2 = 2) {
  data &lt;- rnorm(n, mean = param) + x1 + x2
  stat &lt;- mean(data)
  stat_2 &lt;- var(data)

  if (x2 == 5) {
    stop("x2 can't be 5!")
  }

  return(list(mean = stat, var = stat_2))
}

param_list &lt;- list(
  param = seq(from = 0, to = 1, by = 0.5),
  x1 = 1:2
)

set.seed(101)
test_mc &lt;- future_mc(
  fun = test_func,
  repetitions = 1000,
  param_list = param_list,
  n = 10,
  x2 = 2
)

</code></pre>


</div>