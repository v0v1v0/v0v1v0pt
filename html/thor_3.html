<div class="container">

<table style="width: 100%;"><tr>
<td>mdb_dbi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Use mdb transactions</h2>

<h3>Description</h3>

<p>Database handles are fairly opaque objects used to indicate which
database within an <code>mdb_env</code> operations will happen
to.  This object has therefore got very few methods, all of which
are purely informative.  Most commonly, a <code>mdb_dbi</code> object
will be passed into the <code>mdb_env</code>'s <code>$begin()</code>
method to begin a transaction on a particular database.
</p>


<h3>Methods</h3>


<dl>
<dt><code>path</code></dt>
<dd>
<p>Return the absolute path to the LMDB store (on disk)
</p>
<p><em>Usage:</em>
<code>path()</code>
</p>
<p><em>Value</em>:
A string
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_path()</code>
</p>
</dd>
<dt><code>flags</code></dt>
<dd>
<p>Return flags as used in construction of the LMDB environment
</p>
<p><em>Usage:</em>
<code>flags()</code>
</p>
<p><em>Value</em>:
A named logical vector.  Names correspond to arguments to the constructor.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_flags()</code>
</p>
</dd>
<dt><code>info</code></dt>
<dd>
<p>Brief information about the LMDB environment
</p>
<p><em>Usage:</em>
<code>info()</code>
</p>
<p><em>Value</em>:
An integer vector with elements <code>mapsize</code>, <code>last_pgno</code>, <code>last_txnid</code>, <code>maxreaders</code> and <code>numreaders</code>.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_info()</code>
</p>
</dd>
<dt><code>stat</code></dt>
<dd>
<p>Brief statistics about the LMDB environment.
</p>
<p><em>Usage:</em>
<code>stat()</code>
</p>
<p><em>Value</em>:
An integer vector with elements <code>psize</code> (the size of a database page), <code>depth</code> (depth of the B-tree), <code>brancb_pages</code> (number of internal non-leaf) pages), <code>leaf_pages</code> (number of leaf pages), <code>overflow_pages</code> (number of overflow pages) and <code>entries</code> (number of data items).
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_stat()</code>
</p>
</dd>
<dt><code>maxkeysize</code></dt>
<dd>
<p>The maximum size of a key (the value can be bigger than this)
</p>
<p><em>Usage:</em>
<code>maxkeysize()</code>
</p>
<p><em>Value</em>:
A single integer
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_maxkeysize()</code>
</p>
</dd>
<dt><code>maxreaders</code></dt>
<dd>
<p>The maximum number of readers
</p>
<p><em>Usage:</em>
<code>maxreaders()</code>
</p>
<p><em>Value</em>:
A single integer
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_get_maxreaders()</code>
</p>
</dd>
<dt><code>begin</code></dt>
<dd>
<p>Begin a transaction
</p>
<p><em>Usage:</em>
<code>begin(db = NULL, write = FALSE, sync = NULL, metasync = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>db</code>:   A database handle, as returned by <code>open_database</code>.  If <code>NULL</code> (the default) then the default database will be used.

</p>
</li>
<li>
<p><code>write</code>:   Scalar logical, indicating if this should be a write transaction.  There can be only one write transaction per database (see <code>mdb_txn</code> for more details) - it is an error to try to open more than one.

</p>
</li>
<li>
<p><code>sync</code>:   Scalar logical, indicating if the data should be synchronised synchronised (flushed to disk) after writes; see main parameter list.

</p>
</li>
<li>
<p><code>metasync</code>:   Scalar logical, indicating if the metadata should be synchronised (flushed to disk) after writes; see main parameter list.

</p>
</li>
</ul>
<p><em>Details:</em>
Transactions are the key objects for interacting with an LMDB database (aside from the convenience interface below).  They are described in more detail in <code>mdb_txn</code>.
</p>
<p><em>Value</em>:
A <code>mdb_txn</code> object
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_begin()</code>
</p>
</dd>
<dt><code>with_transaction</code></dt>
<dd>
<p>Evaluate some code within a transaction
</p>
<p><em>Usage:</em>
<code>with_transaction(fun, db = NULL, write = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>fun</code>:   A function of one argument that does the work of the transaction.  <code>with_transaction</code> will pass the transaction to this function.  This is most easily explained with an example, so see the bottom of the help

</p>
</li>
<li>
<p><code>db</code>:   A database handle, as returned by <code>open_database</code>.  If <code>NULL</code> (the default) then the default database will be used.

</p>
</li>
<li>
<p><code>write</code>:   Scalar logical, indicating if this should be a write transaction.  There can be only one write transaction per database (see <code>mdb_txn</code> for more details) - it is an error to try to open more than one.

</p>
</li>
</ul>
<p><em>Details:</em>
This exists to simplify a pattern where one wants to open a transaction, evaluate some code with that transaction and if anything goes wrong abort, but otherwise commit.  It is most useful with read-write transactions, but can be used with both (and the default is for readonly transactions, like <code>begin()</code>.
</p>
</dd>
<dt><code>open_database</code></dt>
<dd>
<p>Open a named database, or return one if already opened.
</p>
<p><em>Usage:</em>
<code>open_database(key = NULL, reversekey = FALSE, create = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   Name of the database; if <code>NULL</code> this returns the default database (always open).

</p>
</li>
<li>
<p><code>reversekey</code>:   Compare strings in reverse order? See <code>reversekey</code> documentation above

</p>
</li>
<li>
<p><code>create</code>:   Create database if it does not exist already?

</p>
</li>
</ul>
<p><em>Details:</em>
LMDB environments can hold multiple databases, provided they have been opened with <code>maxdbs</code> greater than one.  There is always a "default" database - this is unnamed and cannot be dropped. Other databases have a key (i.e., a name) and can be dropped. These database objects are passed through to other methods, notably <code>drop_database</code> and <code>begin</code>
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_open()</code>
</p>
</dd>
<dt><code>drop_database</code></dt>
<dd>
<p>Drop a database
</p>
<p><em>Usage:</em>
<code>drop_database(db, delete = TRUE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>db</code>:   A database object, as returned by <code>open_database</code>

</p>
</li>
<li>
<p><code>delete</code>:   Scalar logical, indicating if the database should be deleted too.  If <code>FALSE</code>, the values are deleted from the database (i.e., it is emptied). If <code>TRUE</code> then the actual database is deleted too.

</p>
</li>
</ul>
<p><em>Value</em>:
No return value, called for side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_drop()</code>
</p>
</dd>
<dt><code>sync</code></dt>
<dd>
<p>Flush the data buffers to disk.
</p>
<p><em>Usage:</em>
<code>sync(force = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul><li>
<p><code>force</code>:   Scalar logical; force a synchronous flush.  Otherwise if the environment was constructed with <code>sync = FALSE</code> the flushes will be omitted, and with <code>mapasync = TRUE</code> they will be asynchronous.

</p>
</li></ul>
<p><em>Details:</em>
Data is always written to disk when a transaction is committed, but the operating system may keep it buffered.  LMDB always flushes the OS buffers upon commit as well, unless the environment was opened with <code>sync = FALSE</code> or in part <code>metasync = FALSE</code>.  This call is not valid if the environment was opened with <code>readonly = TRUE</code>.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_sync()</code>
</p>
</dd>
<dt><code>copy</code></dt>
<dd>
<p>Copy the entire environment state to a new path.  This can be used to make a backup of the database.
</p>
<p><em>Usage:</em>
<code>copy(path, compact = FALSE)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>path</code>:   Scalar character; the new path

</p>
</li>
<li>
<p><code>compact</code>:   Scalar logical; perform compaction while copying?  This omits free pages and sequentially renumbers all pages in output.  This can take longer than the default but produce a smaller database

</p>
</li>
</ul>
<p><em>Value</em>:
Invisibly, the new path (allowing use of <code>$copy(tempfile)</code>)
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_copy()</code> &amp; <code>mdb_env_copy2()</code>
</p>
</dd>
<dt><code>close</code></dt>
<dd>
<p>Close the environment.  This closes all cursors and transactions (active write transactions are aborted).
</p>
<p><em>Usage:</em>
<code>close()</code>
</p>
<p><em>Value</em>:
No return value, called for side effects only
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_env_close()</code>
</p>
</dd>
<dt><code>destroy</code></dt>
<dd>
<p>Totally destroy an LMDB environment.  This closes the database and removes the files.  Use with care!
</p>
<p><em>Usage:</em>
<code>destroy()</code>
</p>
<p><em>Value</em>:
No return value, called for side effects only
</p>
</dd>
<dt><code>reader_list</code></dt>
<dd>
<p>List information about database readers
</p>
<p><em>Usage:</em>
<code>reader_list()</code>
</p>
<p><em>Value</em>:
A character matrix with columns <code>pid</code> (process ID), <code>thread</code> (a pointer address), and <code>txnid</code> (a small integer)
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_reader_list()</code>
</p>
</dd>
<dt><code>reader_check</code></dt>
<dd>
<p>Check for, and remove, stale entries in the reader lock table.
</p>
<p><em>Usage:</em>
<code>reader_check()</code>
</p>
<p><em>Value</em>:
An integer, being the number of stale readers discarded.  However, this function is primarily called for its side effect.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_reader_check()</code>
</p>
</dd>
<dt><code>get</code></dt>
<dd>
<p>Retrieve a value from the database
</p>
<p><em>Usage:</em>
<code>get(key, missing_is_error = TRUE, as_raw = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   A string (or raw vector) - the key to get

</p>
</li>
<li>
<p><code>missing_is_error</code>:   Logical, indicating if a missing value is an error (by default it is).  Alternatively, with <code>missing_is_error = FALSE</code>, a missing value will return <code>NULL</code>.  Because no value can be <code>NULL</code> (all values must have nonzero length) a <code>NULL</code> is unambiguously missing.

</p>
</li>
<li>
<p><code>as_raw</code>:   Either <code>NULL</code>, or a logical, to indicate the result type required.  With <code>as_raw = NULL</code>, the default, the value will be returned as a string if possible.  If not possible it will return a raw vector.  With <code>as_raw = TRUE</code>, <code>get()</code> will <em>always</em> return a raw vector, even when it is possibly to represent the value as a string.  If <code>as_raw = FALSE</code>, <code>get</code> will return a string, but throw an error if this is not possible.  This is discussed in more detail in the thor vignette (<code>vignette("thor")</code>)

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code>mdb_txn</code> and then aborts the transaction.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_get()</code>
</p>
</dd>
<dt><code>put</code></dt>
<dd>
<p>Put values into the database.  In other systems, this might be called "<code>set</code>".
</p>
<p><em>Usage:</em>
<code>put(key, value, overwrite = TRUE, append = FALSE, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li>
<li>
<p><code>value</code>:   The value to save (string or raw vector)

</p>
</li>
<li>
<p><code>overwrite</code>:   Logical - when <code>TRUE</code> it will overwrite existing data; when <code>FALSE</code> throw an error

</p>
</li>
<li>
<p><code>append</code>:   Logical - when <code>TRUE</code>, append the given key/value to the end of the database.  This option allows fast bulk loading when keys are already known to be in the correct order.  But if you load unsorted keys with <code>append = TRUE</code> an error will be thrown

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code>mdb_txn</code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_put()</code>
</p>
</dd>
<dt><code>del</code></dt>
<dd>
<p>Remove a key/value pair from the database
</p>
<p><em>Usage:</em>
<code>del(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   The name of the key (string or raw vector)

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code>mdb_txn</code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Value</em>:
A scalar logical, indicating if the value was deleted
</p>
<p><em>Note</em>: In lmdb.h this is <code>mdb_del()</code>
</p>
</dd>
<dt><code>exists</code></dt>
<dd>
<p>Test if a key exists in the database.
</p>
<p><em>Usage:</em>
<code>exists(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   The name of the key to test (string or raw vector).  Unlike <code>get</code>, <code>put</code> and <code>del</code> (but like <code>mget</code>, <code>mput</code> and <code>mdel</code>), <code>exists</code> is <em>vectorised</em>.  So the input here can be; a character vector of any length (returning the same length logical vector), a raw vector (representing one key, returning a scalar logical) or a <code>list</code> with each element being either a scalar character or a raw vector, returning a logical the same length as the list.

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
This is an extension of the raw LMDB API and works by using <code>mdb_get</code> for each key (which for lmdb need not copy data) and then testing whether the return value is <code>MDB_SUCCESS</code> or <code>MDB_NOTFOUND</code>.
</p>
<p>This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code>mdb_txn</code> and then aborts the transaction.
</p>
<p><em>Value</em>:
A logical vector
</p>
</dd>
<dt><code>list</code></dt>
<dd>
<p>List keys in the database
</p>
<p><em>Usage:</em>
<code>list(starts_with = NULL, as_raw = FALSE, size = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>starts_with</code>:   Optionally, a prefix for all strings.  Note that is not a regular expression or a filename glob.  Using <code>foo</code> will match <code>foo</code>, <code>foo:bar</code> and <code>foobar</code> but not <code>fo</code> or <code>FOO</code>.  Because LMDB stores keys in a sorted tree, using a prefix can greatly reduce the number of keys that need to be tested.

</p>
</li>
<li>
<p><code>as_raw</code>:   Same interpretation as <code>as_raw</code> in <code>$get()</code> but with a different default.  It is expected that most of the time keys will be strings, so by default we'll try and return a character vector <code>as_raw = FALSE</code>.  Change the default if your database contains raw keys.

</p>
</li>
<li>
<p><code>size</code>:   For use with <code>starts_with</code>, optionally a guess at the number of keys that would be returned.  with <code>starts_with = NULL</code> we can look the number of keys up directly so this is ignored.

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code>mdb_txn</code> and then aborts the transaction.
</p>
</dd>
<dt><code>mget</code></dt>
<dd>
<p>Get values for multiple keys at once (like <code>$get</code> but vectorised over <code>key</code>)
</p>
<p><em>Usage:</em>
<code>mget(key, as_raw = NULL, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   The keys to get values for.  Zero, one or more keys are allowed.

</p>
</li>
<li>
<p><code>as_raw</code>:   As for <code>$get()</code>, logical (or <code>NULL</code>) indicating if raw or string output is expected or desired.

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
This is a helper method that establishes a temporary read-only transaction, calls the corresponding method in <code>mdb_txn</code> and then aborts the transaction.
</p>
</dd>
<dt><code>mput</code></dt>
<dd>
<p>Put multiple values into the database (like <code>$put</code> but vectorised over <code>key</code>/<code>value</code>).
</p>
<p><em>Usage:</em>
<code>mput(key, value, overwrite = TRUE, append = FALSE, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   The keys to set

</p>
</li>
<li>
<p><code>value</code>:   The values to set against these keys.  Must be the same length as <code>key</code>.

</p>
</li>
<li>
<p><code>overwrite</code>:   As for <code>$put</code>

</p>
</li>
<li>
<p><code>append</code>:   As for <code>$put</code>

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
The implementation simply calls <code>mdb_put</code> repeatedly (but with a single round of error checking) so duplicate <code>key</code> entries will result in the last key winning.
</p>
<p>This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code>mdb_txn</code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
</dd>
<dt><code>mdel</code></dt>
<dd>
<p>Delete multiple values from the database (like <code>$del</code> but vectorised over <code>key</code>).
</p>
<p><em>Usage:</em>
<code>mdel(key, db = NULL)</code>
</p>
<p><em>Arguments:</em>
</p>

<ul>
<li>
<p><code>key</code>:   The keys to delete

</p>
</li>
<li>
<p><code>db</code>:   A database handle that would be passed through to create the transaction (see the <code>$begin</code> method).

</p>
</li>
</ul>
<p><em>Details:</em>
This is a helper method that establishes a temporary read-write transaction, calls the corresponding method in <code>mdb_txn</code> and then commits the transaction.  This will only be possible to use if there is not an existing write transaction in effect for this environment.
</p>
<p><em>Value</em>:
A logical vector, the same length as <code>key</code>, indicating if each key was deleted.
</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">
# As always, start with the environment.  Because we're going to
# use more than one database, we must set `maxdbs` to more than 1:
env &lt;- thor::mdb_env(tempfile(), maxdbs = 10)

# The default environment - every database
db &lt;- env$open_database()
# The default database will always have id 1 and no name
db$id()
db$name()

# A different database
foo &lt;- env$open_database("foo")
foo$id()
foo$name()

# Opening a database multiple times has no effect - it returns the
# same data base every call.
identical(env$open_database("foo"), foo) # TRUE

# Then we can put some data int the new database:
txn &lt;- env$begin(foo, write = TRUE)
txn$put("hello", "world")
txn$commit()

# Now we have values in the "foo" database, but not the default one:
env$get("hello", db = NULL, missing_is_error = FALSE) # NULL
env$get("hello", db = foo,  missing_is_error = FALSE) # "world"

# Cleanup
env$destroy()
</code></pre>


</div>