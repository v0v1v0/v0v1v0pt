<div class="container">

<table style="width: 100%;"><tr>
<td>test.vc.twosigma</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Convenient wrapper function for performing (joint) likelihood ratio tests of variance components using the TWO-SIGMA model.</h2>

<h3>Description</h3>

<p>Convenient wrapper function for performing (joint) likelihood ratio tests of variance components using the TWO-SIGMA model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">test.vc.twosigma(
  count_matrix,
  mean_covar,
  zi_covar,
  mean_re = TRUE,
  zi_re = TRUE,
  id,
  return_full_fits = TRUE,
  adhoc = FALSE,
  adhoc_thresh = 0.1,
  silent = FALSE,
  disp_covar = NULL,
  weights = rep(1, ncol(count_matrix)),
  control = glmmTMBControl(),
  ncores = 1,
  cluster_type = "Fork",
  chunk_size = 1,
  lb = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>count_matrix</code></td>
<td>
<p>Matrix of non-negative integer read counts, with rows corresponding to genes and columns corresponding to cells. It is recommended to make the rownames the gene names for better output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_covar</code></td>
<td>
<p>Covariates for the (conditional) mean model. Must be a matrix (without an intercept column) or a vector if a single covariate is being tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zi_covar</code></td>
<td>
<p>Covariates for the zero-inflation model. Must be a matrix (without an intercept column) or a vector if a single covariate is being tested.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean_re</code></td>
<td>
<p>Should random intercepts be tested in the (conditional) mean model?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zi_re</code></td>
<td>
<p>Should random intercepts be tested in the zero-inflation model?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>Vector of individual-level ID's. Used for random effect prediction and the adhoc method but required regardless.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_full_fits</code></td>
<td>
<p>If TRUE, fit objects of class glmmTMB are returned. If FALSE, only objects of class summary.glmmTMB are returned. The latter require a much larger amount of memory to store.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adhoc</code></td>
<td>
<p>Should the adhoc method be used by default to judge if random effects are needed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adhoc_thresh</code></td>
<td>
<p>Value below which the adhoc p-value is deemed significant (and thus RE are deemed necessary). Only used if adhoc==TRUE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>If TRUE, progress is not printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>disp_covar</code></td>
<td>
<p>Covariates for a log-linear model for the dispersion. Either a matrix or = 1 to indicate an intercept only model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights, as in glm. Defaults to 1 for all observations and no scaling or centering of weights is performed.  See <code>?glmmTMBControl</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>Control parameters for optimization in glmmTMB.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>Number of cores used for parallelization. Defaults to 1, meaning no parallelization of any kind is done.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluster_type</code></td>
<td>
<p>Whether to use a "cluster of type "Fork" or "Sock". On Unix systems, "Fork" will likely improve performance. On Windows, only "Sock" will actually result in parallelized computing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunk_size</code></td>
<td>
<p>Number of genes to be sent to each parallel environment. Parallelization is more efficient, particularly with a large count matrix, when the count matrix is 'chunked' into some common size (e.g. 10, 50, 200). Defaults to 10.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lb</code></td>
<td>
<p>Should load balancing be used for parallelization? Users will likely want to set to FALSE for improved performance.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li>
<p><code>fit_null: </code> Model fits under the null hypothesis. If <code>return_summary_fits=TRUE</code>, returns a list of objects of class <code>summary.glmmTMB</code>. If <code>return_summary_fits=FALSE</code>, returns a list of model fit objects of class <code>glmmTMB</code>. In either case, the order matches the row order of <code>count_matrix</code>, and the names of the list elements are taken as the rownames of <code>count_matrix</code>.
</p>
</li>
<li>
<p><code>fit_alt: </code> Model fits under the alt hypothesis of the same format as <code>fit_null</code>.
</p>
</li>
<li>
<p><code>LR_stat: </code> Vector of Likelihood Ratio statistics. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li>
<li>
<p><code>LR_p.val: </code> Vector of Likelihood Ratio p-values. A value of 'NA' implies a convergence issue or other model fit problem.
</p>
</li>
</ul>
<h3>Details</h3>

<p>If either model fails to converge, or the LR statistic is negative, both the statistic and p-value are assigned as NA.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Set Parameters to Simulate Some Data

nind&lt;-10;ncellsper&lt;-rep(50,nind)
sigma.a&lt;-.5;sigma.b&lt;-.5;phi&lt;-.1
alpha&lt;-c(1,0,-.5,-2);beta&lt;-c(2,0,-.1,.6)
beta2&lt;-c(2,1,-.1,.6)
id.levels&lt;-1:nind;nind&lt;-length(id.levels)
id&lt;-rep(id.levels,times=ncellsper)
sim.seed&lt;-1234

# Simulate individual level covariates

t2d_sim&lt;-rep(rbinom(nind,1,p=.4),times=ncellsper)
cdr_sim&lt;-rbeta(sum(ncellsper),3,6)
age_sim&lt;-rep(sample(c(20:60),size=nind,replace = TRUE),times=ncellsper)

# Construct design matrices

Z&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(Z)&lt;-c("t2d_sim","age_sim","cdr_sim")
X&lt;-cbind(scale(t2d_sim),scale(age_sim),scale(cdr_sim))
colnames(X)&lt;-c("t2d_sim","age_sim","cdr_sim")

# Simulate Data

sim_dat&lt;-matrix(nrow=2,ncol=sum(ncellsper))
for(i in 1:nrow(sim_dat)){
   sim_dat[i,]&lt;-simulate_zero_inflated_nb_random_effect_data(ncellsper,X,Z,alpha,beta2
   ,phi,sigma.a,sigma.b,id.levels=NULL)$Y
}
rownames(sim_dat)&lt;-paste("Gene",1:2)

# Run test.vc.twosigma

test.vc.twosigma(sim_dat[1,,drop=FALSE],mean_covar = X,zi_covar=Z
,mean_re = TRUE,zi_re=FALSE,id = id)
</code></pre>


</div>