<div class="container">

<table style="width: 100%;"><tr>
<td>Kronecker product</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Kronecker product</h2>

<h3>Description</h3>

<p>Computes the direct Kronecker product between two matrices
</p>


<h3>Usage</h3>

<pre><code class="language-R">Kronecker(A, B, rows = NULL, cols = NULL, a = 1,
          make.dimnames = FALSE, drop = TRUE,
          inplace = FALSE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(numeric) Left numeric matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>(numeric) Right numeric matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>(integer) Index which rows of the Kronecker are to be returned. They must range from 1 to <code>nrow(A)*nrow(B)</code>. Default <code>rows=NULL</code> will return all the rows</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>(integer) Index which columns of the Kronecker are to be returned. They must range from 1 to <code>ncol(A)*ncol(B)</code>. Default <code>cols=NULL</code> return all the columns</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>(numeric) A constant to multiply the resulting Kronecker product by</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Either <code>TRUE</code> or <code>FALSE</code> to whether return a uni-dimensional vector when output is a matrix with either 1 row or 1 column as per the <code>rows</code> and <code>cols</code> arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.dimnames</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether add <code>rownames</code> and <code>colnames</code> attributes to the output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inplace</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether operate directly on one input matrix (<code>A</code> or <code>B</code>) when the other one is a scalar. This is possible only when <code>rows=NULL</code> and <code>cols=NULL</code>. When <code>TRUE</code> the output will be overwritten on the same address occupied by the input that is not scalar. Default <code>inplace=FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For any two matrices
<b>A</b>={a<sub>ij</sub>} of dimensions 
<i>m</i> × <i>n</i> and
<b>B</b>={b<sub>ij</sub>} of dimensions
<i>p</i> × <i>q</i>, 
the direct Kronecker product between them is a matrix defined as the block matrix
</p>
<p style="text-align:center"><b>A</b>⊗<b>B</b> = {a<sub>ij</sub><b>B</b>}</p>
<p>which is of dimensions <i>mp</i> × <i>nq</i>.
</p>
<p>A sub-matrix formed by selecting specific rows and columns from the Kronecker can be obtained by pre- and post- multiplication with incidence matrices
</p>
<p style="text-align:center"><b>R</b> (<b>A</b>⊗<b>B</b>) <b>C'</b></p>
<p>where
<b>R</b> is an incidence matrix mapping from rows of the resulting sub-matrix to rows of the Kronecker product, and 
<b>C</b> is an incidence matrix mapping from columns of the resulting sub-matrix to columns of the Kronecker product.
This sub-matrix of the Kronecker can be obtained by matrix indexing as
</p>
<p style="text-align:center;font-family:courier">Kronecker(A,B)[rows,cols]</p>
<p>where <code>rows</code> and <code>cols</code> are integer vectors whose entries are, respectively, the row and column number of the Kronecker that are mapped at each row of <b>R</b> and <b>C</b>.
</p>
<p>The function computes this sub-matrix of the Kronecker product directly from <b>A</b> and <b>B</b> without forming the whole Kronecker product. This is very useful if a relatively small number of row/columns are to be selected. 
</p>


<h3>Value</h3>

<p>Returns the Kronecker product matrix. It can be a sub-matrix of it as per the <code>rows</code> and <code>cols</code> arguments.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  require(tensorEVD)
  
  # (a) Kronecker product of 2 vectors
  A = rnorm(3)
  B = rnorm(2) 
  (K1 = Kronecker(A, B))
  # it must equal when using from the R-base package:
  (K2 = kronecker(A, B))
  
  # (b) Kronecker product of 2 matrices
  A = matrix(rnorm(12), ncol=3)
  B = matrix(rnorm(4), ncol=2)
  K1 = Kronecker(A, B)
  # (it must equal (but faster) to:)
  K2 = kronecker(A, B)
  all.equal(K1,K2)
  
  # (c) Subsetting rows/columns from the Kronecker
  A = matrix(rnorm(100*150), ncol=150)
  B = matrix(rnorm(100*120), ncol=120)
  rows = c(1,3,5,7)
  cols = c(10,20,30,50)
  K1 = Kronecker(A, B, rows=rows, cols=cols)
  # (it must equal (but faster) to:)
  K2 = Kronecker(A, B)[rows,cols]
  all.equal(K1,K2)
  
  # (d) Inplace calculation
  # overwrite the output at the same address as the input:
  K1 = A[]                     # copy of A to be used as input
  add  = pryr::address(K1)     # address of K on entry
  K1 = Kronecker(K1, B=0.5)
  pryr::address(K1) == add     # on exit, K was moved to a different address
  
  K2 = A[]   
  add  = pryr::address(K2)
  K2 = Kronecker(K2, B=0.5, inplace=TRUE)
  pryr::address(K2) == add     # on exit, K remains at the same address
  all.equal(K1,K2)
  
</code></pre>


</div>