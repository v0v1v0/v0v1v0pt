<div class="container">

<table style="width: 100%;"><tr>
<td>tsmp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes the Matrix Profile and Profile Index</h2>

<h3>Description</h3>

<p>This is a wrap function that makes easy to use all available algorithms to compute the Matrix
Profile and Profile Index for multiple purposes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tsmp(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  mode = c("stomp", "stamp", "simple", "mstomp", "scrimp", "valmod", "pmp"),
  verbose = getOption("tsmp.verbose", 2),
  n_workers = 1,
  s_size = Inf,
  must_dim = NULL,
  exc_dim = NULL,
  heap_size = 50,
  paa = 1,
  .keep_data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. If a second time series is supplied it will be a join matrix
profile (except for <code>mstomp()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>window_size</code></td>
<td>
<p>an <code>int</code> with the size of the sliding window. Use a vector for Valmod.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>the algorithm that will be used to compute the matrix profile. (Default is <code>stomp</code>).
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>an <code>int</code>. (Default is <code>2</code>). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_workers</code></td>
<td>
<p>an <code>int</code>. Number of workers for parallel. (Default is <code>1</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s_size</code></td>
<td>
<p>a <code>numeric</code>. for anytime algorithm, represents the size (in observations) the
random calculation will occur (default is <code>Inf</code>). See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>must_dim</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of which dimensions to forcibly include (default is <code>NULL</code>).
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exc_dim</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of which dimensions to exclude (default is <code>NULL</code>). See
details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heap_size</code></td>
<td>
<p>an <code>int</code>. (Default is <code>50</code>). Size of the distance profile heap buffer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paa</code></td>
<td>
<p>an <code>int</code>. (Default is <code>1</code>). Factor of PAA reduction (2 == half of size)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.keep_data</code></td>
<td>
<p>a <code>logical</code>. (Default is <code>TRUE</code>). Keeps the data embedded to resultant object.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because
of its generality, versatility, simplicity and scalability. In particular it has implications
for time series motif discovery, time series joins, shapelet discovery (classification),
density estimation, semantic segmentation, visualization, rule discovery, clustering etc.
</p>
<p>The first algorithm invented was the <code>stamp()</code> that using <code>mass()</code> as an ultra-fast Algorithm
for Similarity Search allowed to compute the Matrix Profile in reasonable time. One of its main
feature was its Anytime property which using a randomized approach could return a "best-so-far"
matrix that could give us the correct answer (using for example 1/10 of all iterations) almost
every time.
</p>
<p>The next algorithm was <code>stomp()</code> that currently is the most used. Researchers noticed that the
dot products do not need to be recalculated from scratch for each subsequence. Instead, we can
reuse the values calculated for the first subsequence to make a faster calculation in the next
iterations. The idea is to make use of the intersections between the required products in
consecutive iterations. This approach reduced the time to compute the Matrix Profile to about
3% compared to <code>stamp()</code>, but on the other hand, we lost the Anytime property.
</p>
<p>Currently there is a new algorithm that I'll not explain further here. It is called <code>scrimp()</code>,
and is as fast as <code>stomp()</code>, and have the Anytime property. This algorithm is implemented in
this package, but still waiting for an article publication.
</p>
<p>Further, there is the <code>mstomp()</code> that computes a multidimensional Matrix Profile that allows to
meaningful MOTIF discovery in Multivariate Time Series. And <code>simple_fast()</code> that also handles
Multivariate Time Series, but focused in Music Analysis and Exploration.
</p>
<p>The <code>valmod()</code> uses a new pruning algorithm allowing a similarity search with a range of sliding
window sizes.
</p>
<p>The <code>pmp()</code> is a new concept that creates several profiles from a range of windows.
</p>
<p>Some parameters are global across the algorithms:
</p>

<dl>
<dt>...</dt>
<dd>
<p>One or two time series (except for <code>mstomp()</code>). The second time series can be smaller than the first.</p>
</dd>
<dt>window_size</dt>
<dd>
<p>The sliding window.</p>
</dd>
<dt>exclusion_zone</dt>
<dd>
<p>Is used to avoid trivial matches; if a query data is provided
(join similarity), this parameter is ignored.</p>
</dd>
<dt>verbose</dt>
<dd>
<p>Changes how much information is printed by this function; <code>0</code> means nothing,
<code>1</code> means text, <code>2</code> adds the progress bar, <code>3</code> adds the finish sound.</p>
</dd>
<dt>n_workers</dt>
<dd>
<p>number of threads for parallel computing (except <code>simple_fast</code>, <code>scrimp</code> and <code>valmod</code>).
If the value is 2 or more, the '_par' version of the algorithm will be used.</p>
</dd>
</dl>
<p><code>s_size</code> is used only in Anytime algorithms: <code>stamp()</code> and <code>scrimp()</code>.
<code>must_dim</code> and <code>exc_dim</code> are used only in <code>mstomp()</code>.
<code>heap_size</code> is used only for <code>valmod()</code>
<code>mode</code> can be any of the following: <code>stomp</code>, <code>stamp</code>, <code>simple</code>, <code>mstomp</code>, <code>scrimp</code>, <code>valmod</code>, <code>pmp</code>.
</p>


<h3>Value</h3>

<p>Returns the matrix profile <code>mp</code> and profile index <code>pi</code>. It also returns the left and
right matrix profile <code>lmp</code>, <code>rmp</code> and profile index <code>lpi</code>, <code>rpi</code> that may be used to detect
Time Series Chains. <code>mstomp()</code> returns a multidimensional Matrix Profile.
</p>


<h3>References</h3>


<ul><li>
<p> Silva D, Yeh C, Batista G, Keogh E. Simple: Assessing Music Similarity Using
Subsequences Joins. Proc 17th ISMIR Conf. 2016;23-30.
</p>
</li></ul>
<ul><li>
<p> Silva DF, Yeh C-CM, Zhu Y, Batista G, Keogh E. Fast Similarity Matrix Profile for
Music Analysis and Exploration. IEEE Trans Multimed. 2018;14(8):1-1.
</p>
</li></ul>
<ul><li>
<p> Yeh CM, Kavantzas N, Keogh E. Matrix Profile VI : Meaningful Multidimensional Motif
Discovery.
</p>
</li></ul>
<ul><li>
<p> Yeh CCM, Zhu Y, Ulanova L, Begum N, Ding Y, Dau HA, et al. Matrix profile I: All
pairs similarity joins for time series: A unifying view that includes motifs, discords and
shapelets. Proc - IEEE Int Conf Data Mining, ICDM. 2017;1317-22.
</p>
</li></ul>
<ul><li>
<p> Zhu Y, Imamura M, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A
New Primitive for Time Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>
<ul><li>
<p> Zhu Y, Zimmerman Z, Senobari NS, Yeh CM, Funning G. Matrix Profile II : Exploiting
a Novel Algorithm and GPUs to Break the One Hundred Million Barrier for Time Series Motifs and
Joins. Icdm. 2016 Jan 22;54(1):739-48.
</p>
</li></ul>
<p>Website: <a href="https://sites.google.com/view/simple-fast">https://sites.google.com/view/simple-fast</a>
</p>
<p>Website: <a href="https://sites.google.com/site/ismir2016simple/home">https://sites.google.com/site/ismir2016simple/home</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other matrix profile computations: 
<code>mstomp_par()</code>,
<code>scrimp()</code>,
<code>stamp_par()</code>,
<code>stomp_par()</code>,
<code>valmod()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># default with [stomp()]
mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)

# Anytime STAMP
mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, mode = "stamp", s_size = 50, verbose = 0)

# [mstomp()]
mp &lt;- tsmp(mp_toy_data$data[1:200, ], window_size = 30, mode = "mstomp", verbose = 0)

# [simple_fast()]
mp &lt;- tsmp(mp_toy_data$data[1:200, ], window_size = 30, mode = "simple", verbose = 0)

# parallel with [stomp_par()]
mp &lt;- tsmp(mp_test_data$train$data[1:1000, 1], window_size = 30, n_workers = 2, verbose = 0)

</code></pre>


</div>