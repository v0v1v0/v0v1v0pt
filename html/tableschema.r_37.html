<div class="container">

<table style="width: 100%;"><tr>
<td>Table</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Table Class</h2>

<h3>Description</h3>

<p>Table class for working with data and schema.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># Table.load(source, schema = NULL, strict = FALSE, headers = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>source</code></td>
<td>
<p>data source, one of:
</p>

<ul>
<li>
<p> string with the path of the local CSV file
</p>
</li>
<li>
<p> string with the url of the remote CSV file
</p>
</li>
<li>
<p> list of lists representing the rows
</p>
</li>
<li>
<p> readable stream with CSV file contents
</p>
</li>
<li>
<p> function returning readable stream with CSV file contents
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>schema</code></td>
<td>
<p>data schema in all forms supported by <code>Schema</code> class</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strict</code></td>
<td>
<p>strictness option <code>TRUE</code> or <code>FALSE</code>, to pass to <code>Schema</code> constructor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>headers</code></td>
<td>
<p>data source headers, one of:
</p>

<ul>
<li>
<p> row number containing headers (<code>source</code> should contain headers rows)
</p>
</li>
<li>
<p> list of headers (<code>source</code> should NOT contain headers rows)
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>options to be used by CSV parser. 
All options listed at <a href="https://csv.js.org/parse/options/">https://csv.js.org/parse/options/</a>. 
By default <code>ltrim</code> is <code>TRUE</code> according to the <a href="https://specs.frictionlessdata.io//csv-dialect/#specification">CSV Dialect spec</a>.</p>
</td>
</tr>
</table>
<h3>Format</h3>

<p><code>R6Class</code> object.
</p>


<h3>Value</h3>

<p>Object of <code>R6Class</code> .
</p>


<h3>Methods</h3>


<dl>
<dt><code>Table$new(source, schema, strict, headers)</code></dt>
<dd>
<p>Use <code>Table.load</code> to instantiate <code>Table</code> class.</p>
</dd>
<dt><code>iter(keyed, extended, cast=TRUE, relations=FALSE, stream=FALSE)</code></dt>
<dd>
<p>Iter through the table data and emits rows cast based on table schema. Data casting could be disabled.</p>
</dd>
</dl>
<ul>
<li>
<p><code>keyed </code>Iter keyed rows - <code>TRUE</code>/<code>FALSE</code>  
</p>
</li>
<li>
<p><code>extended </code>Iter extended rows - <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li>
<p><code>cast </code>Disable data casting if <code>FALSE</code>
</p>
</li>
<li>
<p><code>relations </code>List object of foreign key references from a form of JSON <code>{resource1: [{field1: value1, field2: value2},...],...}</code>.
If provided foreign key fields will checked and resolved to its references
</p>
</li>
<li>
<p><code>stream </code>Return Readable Stream of table rows if <code>TRUE</code>
</p>
</li>
</ul>
<dl>
<dt><code>read(keyed, extended, cast=TRUE, relations=FALSE, limit)</code></dt>
<dd>
<p>Read the whole table and returns as array of rows. Count of rows could be limited.</p>
</dd>
</dl>
<ul>
<li>
<p><code>keyed </code>Flag to emit keyed rows - <code>TRUE</code>/<code>FALSE</code>  
</p>
</li>
<li>
<p><code>extended </code>Flag to emit extended rows - <code>TRUE</code>/<code>FALSE</code>
</p>
</li>
<li>
<p><code>cast </code>Disable data casting if <code>FALSE</code>
</p>
</li>
<li>
<p><code>relations </code>List object of foreign key references from a form of JSON <code>{resource1: [{field1: value1, field2: value2},...],...}</code>.
If provided foreign key fields will checked and resolved to its references
</p>
</li>
<li>
<p><code>limit </code>Integer limit of rows to return if specified
</p>
</li>
</ul>
<dl>
<dt><code>infer(limit=100)</code></dt>
<dd>
<p>Infer a schema for the table. It will infer and set <code>Table Schema</code> to <code>table$schema</code> based on table data.</p>
</dd>
</dl>
<ul><li>
<p><code>limit </code>Limit rows samle size - number
</p>
</li></ul>
<dl>
<dt><code>save(target)</code></dt>
<dd>
<p>Save data source to file locally in CSV format with <code>,</code> (comma) delimiter.</p>
</dd>
</dl>
<ul><li>
<p><code>target </code>String path where to save a table data
</p>
</li></ul>
<h3>Properties</h3>


<dl>
<dt><code>headers</code></dt>
<dd>
<p>Returns data source headers</p>
</dd>
<dt><code>schema</code></dt>
<dd>
<p>Returns schema class instance</p>
</dd>
</dl>
<h3>Details</h3>

<p>A table is a core concept in a tabular data world. It represents a data with a metadata (Table Schema).
Tabular data consists of a set of rows. Each row has a set of fields (columns). 
We usually expect that each row has the same set of fields and thus we can talk about the 
fields for the table as a whole. In case of tables in spreadsheets or CSV files we often interpret 
the first row as a header row, giving the names of the fields. By contrast, in other situations, 
e.g. tables in SQL databases, the field names are explicitly designated.
</p>
<p>In order to talk about the representation and processing of tabular data from text-based sources, 
it is useful to introduce the concepts of the <em>physical</em> and the <em>logical</em> representation of data.
</p>
<p>The <em>physical representation</em> of data refers to the representation of data as text on disk, 
for example, in a CSV or JSON file. This representation may have some type information 
(JSON, where the primitive types that JSON supports can be used) or not 
(CSV, where all data is represented in string form).
</p>
<p>The <em>logical representation</em> of data refers to the "ideal" representation of the data 
in terms of primitive types, data structures, and relations, all as defined by the specification. 
We could say that the specification is about the logical representation of data, 
as well as about ways in which to handle conversion of a physical representation to a logical one.
</p>
<p>We'll explicitly refer to either the <em>physical</em> or <em>logical</em> representation 
in places where it prevents ambiguity for those engaging with the specification, especially implementors.
</p>
<p>For example, <code>constraints</code> should be tested on the logical representation of data, 
whereas a property like <code>missingValues</code> applies to the physical representation of the data.
</p>
<p><a href="https://CRAN.R-project.org/package=jsonlite">Jsolite package</a> is internally used to convert json data to list objects. The input parameters of functions could be json strings, 
files or lists and the outputs are in list format to easily further process your data in R environment and exported as desired. 
More details about handling json you can see jsonlite documentation or vignettes <a href="https://CRAN.R-project.org/package=jsonlite">here</a>.
</p>
<p><a href="https://CRAN.R-project.org/package=future">Future package</a> is also used to load and create Table and Schema class asynchronously. 
To retrieve the actual result of the loaded Table or Schema you have to call <code>value(future)</code> to the variable you stored the loaded Table/Schema. 
More details about future package and sequential and parallel processing you can find <a href="https://CRAN.R-project.org/package=future">here</a>.
</p>
<p>Examples section of each function show how to use jsonlite and future packages with tableschema.r.
</p>


<h3>Language</h3>

<p>The key words <code>MUST</code>, <code>MUST NOT</code>, <code>REQUIRED</code>, <code>SHALL</code>, <code>SHALL NOT</code>, 
<code>SHOULD</code>, <code>SHOULD NOT</code>, <code>RECOMMENDED</code>, <code>MAY</code>, and <code>OPTIONAL</code> 
in this package documents are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>


<h3>See Also</h3>

<p><code>Table.load</code>, 
<a href="https://specs.frictionlessdata.io//table-schema/">Table Schema Specifications</a>
</p>


</div>