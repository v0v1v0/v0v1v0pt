<div class="container">

<table style="width: 100%;"><tr>
<td>AMUSEboot</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Second-order Separation Sub-White-Noise Bootstrap Testing with AMUSE
</h2>

<h3>Description</h3>

<p>The function uses AMUSE (Algorithm for Multiple Unknown Signals Extraction) to test whether the last <code>p-k</code> latent series are pure white noise, assuming a p-variate second-order stationary blind source separation (BSS) model.
Four different bootstrapping strategies are available and the function can be run in parallel.
</p>


<h3>Usage</h3>

<pre><code class="language-R">AMUSEboot(X, ...)

## Default S3 method:
AMUSEboot(X, k, tau = 1, n.boot = 200, s.boot = c("p", "np1", "np2", "np3"),
          ncores = NULL, iseed = NULL, ...)
## S3 method for class 'ts'
AMUSEboot(X, ...)
## S3 method for class 'xts'
AMUSEboot(X, ...)
## S3 method for class 'zoo'
AMUSEboot(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code>ts</code>, <code>xts</code> or <code>zoo</code>. Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of latent series that are not white noise. Can be between <code class="reqn">0</code> and <code class="reqn">p-1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The lag for the AMUSE autocovariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.boot</code></td>
<td>
<p>The number of bootstrapping samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.boot</code></td>
<td>
<p>Bootstrapping strategy to be used. Possible values are <code>"p"</code> (default), <code>"np1"</code>, <code>"np2"</code>, <code>"np3"</code>. See details for further information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ncores</code></td>
<td>
<p>The number of cores to be used. If <code>NULL</code> or 1, no parallel computing is used. Otherwise <code>makeCluster</code> with <code>type = "PSOCK"</code> is used. It is the users repsonsibilty to choose a reasonable value for <code>ncores</code>. The function <code>detectCores</code> might be useful in this context.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iseed</code></td>
<td>
<p>If parallel computation is used, the seed passed on to <code>clusterSetRNGStream</code>. Default is <code>NULL</code> which means no fixed seed is used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>AMUSE standardizes <code>X</code> with <code class="reqn">n</code> samples and computes the eigendecomposition of the autocovariance matrix of the standardized data for a chosen lag <code>tau</code>, yielding a transformation <code class="reqn">\bf W</code> giving the latent variables as <code class="reqn">{\bf S} = {\bf X} {\bf W}</code>. Assume, without loss of generality, that the latent components are ordered in decreasing order with respect to the squares of the corresponding eigenvalues of the autocovariance matrix. Under the null hypothesis the final <code class="reqn">p - k</code> eigenvalues equal zero, <code class="reqn">\lambda_{p-k} = \cdots = \lambda_{p} = 0</code>, and their mean square <code class="reqn">m</code> can be used as a test statistic in bootstrap-based inference on the true number of latent white noise series.
</p>
<p>The function offers four different bootstrapping strategies for generating samples for which the null hypothesis approximately holds, and they are all based on the following general formula:
</p>

<ol>
<li>
<p> Decompose the AMUSE-estimated latent series <code class="reqn">\bf S</code> into the postulated signal <code class="reqn">{\bf S}_1</code> and white noise <code class="reqn">{\bf S}_2</code>.
</p>
</li>
<li>
<p> Take <code class="reqn">n</code> bootstrap samples <code class="reqn">{\bf S}_2^*</code> of <code class="reqn">{\bf S}_2</code>, see the different strategies below.
</p>
</li>
<li>
<p> Recombine <code class="reqn">\bf S^* = ({\bf S}_1, {\bf S}_2^*)</code> and back-transform <code class="reqn">{\bf X}^*= {\bf S}^* {\bf W}^{-1}</code>.
</p>
</li>
<li>
<p> Compute the test statistic based on <code class="reqn">{\bf X}^*</code>.
</p>
</li>
<li>
<p> Repeat the previous steps <code>n.boot</code> times.
</p>
</li>
</ol>
<p>The four different bootstrapping strategies are:
</p>

<ol>
<li> <p><code>s.boot = "p"</code>: 
The first strategy is parametric and simply generates all boostrap samples independently and identically from the standard normal distribution.
</p>
</li>
<li> <p><code>s.boot = "np1"</code>: 
The second strategy is non-parametric and pools all observed <code class="reqn">n(p - k)</code> white noise observations together and draws the bootstrap samples from amongst them.
</p>
</li>
<li> <p><code>s.boot = "np2"</code>: 
The third strategy is non-parametric and proceeds otherwise as the second strategy but acts component-wise. That is, for each of the <code class="reqn">p - k</code> white noise series it pools the observed <code class="reqn">n</code> white noise observations together and draws the bootstrap samples of that particular latent series from amongst them.
</p>
</li>
<li> <p><code>s.boot = "np3"</code>: 
The third strategy is non-parametric and instead of drawing the samples univariately as in the second and third strategies, it proceeds by resampling <code class="reqn">n</code> vectors of size <code class="reqn">p - k</code> from amongst all the observed <code class="reqn">n</code> white noise vectors.
</p>
</li>
</ol>
<p>The function can be run in parallel by setting <code>ncores</code> to the desired number of cores (should be less than the number of cores available - 1). When running code in parallel the standard random seed of R is overridden and if a random seed needs to be set it should be passed via the argument <code>iseed</code>. The argument <code>iseed</code> has no effect in case <code>ncores</code> equals 1 (the default value).
</p>


<h3>Value</h3>

<p>A list of class ictest, inheriting from class htest, containing:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>statistic</code></td>
<td>
<p>The value of the test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value</code></td>
<td>
<p>The p-value of the test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter</code></td>
<td>
<p>The number of bootstrap samples.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alternative</code></td>
<td>
<p>Character string specifying the alternative hypothesis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of latent series that are not white noise used in the testing problem.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>W</code></td>
<td>
<p>The transformation matrix to the latent series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S</code></td>
<td>
<p>Multivariate time series with the centered source components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>The underlying eigenvalues of the autocovariance matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MU</code></td>
<td>
<p>The location of the data which was subtracted before calculating AMUSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>The used lag.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Character string indicating which test was performed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.name</code></td>
<td>
<p>Character string giving the name of the data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s.boot</code></td>
<td>
<p>Character string denoting which bootstrapping test version was used.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen, Joni Virta
</p>


<h3>References</h3>

<p>Matilainen, M., Nordhausen, K. and Virta, J. (2018), <em>On the Number of Signals in Multivariate Time Series</em>. In Deville, Y., Gannot, S., Mason, R., Plumbley, M.D. and  Ward, D. (editors) "International Conference on Latent Variable Analysis and Signal Separation", LNCS 10891, 248â€“258. Springer, Cham., &lt;doi:10.1007/978-3-319-93764-9_24&gt;.
</p>


<h3>See Also</h3>

<p><code>AMUSE</code>, <code>SOBI</code>, <code>SOBIboot</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">  n &lt;- 1000

  A &lt;- matrix(rnorm(16), 4, 4)
  s1 &lt;- arima.sim(list(ar = c(0.3, 0.6)), n)
  s2 &lt;- arima.sim(list(ma = c(-0.3, 0.3)), n)
  s3 &lt;- rnorm(n)
  s4 &lt;- rnorm(n)

  S &lt;- cbind(s1, s2, s3, s4)
  X &lt;- S %*% t(A)

  boot_res_1 &lt;- AMUSEboot(X, k = 1)
  boot_res_1

  boot_res_2 &lt;- AMUSEboot(X, k = 2)
  boot_res_2

  # Plots of the estimated sources, the last two are white noise
  plot(boot_res_2)
</code></pre>


</div>