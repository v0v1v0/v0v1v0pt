<div class="container">

<table style="width: 100%;"><tr>
<td>sts_fit_with_hmc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Draw posterior samples using Hamiltonian Monte Carlo (HMC)</h2>

<h3>Description</h3>

<p>Markov chain Monte Carlo (MCMC) methods are considered the gold standard of
Bayesian inference; under suitable conditions and in the limit of infinitely
many draws they generate samples from the true posterior distribution. HMC (Neal, 2011)
uses gradients of the model's log-density function to propose samples,
allowing it to exploit posterior geometry. However, it is computationally more
expensive than variational inference and relatively sensitive to tuning.
</p>


<h3>Usage</h3>

<pre><code class="language-R">sts_fit_with_hmc(
  observed_time_series,
  model,
  num_results = 100,
  num_warmup_steps = 50,
  num_leapfrog_steps = 15,
  initial_state = NULL,
  initial_step_size = NULL,
  chain_batch_shape = list(),
  num_variational_steps = 150,
  variational_optimizer = NULL,
  variational_sample_size = 5,
  seed = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>observed_time_series</code></td>
<td>
<p><code>float</code> <code>tensor</code> of shape
<code style="white-space: pre;">⁠concat([sample_shape, model.batch_shape, [num_timesteps, 1]])⁠</code> where
<code>sample_shape</code> corresponds to i.i.d. observations, and the trailing <code style="white-space: pre;">⁠[1]⁠</code>
dimension may (optionally) be omitted if <code>num_timesteps &gt; 1</code>. May
optionally be an instance of <code>sts_masked_time_series</code>, which includes
a mask <code>tensor</code> to specify timesteps with missing observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>An instance of <code>StructuralTimeSeries</code> representing a
time-series model. This represents a joint distribution over
time-series and their parameters with batch shape <code style="white-space: pre;">⁠[b1, ..., bN]⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_results</code></td>
<td>
<p>Integer number of Markov chain draws. Default value: <code>100</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_warmup_steps</code></td>
<td>
<p>Integer number of steps to take before starting to
collect results. The warmup steps are also used to adapt the step size
towards a target acceptance rate of 0.75. Default value: <code>50</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_leapfrog_steps</code></td>
<td>
<p>Integer number of steps to run the leapfrog integrator
for. Total progress per HMC step is roughly proportional to <code>step_size * num_leapfrog_steps</code>.
Default value: <code>15</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_state</code></td>
<td>
<p>Optional Python <code>list</code> of <code>Tensor</code>s, one for each model
parameter, representing the initial state(s) of the Markov chain(s). These
should have shape <code>tf$concat(list(chain_batch_shape, param$prior$batch_shape, param$prior$event_shape))</code>.
If <code>NULL</code>, the initial state is set automatically using a sample from a variational posterior.
Default value: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initial_step_size</code></td>
<td>
<p><code>list</code> of <code>tensor</code>s, one for each model parameter,
representing the step size for the leapfrog integrator. Must
broadcast with the shape of <code>initial_state</code>. Larger step sizes lead to
faster progress, but too-large step sizes make rejection exponentially
more likely. If <code>NULL</code>, the step size is set automatically using the
standard deviation of a variational posterior. Default value: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chain_batch_shape</code></td>
<td>
<p>Batch shape (<code>list</code> or <code>int</code>) of chains to run in parallel.
Default value: <code>list()</code> (i.e., a single chain).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_variational_steps</code></td>
<td>
<p><code>int</code> number of steps to run the variational
optimization to determine the initial state and step sizes. Default value: <code>150</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variational_optimizer</code></td>
<td>
<p>Optional <code>tf$train$Optimizer</code> instance to use in
the variational optimization. If <code>NULL</code>, defaults to <code>tf$train$AdamOptimizer(0.1)</code>.
Default value: <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>variational_sample_size</code></td>
<td>
<p>integer number of Monte Carlo samples to use
in estimating the variational divergence. Larger values may stabilize
the optimization, but at higher cost per step in time and memory.
Default value: <code>1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer to seed the random number generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>name prefixed to ops created by this function. Default value: <code>NULL</code> (i.e., 'fit_with_hmc').</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This method attempts to provide a sensible default approach for fitting
StructuralTimeSeries models using HMC. It first runs variational inference as
a fast posterior approximation, and initializes the HMC sampler from the
variational posterior, using the posterior standard deviations to set
per-variable step sizes (equivalently, a diagonal mass matrix). During the
warmup phase, it adapts the step size to target an acceptance rate of 0.75,
which is thought to be in the desirable range for optimal mixing (Betancourt et al., 2014).
</p>


<h3>Value</h3>

<p>list of:
</p>

<ul>
<li>
<p> samples: <code>list</code> of <code>Tensors</code> representing posterior samples of model
parameters, with shapes <code style="white-space: pre;">⁠[concat([[num_results], chain_batch_shape, param.prior.batch_shape, param.prior.event_shape]) for param in model.parameters]⁠</code>.
</p>
</li>
<li>
<p> kernel_results: A (possibly nested) <code>list</code> of <code>Tensor</code>s representing
internal calculations made within the HMC sampler.
</p>
</li>
</ul>
<h3>References</h3>


<ul>
<li> <p><a href="https://arxiv.org/abs/1206.1901">Radford Neal. MCMC Using Hamiltonian Dynamics. <em>Handbook of Markov Chain Monte Carlo</em>, 2011.</a>
</p>
</li>
<li> <p><a href="https://arxiv.org/abs/1411.6669">M.J. Betancourt, Simon Byrne, and Mark Girolami. Optimizing The Integrator Step Size for Hamiltonian Monte Carlo.</a>
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other sts-functions: 
<code>sts_build_factored_surrogate_posterior()</code>,
<code>sts_build_factored_variational_loss()</code>,
<code>sts_decompose_by_component()</code>,
<code>sts_decompose_forecast_by_component()</code>,
<code>sts_forecast()</code>,
<code>sts_one_step_predictive()</code>,
<code>sts_sample_uniform_initial_state()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
observed_time_series &lt;-
  rep(c(3.5, 4.1, 4.5, 3.9, 2.4, 2.1, 1.2), 5) +
  rep(c(1.1, 1.5, 2.4, 3.1, 4.0), each = 7) %&gt;%
  tensorflow::tf$convert_to_tensor(dtype = tensorflow::tf$float64)
day_of_week &lt;- observed_time_series %&gt;% sts_seasonal(num_seasons = 7)
local_linear_trend &lt;- observed_time_series %&gt;% sts_local_linear_trend()
model &lt;- observed_time_series %&gt;%
  sts_sum(components = list(day_of_week, local_linear_trend))
states_and_results &lt;- observed_time_series %&gt;%
  sts_fit_with_hmc(
    model,
    num_results = 10,
    num_warmup_steps = 5,
    num_variational_steps = 15)


</code></pre>


</div>