<div class="container">

<table style="width: 100%;"><tr>
<td>gather_draws</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract draws of variables in a Bayesian model fit into a tidy data format</h2>

<h3>Description</h3>

<p>Extract draws from a Bayesian model for one or more variables (possibly with named
dimensions) into one of two types of long-format data frames.
</p>


<h3>Usage</h3>

<pre><code class="language-R">gather_draws(
  model,
  ...,
  regex = FALSE,
  sep = "[, ]",
  ndraws = NULL,
  seed = NULL,
  draw_indices = c(".chain", ".iteration", ".draw"),
  n
)

spread_draws(
  model,
  ...,
  regex = FALSE,
  sep = "[, ]",
  ndraws = NULL,
  seed = NULL,
  draw_indices = c(".chain", ".iteration", ".draw"),
  n
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>A supported Bayesian model fit. Tidybayes supports a variety of model objects;
for a full list of supported models, see tidybayes-models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Expressions in the form of
<code>variable_name[dimension_1, dimension_2, ...] | wide_dimension</code>. See <em>Details</em>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>regex</code></td>
<td>
<p>If <code>TRUE</code>, variable names are treated as regular expressions and all column matching the
regular expression and number of dimensions are included in the output. Default <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>Separator used to separate dimensions in variable names, as a regular expression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ndraws</code></td>
<td>
<p>The number of draws to return, or <code>NULL</code> to return all draws.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>A seed to use when subsampling draws (i.e. when <code>ndraws</code> is not <code>NULL</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>draw_indices</code></td>
<td>
<p>Character vector of column names that should be treated
as indices of draws. Operations are done within combinations of these values.
The default is <code>c(".chain", ".iteration", ".draw")</code>, which is the same names
used for chain, iteration, and draw indices returned by <code>tidy_draws()</code>.
Names in <code>draw_indices</code> that are not found in the data are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>(Deprecated). Use <code>ndraws</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Imagine a JAGS or Stan fit named <code>model</code>. The model may contain a variable named
<code>b[i,v]</code> (in the JAGS or Stan language) with dimension <code>i</code> in <code>1:100</code> and
dimension <code>v</code> in <code>1:3</code>. However, the default format for draws returned from
JAGS or Stan in R will not reflect this indexing structure, instead
they will have multiple columns with names like <code>"b[1,1]"</code>, <code>"b[2,1]"</code>, etc.
</p>
<p><code>spread_draws</code> and <code>gather_draws</code> provide a straightforward
syntax to translate these columns back into properly-indexed variables in two different
tidy data frame formats, optionally recovering dimension types (e.g. factor levels) as it does so.
</p>
<p><code>spread_draws</code> and <code>gather_draws</code> return data frames already grouped by
all dimensions used on the variables you specify.
</p>
<p>The difference between <code>spread_draws</code> is that names of variables in the model will
be spread across the data frame as column names, whereas <code>gather_draws</code> will
gather variables into a single column named <code>".variable"</code> and place values of variables into a
column named <code>".value"</code>. To use naming schemes from other packages (such as <code>broom</code>), consider passing
results through functions like <code>to_broom_names()</code> or <code>to_ggmcmc_names()</code>.
</p>
<p>For example, <code>spread_draws(model, a[i], b[i,v])</code> might return a grouped
data frame (grouped by <code>i</code> and <code>v</code>), with:
</p>

<ul>
<li>
<p> column <code>".chain"</code>: the chain number. <code>NA</code> if not applicable to the model
type; this is typically only applicable to MCMC algorithms.
</p>
</li>
<li>
<p> column <code>".iteration"</code>: the iteration number. Guaranteed to be unique within-chain only.
<code>NA</code> if not applicable to the model type; this is typically only applicable to MCMC algorithms.
</p>
</li>
<li>
<p> column <code>".draw"</code>: a unique number for each draw from the posterior. Order is not
guaranteed to be meaningful.
</p>
</li>
<li>
<p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li>
<p> column <code>"v"</code>: value in <code>1:10</code>
</p>
</li>
<li>
<p> column <code>"a"</code>: value of <code>"a[i]"</code> for draw <code>".draw"</code>
</p>
</li>
<li>
<p> column <code>"b"</code>: value of <code>"b[i,v]"</code> for draw <code>".draw"</code>
</p>
</li>
</ul>
<p><code>gather_draws(model, a[i], b[i,v])</code> on the same model would return a grouped
data frame (grouped by <code>i</code> and <code>v</code>), with:
</p>

<ul>
<li>
<p> column <code>".chain"</code>: the chain number
</p>
</li>
<li>
<p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li>
<p> column <code>".draw"</code>: the draw number
</p>
</li>
<li>
<p> column <code>"i"</code>: value in <code>1:5</code>
</p>
</li>
<li>
<p> column <code>"v"</code>: value in <code>1:10</code>, or <code>NA</code>
if <code>".variable"</code> is <code>"a"</code>.
</p>
</li>
<li>
<p> column <code>".variable"</code>: value in <code>c("a", "b")</code>.
</p>
</li>
<li>
<p> column <code>".value"</code>: value of <code>"a[i]"</code> (when <code>".variable"</code> is <code>"a"</code>)
or <code>"b[i,v]"</code> (when <code>".variable"</code> is <code>"b"</code>) for draw <code>".draw"</code>
</p>
</li>
</ul>
<p><code>spread_draws</code> and <code>gather_draws</code> can use type information
applied to the <code>model</code> object by <code>recover_types()</code> to convert columns
back into their original types. This is particularly helpful if some of the dimensions in
your model were originally factors. For example, if the <code>v</code> dimension
in the original data frame <code>data</code> was a factor with levels <code>c("a","b","c")</code>,
then we could use <code>recover_types</code> before <code>spread_draws</code>:
</p>
<pre>model %&gt;%
 recover_types(data) 
 spread_draws(model, b[i,v])
</pre>
<p>Which would return the same data frame as above, except the <code>"v"</code> column
would be a value in <code>c("a","b","c")</code> instead of <code>1:3</code>.
</p>
<p>For variables that do not share the same subscripts (or share
some but not all subscripts), we can supply their specifications separately.
For example, if we have a variable <code>d[i]</code> with the same <code>i</code> subscript
as <code>b[i,v]</code>, and a variable <code>x</code> with no subscripts, we could do this:
</p>
<pre>spread_draws(model, x, d[i], b[i,v])</pre>
<p>Which is roughly equivalent to this:
</p>
<pre>spread_draws(model, x) %&gt;%
 inner_join(spread_draws(model, d[i])) %&gt;%
 inner_join(spread_draws(model, b[i,v])) %&gt;%
 group_by(i,v)
</pre>
<p>Similarly, this:
</p>
<pre>gather_draws(model, x, d[i], b[i,v])</pre>
<p>Is roughly equivalent to this:
</p>
<pre>bind_rows(
 gather_draws(model, x),
 gather_draws(model, d[i]),
 gather_draws(model, b[i,v])
)</pre>
<p>The <code>c</code> and <code>cbind</code> functions can be used to combine multiple variable names that have
the same dimensions. For example, if we have several variables with the same
subscripts <code>i</code> and <code>v</code>, we could do either of these:
</p>
<pre>spread_draws(model, c(w, x, y, z)[i,v])</pre>
<pre>spread_draws(model, cbind(w, x, y, z)[i,v])  # equivalent</pre>
<p>Each of which is roughly equivalent to this:
</p>
<pre>spread_draws(model, w[i,v], x[i,v], y[i,v], z[i,v])</pre>
<p>Besides being more compact, the <code>c()</code>-style syntax is currently also
faster (though that may change).
</p>
<p>Dimensions can be omitted from the resulting data frame by leaving their names
blank; e.g. <code>spread_draws(model, b[,v])</code> will omit the first dimension of
<code>b</code> from the output. This is useful if a dimension is known to contain all
the same value in a given model.
</p>
<p>The shorthand <code>..</code> can be used to specify one column that should be put
into a wide format and whose names will be the base variable name, plus a dot
("."), plus the value of the dimension at <code>..</code>. For example:
</p>
<p><code>spread_draws(model, b[i,..])</code> would return a grouped data frame
(grouped by <code>i</code>), with:
</p>

<ul>
<li>
<p> column <code>".chain"</code>: the chain number
</p>
</li>
<li>
<p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li>
<p> column <code>".draw"</code>: the draw number
</p>
</li>
<li>
<p> column <code>"i"</code>: value in <code>1:20</code>
</p>
</li>
<li>
<p> column <code>"b.1"</code>: value of <code>"b[i,1]"</code> for draw <code>".draw"</code>
</p>
</li>
<li>
<p> column <code>"b.2"</code>: value of <code>"b[i,2]"</code> for draw <code>".draw"</code>
</p>
</li>
<li>
<p> column <code>"b.3"</code>: value of <code>"b[i,3]"</code> for draw <code>".draw"</code>
</p>
</li>
</ul>
<p>An optional clause in the form <code style="white-space: pre;">⁠| wide_dimension⁠</code> can also be used to put
the data frame into a wide format based on <code>wide_dimension</code>. For example, this:
</p>
<pre>spread_draws(model, b[i,v] | v)</pre>
<p>is roughly equivalent to this:
</p>
<pre>spread_draws(model, b[i,v]) %&gt;% spread(v,b)</pre>
<p>The main difference between using the <code>|</code> syntax instead of the
<code>..</code> syntax is that the <code>|</code> syntax respects prototypes applied to
dimensions with <code>recover_types()</code>, and thus can be used to get
columns with nicer names. For example:
</p>
<div class="sourceCode"><pre>model %&gt;% recover_types(data) %&gt;% spread_draws(b[i,v] | v)
</pre></div>
<p>would return a grouped data frame
(grouped by <code>i</code>), with:
</p>

<ul>
<li>
<p> column <code>".chain"</code>: the chain number
</p>
</li>
<li>
<p> column <code>".iteration"</code>: the iteration number
</p>
</li>
<li>
<p> column <code>".draw"</code>: the draw number
</p>
</li>
<li>
<p> column <code>"i"</code>: value in <code>1:20</code>
</p>
</li>
<li>
<p> column <code>"a"</code>: value of <code>"b[i,1]"</code> for draw <code>".draw"</code>
</p>
</li>
<li>
<p> column <code>"b"</code>: value of <code>"b[i,2]"</code> for draw <code>".draw"</code>
</p>
</li>
<li>
<p> column <code>"c"</code>: value of <code>"b[i,3]"</code> for draw <code>".draw"</code>
</p>
</li>
</ul>
<p>The shorthand <code>.</code> can be used to specify columns that should be nested
into vectors, matrices, or n-dimensional arrays (depending on how many dimensions
are specified with <code>.</code>).
</p>
<p>For example, <code>spread_draws(model, a[.], b[.,.])</code> might return a
data frame, with:
</p>

<ul>
<li>
<p> column <code>".chain"</code>: the chain number.
</p>
</li>
<li>
<p> column <code>".iteration"</code>: the iteration number.
</p>
</li>
<li>
<p> column <code>".draw"</code>: a unique number for each draw from the posterior.
</p>
</li>
<li>
<p> column <code>"a"</code>: a list column of vectors.
</p>
</li>
<li>
<p> column <code>"b"</code>: a list column of matrices.
</p>
</li>
</ul>
<p>Ragged arrays are turned into non-ragged arrays with
missing entries given the value <code>NA</code>.
</p>
<p>Finally, variable names can be regular expressions by setting <code>regex = TRUE</code>; e.g.:
</p>
<pre>spread_draws(model, `b_.*`[i], regex = TRUE)</pre>
<p>Would return a tidy data frame with variables starting with <code>b_</code> and having one dimension.
</p>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Matthew Kay
</p>


<h3>See Also</h3>

<p><code>spread_rvars()</code>, <code>recover_types()</code>, <code>compose_data()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(dplyr)
library(ggplot2)

data(RankCorr, package = "ggdist")

RankCorr %&gt;%
  spread_draws(b[i, j])

RankCorr %&gt;%
  spread_draws(b[i, j], tau[i], u_tau[i])


RankCorr %&gt;%
  gather_draws(b[i, j], tau[i], u_tau[i])

RankCorr %&gt;%
  gather_draws(tau[i], typical_r) %&gt;%
  median_qi()

</code></pre>


</div>