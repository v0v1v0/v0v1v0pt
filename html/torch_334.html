<div class="container">

<table style="width: 100%;"><tr>
<td>nn_upsample</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Upsample module</h2>

<h3>Description</h3>

<p>Upsamples a given multi-channel 1D (temporal), 2D (spatial) or 3D (volumetric) data.
The input data is assumed to be of the form minibatch x channels x optional depth x
optional height] x width. Hence, for spatial inputs, we expect a 4D Tensor and for
volumetric inputs, we expect a 5D Tensor.
</p>


<h3>Usage</h3>

<pre><code class="language-R">nn_upsample(
  size = NULL,
  scale_factor = NULL,
  mode = "nearest",
  align_corners = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>
<p>(int or <code>Tuple[int]</code> or <code>Tuple[int, int]</code> or <code>Tuple[int, int, int]</code>, optional):
output spatial sizes</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_factor</code></td>
<td>
<p>(float or <code>Tuple[float]</code> or <code>Tuple[float, float]</code> or <code>Tuple[float, float, float]</code>, optional):
multiplier for spatial size. Has to match input size if it is a tuple.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>(str, optional): the upsampling algorithm: one of <code>'nearest'</code>,
<code>'linear'</code>, <code>'bilinear'</code>, <code>'bicubic'</code> and <code>'trilinear'</code>.
Default: <code>'nearest'</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>align_corners</code></td>
<td>
<p>(bool, optional): if <code>TRUE</code>, the corner pixels of the input
and output tensors are aligned, and thus preserving the values at
those pixels. This only has effect when <code>mode</code> is
<code>'linear'</code>, <code>'bilinear'</code>, or <code>'trilinear'</code>. Default: <code>FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The algorithms available for upsampling are nearest neighbor and linear, bilinear,
bicubic and trilinear for 3D, 4D and 5D input Tensor, respectively.
</p>
<p>One can either give a scale_factor or the target output size to calculate the
output size. (You cannot give both, as it is ambiguous)
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
input &lt;- torch_arange(start = 1, end = 4, dtype = torch_float())$view(c(1, 1, 2, 2))
nn_upsample(scale_factor = c(2), mode = "nearest")(input)
nn_upsample(scale_factor = c(2, 2), mode = "nearest")(input)
}
</code></pre>


</div>