<div class="container">

<table style="width: 100%;"><tr>
<td>Tinflex.setup</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Create Tinflex Generator Objects 
</h2>

<h3>Description</h3>

<p>Create a generator object of class <code>"Tinflex"</code> or
<code>"TinflexC"</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Tinflex.setup(lpdf, dlpdf, d2lpdf=NULL, ib, cT=0, rho=1.1, max.intervals=1001)
Tinflex.setup.C(lpdf, dlpdf, d2lpdf=NULL, ib, cT=0, rho=1.1, max.intervals=1001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lpdf</code></td>
<td>
<p>log-density of targent distribution. (function)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dlpdf</code></td>
<td>
<p>first derivative of log-density. (function)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d2lpdf</code></td>
<td>
<p>second derivative of log-density. (function, optional)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ib</code></td>
<td>
<p>break points for partition of domain of log-density.
(numeric vector of length greater than 1)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cT</code></td>
<td>
<p>parameter for transformation <code class="reqn">T_c</code>.
(numeric vector of length 1 or of length <code>length(ib)-1</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rho</code></td>
<td>
<p>performance parameter:
requested upper bound for ratio of area below hat to area
below squeeze. (numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.intervals</code></td>
<td>
<p>maximal numbers of intervals. (numeric)</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Algorithm <code>Tinflex</code> is a flexible algorithm that works (in
theory) for all distributions that have a piecewise twice
differentiable density function.
The algorithm is based on the transformed density rejection algorithm
which is a variant of the acceptance-rejection algorithm where
the density of the targent distribution is transformed by means of
some transformation <code class="reqn">T_c</code>.
Hat and squeeze functions of the density are then constructed by means
of tangents and secants.
</p>
<p>The algorithm uses family <code class="reqn">T_c</code>
of transformations, where
</p>
<p style="text-align: center;"><code class="reqn">T_c(x) = \left\{\begin{array}{lcl}%
    \log(x) &amp; \quad &amp; \mbox{for $c=0\,,$}\\
    \mbox{sign}(c)\; x^c &amp;&amp; \mbox{for $c\not=0\,.$}
    \end{array}\right.</code>
</p>

<p>Parameter <code class="reqn">c</code> is given by argument <code>cT</code>.
</p>
<p>The algorithm requires the following input from the user:
</p>

<ul>
<li>
<p> the log-density of the targent distribution, <code>lpdf</code>;
</p>
</li>
<li>
<p> its first derivative <code>dlpdf</code>;
</p>
</li>
<li>
<p> its second derivative <code>d2lpdf</code> (optionally);
</p>
</li>
<li>
<p> a starting partition <code>ib</code> of the domain of the target
distribution such that each subinterval contains at most one
inflection point of the transformed density;
</p>
</li>
<li>
<p> the parameter(s) <code>cT</code> of the transformation either for
the entire domain or alternatively for each of the subintervals of
the partition.
</p>
</li>
</ul>
<p>The starting partition of the domain of the target distribution into
non-overlapping intervals has to satisfy the following conditions:
</p>

<ul>
<li>
<p> The partition points must be given in ascending order
(otherwise they are sorted anyway).
</p>
</li>
<li>
<p> The first and last entry of this vector are the boundary
points of the domain of the distribution.
In the case when the domain of the distribution is unbounded, the
respective points are <code>-Inf</code> and <code>Inf</code>.
</p>
</li>
<li>
<p> Within each interval of the partition, the transformed density
possesses at most one inflection point (including all finite
boundary points).
</p>
</li>
<li>
<p> If a boundary point is infinite, or the density vanishes at the
boundary point, then the transformed density must be concave near
the corresponding boundary point and in the corresponding tail,
respectively.
</p>
</li>
<li>
<p> If the log-density <code>lpdf</code> has a pole or cusp at some
point <code class="reqn">x</code>, then this must be added to the starting partition
point. Moreover, it has to be counted as inflection point.
Moreover, in the corresponding intervals the transformed density
must be convex.
</p>
</li>
</ul>
<p>Argument <code>d2lpdf</code> is optional. If <code>d2lpdf=NULL</code>, then
a variant of the method is used, that determines intervals where the
transformed density is concave or convex without means of the second
derivative of the log-density.
</p>
<p>Parameter <code>cT</code> is either a single numeric, that is, the same
transformation <code class="reqn">T_c</code>
is used for all subintervals of the domain,
or it can be set independently for each of these intervals.
In the latter case <code>length(cT)</code> must be equal to the number of
intervals, that is, equal to <code>length(ib)-1</code>.
For the choice of <code>cT</code> the following should be taken into
consideration:
</p>

<ul>
<li> <p><code>cT=0</code> (the default) is most robust against numeric
underflow or overflow.
</p>
</li>
<li> <p><code>cT=-0.5</code> has the fastest marginal generation time.
</p>
</li>
<li>
<p> One should always use <code>cT=0</code> or <code>cT=-0.5</code> 
for intervals that contain a point where the derivative of the
(log-) density vanishes (e.g., an extremum). For other values of
<code>cT</code>, the algorithm is less accurate.
</p>
</li>
<li>
<p> For unbounded intervals <code class="reqn">(-\inf,a]</code> or
<code class="reqn">[a,\inf)</code>, one has to select <code>cT</code> such that
<code class="reqn">0 \ge c_T &gt; -1</code>.
</p>
</li>
<li>
<p> For an interval that contains a pole at one of its boundary
points (i.e., there the density is unbounded), one has to select
<code>cT</code> such that <code class="reqn">c_T &lt; -1</code> and the
transformed density is convex.
</p>
</li>
<li>
<p> If the transformed density is concave in some interval for a
particular value of <code>cT</code>, then it is concave for all smaller
values of <code>cT</code>.




</p>
</li>
</ul>
<p>Parameter <code>rho</code> is a performance parameter. It defines an upper
bound for ratio of the area below the hat function to the area below
the squeeze function. This parameter is an upper bound of the
rejection constant. More importantly, it provides an approximation to
the number of (time consuming) evalutions of the log-density
function <code>lpdf</code>.
For <code>rho=1.01</code>, the log-density function is evaluated once for a
sample of 300 random points. However, values of <code>rho</code> close to 1
also increase the table size and thus make the setup more expensive.
</p>
<p>Parameter <code>max.intervals</code> defines the maximal number of
subintervals and thus the maximal table size. Putting an upper bound
on the table size prevents the algorithm from accidentally exhausting
all of the computer memory due to invalid input.
It is very unlikely that one has to increase the default value.
</p>


<h3>Value</h3>

<p>Routine <code>Tinflex.setup</code> returns an 
object of class <code>"Tinflex"</code> that stores the random variate
generator (density, hat and squeeze functions, cumulated areas below
hat). For details see sources of the algorithm or execute
<code>print(gen,debug=TRUE)</code> with an object <code>gen</code> of class
<code>"Tinflex"</code>.
</p>
<p>Routine <code>Tinflex.setup.C</code> is equivalent to <code>Tinflex.setup</code>
but does all computations entirely in C. It returns an object of class
<code>"TinflexC"</code> which is equivalent to class <code>"Tinflex"</code> but
stores all data in an C structure instead of an R list.
</p>


<h3>Warning </h3>

<p>It is very important to note that the user is responsible for the
correctness of the supplied arguments. Since the algorithm works (in theory)
for all distributions with piecewise twice differentiable density
functions, it is not possible to detect improper arguments. It is thus
recommended that the user inspect the generator object visually by
means of the <code>plot</code> method (see <code>plot.Tinflex</code> for
details).
</p>


<h3>Author(s)</h3>

<p>Josef Leydold <a href="mailto:josef.leydold@wu.ac.at">josef.leydold@wu.ac.at</a>, Carsten Botts and
Wolfgang Hörmann.
</p>


<h3>References</h3>

<p>C. Botts, W. Hörmann, and J. Leydold (2013),
Transformed Density Rejection with Inflection Points,
Statistics and Computing 23(2), 251–260,
<a href="https://doi.org/10.1007/s11222-011-9306-4">doi:10.1007/s11222-011-9306-4</a>.
See also 
Research Report Series / Department of Statistics and Mathematics
Nr. 110, Department of Statistics and Mathematics,
WU Vienna University of Economics and Business,
<a href="https://epub.wu.ac.at/id/eprint/3158">https://epub.wu.ac.at/id/eprint/3158</a>.
</p>
<p>W. Hörmann, and J. Leydold (2022),
A Generalized Transformed Density Rejection Algorithm,
in: Advances in Modeling and Simulation, Ch. 14,
<a href="https://doi.org/10.1007/978-3-031-10193-9_14">doi:10.1007/978-3-031-10193-9_14</a>, accepted for publication..
See also 
Research Report Series / Department of Statistics and Mathematics
Nr. 135, Department of Statistics and Mathematics, 
WU Vienna University of Economics and Business,
<a href="https://research.wu.ac.at/de/publications/a-generalized-transformed-density-rejection-algorithm">https://research.wu.ac.at/de/publications/a-generalized-transformed-density-rejection-algorithm</a>.
</p>


<h3>See Also</h3>

<p>See <code>Tinflex.sample</code> for drawing random samples,
<code>plot.Tinflex</code> and <code>print.Tinflex</code> for
printing and plotting objects of class <code>"Tinflex"</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Example 1: Bimodal density
##   Density  f(x) = exp( -|x|^alpha + s*|x|^beta + eps*|x|^2 )
##   with alpha &gt; beta &gt;= 2 and s, eps &gt; 0

alpha &lt;- 4.2
beta &lt;- 2.1
s &lt;- 1
eps &lt;- 0.1

## Log-density and its derivatives.
lpdf   &lt;- function(x) { -abs(x)^alpha + s*abs(x)^beta + eps*abs(x)^2 }
dlpdf  &lt;- function(x) { (sign(x) * (-alpha*abs(x)^(alpha-1)
                           + s*beta*abs(x)^(beta-1) + 2*eps*abs(x))) }
d2lpdf &lt;- function(x) { (-alpha*(alpha-1)*abs(x)^(alpha-2)
                          + s*beta*(beta-1)*abs(x)^(beta-2) + 2*eps) }

## Parameter cT=0 (default):
##   There are two inflection points on either side of 0.
ib &lt;- c(-Inf, 0, Inf)

## Create generator object.
gen &lt;- Tinflex.setup.C(lpdf, dlpdf, d2lpdf, ib=c(-Inf,0,Inf), rho=1.1)

## Print data about generator object.
print(gen)

## Draw a random sample
Tinflex.sample(gen, n=10)

## Inspect hat and squeeze visually in original scale
plot(gen, from=-2.5, to=2.5)
## ... and in transformed (log) scale.
plot(gen, from=-2.5, to=2.5, is.trans=TRUE)

## With Version 2.0 the setup also works without providing the
## second derivative of the log-density
gen &lt;- Tinflex.setup.C(lpdf, dlpdf, d2lpdf=NULL, ib=c(-Inf,0,Inf), rho=1.1)
Tinflex.sample(gen, n=10)

## -------------------------------------------------------------------
## Example 2: Exponential Power Distribution
##   Density  f(x) = exp( -|x|^alpha )
##   with alpha &gt; 0  [ &gt;= 0.015 due to limitations of FPA ]

alpha &lt;- 0.5

## Log-density and its derivatives.
lpdf   &lt;- function(x) { -abs(x)^alpha }
dlpdf  &lt;- function(x) { if (x==0) {0} else {-sign(x) * alpha*abs(x)^(alpha-1)}}
d2lpdf &lt;- function(x) { -alpha*(alpha-1)*abs(x)^(alpha-2) }

## Parameter cT=-0.5:
##   There are two inflection points on either side of 0 and
##   a cusp at 0. Thus we need a partition point that separates
##   the inflection points from the cusp.
ib &lt;- c(-Inf, -(1-alpha)/2, 0, (1-alpha)/2, Inf)

## Create generator object with c = -0.5.
gen &lt;- Tinflex.setup.C(lpdf, dlpdf, d2lpdf, ib=ib, cT=-0.5, rho=1.1)

## Print data about generator object.
print(gen)

## Draw a random sample.
Tinflex.sample(gen, n=10)

## Inspect hat and squeeze visually in original scale
plot(gen, from=-4, to=4)
## ... and in transformed (log) scale.
plot(gen, from=-4, to=4, is.trans=TRUE)

## With Version 2.0 the setup also works without providing the
## second derivative of the log-density
gen &lt;- Tinflex.setup.C(lpdf, dlpdf, d2lpdf=NULL, ib=ib, cT=-0.5, rho=1.1)
Tinflex.sample(gen, n=10)

## -------------------------------------------------------------------
## Example 3: Generalized Inverse Gaussian Distribution
##   Density  f(x) = x^(lambda-1) * exp(-omega/2 * (x+1/x))   x&gt;= 0
##   with 0 &lt; lambda &lt; 1 and 0 &lt; omega &lt;= 0.5

la &lt;- 0.4     ## lambda
om &lt;- 1.e-7   ## omega

## Log-density and its derivatives.
lpdf   &lt;- function(x) { ifelse (x==0., -Inf, ((la - 1) * log(x) - om/2*(x+1/x))) }
dlpdf  &lt;- function(x) { if (x==0) { Inf} else {(om + 2*(la-1)*x-om*x^2)/(2*x^2)} }
d2lpdf &lt;- function(x) { if (x==0) {-Inf} else {-(om - x + la*x)/x^3} }

## Parameter cT=0 near 0 and cT=-0.5 at tail:
ib &lt;- c(0, (3/2*om/(1-la) + 2/9*(1-la)/om), Inf)
cT &lt;- c(0,-0.5)

## Create generator object.
gen &lt;- Tinflex.setup.C(lpdf, dlpdf, d2lpdf, ib=ib, cT=cT, rho=1.1)

## Print data about generator object.
print(gen)

## Draw a random sample.
Tinflex.sample(gen, n=10)

## Inspect hat and squeeze visually in original scale
plot(gen, from=0, to=5)

## With Version 2.0 the setup also works without providing the
## second derivative of the log-density
gen &lt;- Tinflex.setup.C(lpdf, dlpdf, d2lpdf=NULL, ib=ib, cT=cT, rho=1.1)
Tinflex.sample(gen, n=10)

</code></pre>


</div>