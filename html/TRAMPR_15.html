<div class="container">

<table style="width: 100%;"><tr>
<td>group.knowns</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Knowns Clustering</h2>

<h3>Description</h3>

<p>Group a <code>TRAMPknowns</code> object so that knowns
with similar TRFLP patterns and knowns that share the same species
name “group” together. In general, this function will be called
automatically whenever appropriate (e.g. when loading a data set or
adding new knowns).  Please see Details to understand why this
function is necessary, and how it works.
</p>
<p>The main reason for manually calling <code>group.knowns</code> is to change
the default values of the arguments; if you call <code>group.knowns</code>
on a <code>TRAMPknowns</code> object, then any subsequent automatic call to
<code>group.knowns</code> will use any arguments you passed in the
manual <code>group.knowns</code> call (e.g. after doing
<code>group.knowns(x, cut.height=20)</code>, all future groupings will use
<code>cut.height=20</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">group.knowns(x, ...)
## S3 method for class 'TRAMPknowns'
group.knowns(x, dist.method, hclust.method, cut.height, ...)
## S3 method for class 'TRAMP'
group.knowns(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A <code>TRAMPknowns</code> or <code>TRAMP</code> object,
containing identified TRFLP patterns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist.method</code></td>
<td>
<p>Distance method used in calculating similarity
between different knowns (see <code>dist</code>).  Valid options
include <code>"maximum"</code>, <code>"euclidian"</code> and
<code>"manhattan"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hclust.method</code></td>
<td>
<p>Clustering method used in generating clusters
from the similarity matrix (see <code>hclust</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut.height</code></td>
<td>
<p>Passed to <code>cutree</code>; controls how similar
members of each group should be (the larger <code>cut.height</code>, the
more inclusive knowns groups will be).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to further methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>group.knowns</code> groups together knowns in a
<code>TRAMPknowns</code> object based on two criteria: (1) TRFLP
profiles that are very similar across shared enzyme/primer
combinations (based on clustering) and (2) TRFLP profiles that belong
to the same species (i.e. share a common <code>species</code> column in the
<code>info</code> data.frame of <code>x</code>; see <code>TRAMPknowns</code> for
more information).  This is to solve three issues in TRFLP analysis:
</p>

<ol>
<li>
<p> The TRFLP profile of a single species can have variation in
peak sizes due to DNA sequence variation.  By including multiple
collections of each species, variation in TRFLP profiles can be
accounted for.  If a <code>TRAMPknowns</code> object contains
multiple collections of a species, these will be aggregated by
<code>group.knowns</code>.  This aggregation is essential for community
analysis, as leaving individual collections will artificially
inflate the number of “present species” when running
<code>TRAMP</code>.
</p>
<p>Some authors have taken an alternative approach by using a larger
tolerance in matching peaks between samples and knowns (effectively
increasing <code>accept.error</code> in <code>TRAMP</code>) to account
for within-species variation.  This is not recommended, as it
dramatically increases the risk of incorrect matches.
</p>
</li>
<li>
<p> Distinctly different TRFLP profiles may occur within a species
(or in some cases within an individual); see Avis et al. (2006).
<code>group.knowns</code> looks at the <code>species</code> column of the
<code>info</code> data.frame of <code>x</code> and joins any knowns with
identical <code>species</code> values as a group.



This can also be used where multiple profiles are present in an
individual.
</p>
</li>
<li>
<p> Different species may share a similar TRFLP profile and
therefore be indistinguishable using TRFLP. If these patterns are
not grouped, two species will be recorded as present wherever either
is present. <code>group.knowns</code> prevents this by joining knowns with
“very similar” TRFLP patterns as a group.  Ideally, these
problematic groups can be resolved by increasing the number of
enzyme/primer pairs in the data.
</p>
</li>
</ol>
<p>Groups names are generated by concatenating all unique (sorted)
species names together, separated by commas.
</p>
<p>To determine if knowns are “similar enough” to form a group, we
use <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>'s clustering tools: <code>dist</code>, <code>hclust</code>
and <code>cutree</code>.  First, we generate a distance matrix of the
knowns profiles using <code>dist</code>, and using method
<code>dist.method</code> (see Example below; this is very similar to what
<code>TRAMP</code> does, and <code>dist.method</code> should be specified
accordingly).  We then generate clusters using <code>hclust</code>,
and using method <code>hclust.method</code>, and “cut” the tree at
<code>cut.height</code> using <code>cutree</code>.
</p>
<p>Knowns are grouped together iteratively; so that all groups sharing a
common cluster are grouped together, and all knowns that share a
common species name are grouped together.  In certain cases this may
chain together seemingly unrelated groups.
</p>
<p>Because <code>group.knowns</code> is generic, it can be run on either a
<code>TRAMPknowns</code> or a <code>TRAMP</code> object.  When run
on a <code>TRAMP</code> object, it updates the <code>TRAMPknowns</code> object
(stored as <code>x$knowns</code>), so that subsequent calls to
<code>plot.TRAMPknowns</code> or <code>summary.TRAMPknowns</code>
(for example) will use the new grouping parameters.
</p>
<p>Parameters set by <code>group.knowns</code> are retained as part of the
object, so that when adding additional knowns (<code>add.known</code>
and <code>combine</code>), or when subsetting a knowns database (see
<code>[.TRAMPknowns</code>, 
aka <code>TRAMPindexing</code>), the same grouping parameters will be
used.
</p>


<h3>Value</h3>

<p>For <code>group.knowns.TRAMPknowns</code>, a new <code>TRAMPknowns</code> object.
The <code>cluster.pars</code> element will have been updated with new
parameters, if any were specified.
</p>
<p>For <code>group.knowns.TRAMP</code>, a new <code>TRAMP</code> object, with an
updated <code>knowns</code> element.  Note that the <em>original</em>
<code>TRAMPknowns</code> object (i.e. the one from which the <code>TRAMP</code>
object was constructed) will <code>not</code> be modified.
</p>


<h3>Warning</h3>

<p>Warning about missing data: where there are <code>NA</code> values in
certain combinations, <code>NA</code>s may be present in the final distance
matrix, which means we cannot use <code>hclust</code> to generate the
clusters!  In general, <code>NA</code> values are fine.  They just can't be
everywhere.
</p>


<h3>References</h3>

<p>Avis PG, Dickie IA, Mueller GM 2006. A ‘dirty’ business:
testing the limitations of terminal restriction fragment length
polymorphism (TRFLP) analysis of soil fungi. Molecular Ecology
15: 873-882.
</p>


<h3>See Also</h3>

<p><code>TRAMPknowns</code>, which describes the <code>TRAMPknowns</code>
object.
</p>
<p><code>build.knowns</code>, which attempts to generate a knowns
database from a <code>TRAMPsamples</code> data set.
</p>
<p><code>plot.TRAMPknowns</code>, which graphically displays the
relationships between knowns.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(demo.knowns)
data(demo.samples)

demo.knowns &lt;- group.knowns(demo.knowns, cut.height=2.5)
plot(demo.knowns)

## Increasing cut.height makes groups more inclusive:
plot(group.knowns(demo.knowns, cut.height=100))

res &lt;- TRAMP(demo.samples, demo.knowns)
m1.ungrouped &lt;- summary(res)
m1.grouped &lt;- summary(res, group=TRUE)
ncol(m1.grouped) # 94 groups

res2 &lt;- group.knowns(res, cut.height=100)
m2.ungrouped &lt;- summary(res2)
m2.grouped &lt;- summary(res2, group=TRUE)
ncol(m2.grouped) # Now only 38 groups

## group.knowns results in the same distance matrix as produced by
## TRAMP, therefore using the same method (e.g. method="maximum") is
## important.  The example below shows how the matrix produced by
## dist(summary(x)) (as calculated by group.knowns) is the same as that
## produced by TRAMP:
f &lt;- function(x, method="maximum") {
  ## Create a pseudo-samples object from our knowns
  y &lt;- x
  y$data$height &lt;- 1
  names(y$info)[names(y$info) == "knowns.pk"] &lt;- "sample.pk"
  names(y$data)[names(y$data) == "knowns.fk"] &lt;- "sample.fk"
  class(y) &lt;- "TRAMPsamples"

  ## Run TRAMP, clean up and return
  ## (If method != "maximum", rescale the error to match that
  ## generated by dist()).
  z &lt;- TRAMP(y, x, method=method)
  if ( method != "maximum" ) z$error &lt;- z$error * z$n
  names(dimnames(z$error)) &lt;- NULL
  z
}

g &lt;- function(x, method="maximum")
  as.matrix(dist(summary(x), method=method))

all.equal(f(demo.knowns, "maximum")$error,   g(demo.knowns, "maximum"))
all.equal(f(demo.knowns, "euclidian")$error, g(demo.knowns, "euclidian"))
all.equal(f(demo.knowns, "manhattan")$error, g(demo.knowns, "manhattan"))

## However, TRAMP is over 100 times slower in this special case.
system.time(f(demo.knowns))
system.time(g(demo.knowns))
</code></pre>


</div>