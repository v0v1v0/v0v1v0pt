<div class="container">

<table style="width: 100%;"><tr>
<td>tf_map</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2><code>tf.map_fn()</code></h2>

<h3>Description</h3>

<p>Thin wrapper around <code>tf.map_fn()</code> with the following
differences:
</p>

<ul>
<li>
<p> accepts <code>purrr</code> style <code>~</code> lambda syntax to define function <code>fn</code>.
</p>
</li>
<li>
<p> The order of <code>elems</code> and <code>fn</code> is switched to make it more pipe <code style="white-space: pre;">⁠%&gt;%⁠</code>
friendly and consistent with R mappers <code>lapply()</code> and <code>purrr::map()</code>.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">tf_map(
  elems,
  fn,
  dtype = NULL,
  parallel_iterations = NULL,
  back_prop = TRUE,
  swap_memory = FALSE,
  infer_shape = TRUE,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>elems</code></td>
<td>
<p>A tensor or (possibly nested) sequence of tensors, each of which
will be unpacked along their first dimension. The nested sequence of the
resulting slices will be applied to <code>fn</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>An R function, specified using <code>purrr</code> style ~ syntax, a character
string, a python function (or more generally, any python object with a
<code style="white-space: pre;">⁠__call__⁠</code> method) or anything coercible via <code>as.function()</code>. The function
will be be called with one argument, which will have the same (possibly
nested) structure as <code>elems</code>. Its output must return the same structure as
<code>dtype</code> if one is provided, otherwise it must return the same structure as
<code>elems</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dtype</code></td>
<td>
<p>(optional) The output type(s) of fn. If fn returns a structure
of Tensors differing from the structure of elems, then dtype is not
optional and must have the same structure as the output of fn.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel_iterations</code></td>
<td>
<p>(optional) The number of iterations allowed to
run in parallel. When graph building, the default value is 10. While
executing eagerly, the default value is set to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>back_prop</code></td>
<td>
<p>(optional) True enables support for back propagation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swap_memory</code></td>
<td>
<p>(optional) True enables GPU-CPU memory swapping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>infer_shape</code></td>
<td>
<p>(optional) False disables tests for consistent output
shapes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>(optional) Name prefix for the returned tensors.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A tensor or (possibly nested) sequence of tensors. Each tensor packs
the results of applying fn to tensors unpacked from elems along the first
dimension, from first to last.
</p>


</div>