<div class="container">

<table style="width: 100%;"><tr>
<td>sort</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sort a 'timeSeries' by time stamps</h2>

<h3>Description</h3>

<p>Sort a <code>"timeSeries"</code> object with respect to its time stamps.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'timeSeries'
sort(x, decreasing = FALSE, ...)

## S4 method for signature 'timeSeries'
is.unsorted(x, na.rm = FALSE, strictly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a <code>"timeSeries"</code> object.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decreasing</code></td>
<td>

<p>a logical flag. Should we sort in increasing or decreasing order?
By default <code>FALSE</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>

<p>a logical value, should missing values be removed?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>strictly</code></td>
<td>

<p>logical indicating if the check should be for strictly increasing
values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>optional arguments passed to other methods.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The method for <code>sort</code> sorts <code>x</code> either in increasing or
decreasing time stamp order.
</p>
<p>The method for <code>is.unsorted</code> returns <code>TRUE</code> if the time
stamps of <code>x</code> are not sorted in increasing order (including the
case when they are sorted in decreasing order) and <code>FALSE</code>
otherwise. <code>is.unsorted</code> may also return <code>NA</code> when there are
<code>NA</code>s among the time stamps of <code>x</code>.
</p>
<p>All this is in line with the documented functionality of
<code>base::is.unsorted</code>.
</p>


<h3>Value</h3>

<p>for <code>sort</code>, a <code>"timeSeries"</code> object,
</p>
<p>for the <code>is.unsorted</code> method, <code>TRUE</code>, <code>FALSE</code>, or
<code>NA</code>, as described in section ‘Details’.
</p>


<h3>Note</h3>

<p>If <code>is.unsorted</code> returns <code>NA</code> when there are <code>NA</code>s in
the data but not in the time stamps use <code>library{timeSeries}</code> or
call the function as <code>timeSeries::is.unsorted</code>. If you need more
details, read the rest of this note.
</p>
<p><code>base::is.unsorted</code> 'sees' the method for <code>"timeSeries"</code>
objects when package timeSeries is loaded (whether or not it is
attached). However, due to the way <code>base::is.unsorted</code> is
implemented, it may give wrong answers when there are <code>NA</code>'s
among the values of the time series. Developers of packages applying
<code>is.unsorted</code> on timeSeries objects should import if from package
timeSeries.
</p>
<p>The above feature is not a shortcoming of <code>base::is.unsorted</code> but
a consequence of the fact that the timeSeries method is not consistent
with its semantics. For example, it works on the time stamps, while
<code>is.na</code> works on the data values.
</p>


<h3>See Also</h3>

<p><code>is.unsorted</code> for further details on the <code>NA</code> case
</p>


<h3>Examples</h3>

<pre><code class="language-R">   
## a monthly calendar series
x &lt;- daily2monthly(LPP2005REC[, 1:2])[3:14, ]
   

## resample the series with respect to the time stamps,
resampled &lt;- sample(x)
## the time stamps are unordered
resampled
is.unsorted(resampled) # TRUE (i.e., not sorted)
   
## Now sort the series in decreasing time order
backward_in_time &lt;- sort(resampled, , decreasing = TRUE)
## time stamps ordered in decreasing order
## but is.unordered requires increasing order:
backward_in_time
is.unsorted(backward_in_time) # still TRUE
   
## Is the reverted series ordered?
forward_in_time &lt;- rev(backward_in_time)
forward_in_time
is.unsorted(forward_in_time) # FALSE (i.e., sorted)
</code></pre>


</div>