<div class="container">

<table style="width: 100%;"><tr>
<td>analyze_vars_in_cols</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Analyze numeric variables in columns</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt="[Experimental]"></a>
</p>
<p>The layout-creating function <code>analyze_vars_in_cols()</code> creates a layout element to generate a column-wise
analysis table.
</p>
<p>This function sets the analysis methods as column labels and is a wrapper for <code>rtables::analyze_colvars()</code>.
It was designed principally for PK tables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">analyze_vars_in_cols(
  lyt,
  vars,
  ...,
  .stats = c("n", "mean", "sd", "se", "cv", "geom_cv"),
  .labels = c(n = "n", mean = "Mean", sd = "SD", se = "SE", cv = "CV (%)", geom_cv =
    "CV % Geometric Mean"),
  row_labels = NULL,
  do_summarize_row_groups = FALSE,
  split_col_vars = TRUE,
  imp_rule = NULL,
  avalcat_var = "AVALCAT1",
  cache = FALSE,
  .indent_mods = NULL,
  na_str = default_na_str(),
  nested = TRUE,
  .formats = NULL,
  .aligns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lyt</code></td>
<td>
<p>(<code>PreDataTableLayouts</code>)<br> layout that analyses will be added to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vars</code></td>
<td>
<p>(<code>character</code>)<br> variable names for the primary analysis variable to be iterated over.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments for the lower level functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.stats</code></td>
<td>
<p>(<code>character</code>)<br> statistics to select for the table.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.labels</code></td>
<td>
<p>(named <code>character</code>)<br> labels for the statistics (without indent).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_labels</code></td>
<td>
<p>(<code>character</code>)<br> as this function works in columns space, usually <code>.labels</code>
character vector applies on the column space. You can change the row labels by defining this
parameter to a named character vector with names corresponding to the split values. It defaults
to <code>NULL</code> and if it contains only one <code>string</code>, it will duplicate that as a row label.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_summarize_row_groups</code></td>
<td>
<p>(<code>flag</code>)<br> defaults to <code>FALSE</code> and applies the analysis to the current
label rows. This is a wrapper of <code>rtables::summarize_row_groups()</code> and it can accept <code>labelstr</code>
to define row labels. This behavior is not supported as we never need to overload row labels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_col_vars</code></td>
<td>
<p>(<code>flag</code>)<br> defaults to <code>TRUE</code> and puts the analysis results onto the columns.
This option allows you to add multiple instances of this functions, also in a nested fashion,
without adding more splits. This split must happen only one time on a single layout.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>imp_rule</code></td>
<td>
<p>(<code>string</code> or <code>NULL</code>)<br> imputation rule setting. Defaults to <code>NULL</code> for no imputation rule. Can
also be <code>"1/3"</code> to implement 1/3 imputation rule or <code>"1/2"</code> to implement 1/2 imputation rule. In order
to use an imputation rule, the <code>avalcat_var</code> argument must be specified. See <code>imputation_rule()</code>
for more details on imputation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>avalcat_var</code></td>
<td>
<p>(<code>string</code>)<br> if <code>imp_rule</code> is not <code>NULL</code>, name of variable that indicates whether a
row in the data corresponds to an analysis value in category <code>"BLQ"</code>, <code>"LTR"</code>, <code>"&lt;PCLLOQ"</code>, or none of
the above (defaults to <code>"AVALCAT1"</code>). Variable must be present in the data and should match the variable
used to calculate the <code>n_blq</code> statistic (if included in <code>.stats</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cache</code></td>
<td>
<p>(<code>flag</code>)<br> whether to store computed values in a temporary caching environment. This will
speed up calculations in large tables, but should be set to <code>FALSE</code> if the same <code>rtable</code> layout is
used for multiple tables with different data. Defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.indent_mods</code></td>
<td>
<p>(named <code>integer</code>)<br> indent modifiers for the labels. Defaults to 0, which corresponds to the
unmodified default behavior. Can be negative.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_str</code></td>
<td>
<p>(<code>string</code>)<br> string used to replace all <code>NA</code> or empty values in the output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nested</code></td>
<td>
<p>(<code>flag</code>)<br> whether this layout instruction should be applied within the existing layout structure _if
possible (<code>TRUE</code>, the default) or as a new top-level element (<code>FALSE</code>). Ignored if it would nest a split.
underneath analyses, which is not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.formats</code></td>
<td>
<p>(named <code>character</code> or <code>list</code>)<br> formats for the statistics. See Details in <code>analyze_vars</code> for more
information on the <code>"auto"</code> setting.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.aligns</code></td>
<td>
<p>(<code>character</code> or <code>NULL</code>)<br> alignment for table contents (not including labels). When <code>NULL</code>,
<code>"center"</code> is applied. See <code>formatters::list_valid_aligns()</code> for a list of all currently supported alignments.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A layout object suitable for passing to further layouting functions, or to <code>rtables::build_table()</code>.
Adding this function to an <code>rtable</code> layout will summarize the given variables, arrange the output
in columns, and add it to the table layout.
</p>


<h3>Note</h3>


<ul>
<li>
<p> This is an experimental implementation of <code>rtables::summarize_row_groups()</code> and <code>rtables::analyze_colvars()</code>
that may be subjected to changes as <code>rtables</code> extends its support to more complex analysis pipelines in the
column space. We encourage users to read the examples carefully and file issues for different use cases.
</p>
</li>
<li>
<p> In this function, <code>labelstr</code> behaves atypically. If <code>labelstr = NULL</code> (the default), row labels are assigned
automatically as the split values if <code>do_summarize_row_groups = FALSE</code> (the default), and as the group label
if <code>do_summarize_row_groups = TRUE</code>.
</p>
</li>
</ul>
<h3>See Also</h3>

<p><code>analyze_vars()</code>, <code>rtables::analyze_colvars()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)

# Data preparation
adpp &lt;- tern_ex_adpp %&gt;% h_pkparam_sort()

lyt &lt;- basic_table() %&gt;%
  split_rows_by(var = "STRATA1", label_pos = "topleft") %&gt;%
  split_rows_by(
    var = "SEX",
    label_pos = "topleft",
    child_labels = "hidden"
  ) %&gt;% # Removes duplicated labels
  analyze_vars_in_cols(vars = "AGE")
result &lt;- build_table(lyt = lyt, df = adpp)
result

# By selecting just some statistics and ad-hoc labels
lyt &lt;- basic_table() %&gt;%
  split_rows_by(var = "ARM", label_pos = "topleft") %&gt;%
  split_rows_by(
    var = "SEX",
    label_pos = "topleft",
    child_labels = "hidden",
    split_fun = drop_split_levels
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AGE",
    .stats = c("n", "cv", "geom_mean"),
    .labels = c(
      n = "aN",
      cv = "aCV",
      geom_mean = "aGeomMean"
    )
  )
result &lt;- build_table(lyt = lyt, df = adpp)
result

# Changing row labels
lyt &lt;- basic_table() %&gt;%
  analyze_vars_in_cols(
    vars = "AGE",
    row_labels = "some custom label"
  )
result &lt;- build_table(lyt, df = adpp)
result

# Pharmacokinetic parameters
lyt &lt;- basic_table() %&gt;%
  split_rows_by(
    var = "TLG_DISPLAY",
    split_label = "PK Parameter",
    label_pos = "topleft",
    child_labels = "hidden"
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AVAL"
  )
result &lt;- build_table(lyt, df = adpp)
result

# Multiple calls (summarize label and analyze underneath)
lyt &lt;- basic_table() %&gt;%
  split_rows_by(
    var = "TLG_DISPLAY",
    split_label = "PK Parameter",
    label_pos = "topleft"
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AVAL",
    do_summarize_row_groups = TRUE # does a summarize level
  ) %&gt;%
  split_rows_by("SEX",
    child_labels = "hidden",
    label_pos = "topleft"
  ) %&gt;%
  analyze_vars_in_cols(
    vars = "AVAL",
    split_col_vars = FALSE # avoids re-splitting the columns
  )
result &lt;- build_table(lyt, df = adpp)
result

</code></pre>


</div>