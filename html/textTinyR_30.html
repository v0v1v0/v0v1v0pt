<div class="container">

<table style="width: 100%;"><tr>
<td>vocabulary_parser</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>returns the vocabulary counts for small or medium ( xml and not only ) files</h2>

<h3>Description</h3>

<p>returns the vocabulary counts for small or medium ( xml and not only ) files
</p>


<h3>Usage</h3>

<pre><code class="language-R">vocabulary_parser(
  input_path_file = NULL,
  start_query = NULL,
  end_query = NULL,
  vocabulary_path_file = NULL,
  min_lines = 1,
  trimmed_line = FALSE,
  to_lower = FALSE,
  to_upper = FALSE,
  utf_locale = "",
  max_num_char = Inf,
  remove_char = "",
  remove_punctuation_string = FALSE,
  remove_punctuation_vector = FALSE,
  remove_numbers = FALSE,
  trim_token = FALSE,
  split_string = FALSE,
  split_separator = " \r\n\t.,;:()?!//",
  remove_stopwords = FALSE,
  language = "english",
  min_num_char = 1,
  stemmer = NULL,
  min_n_gram = 1,
  max_n_gram = 1,
  skip_n_gram = 1,
  skip_distance = 0,
  n_gram_delimiter = " ",
  threads = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>input_path_file</code></td>
<td>
<p>a character string specifying a valid path to the input file</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_query</code></td>
<td>
<p>a character string. The <em>start_query</em> is the first word of the subset of the data and should appear frequently at the beginning of each line in the text file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end_query</code></td>
<td>
<p>a character string. The <em>end_query</em> is the last word of the subset of the data and should appear frequently at the end of each line in the text file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vocabulary_path_file</code></td>
<td>
<p>a character string specifying the output file where the vocabulary should be saved (after tokenization and transformation is applied).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_lines</code></td>
<td>
<p>a numeric value specifying the minimum number of lines. For instance if min_lines = 2, then only subsets of text with more than 1 lines will be kept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trimmed_line</code></td>
<td>
<p>either TRUE or FALSE. If FALSE then each line of the text file will be trimmed both sides before applying the start_query and end_query</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to_lower</code></td>
<td>
<p>either TRUE or FALSE. If TRUE the character string will be converted to lower case</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to_upper</code></td>
<td>
<p>either TRUE or FALSE. If TRUE the character string will be converted to upper case</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>utf_locale</code></td>
<td>
<p>the language specific locale to use in case that either the <em>to_lower</em> or the <em>to_upper</em> parameter is TRUE and the text file language is other than english. For instance if the language of a text file is greek then the <em>utf_locale</em> parameter should be <em>'el_GR.UTF-8'</em> ( <em>language_country.encoding</em> ). A wrong utf-locale does not raise an error, however the runtime of the function increases.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_num_char</code></td>
<td>
<p>an integer specifying the maximum number of characters to keep. The <em>max_num_char</em> should be less than or equal to <em>Inf</em> (in this function the Inf value translates to a word-length of 1000000000)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_char</code></td>
<td>
<p>a character string with specific characters that should be removed from the text file. If the <em>remove_char</em> is "" then no removal of characters take place</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_punctuation_string</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then the punctuation of the character string will be removed (applies before the split function)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_punctuation_vector</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then the punctuation of the vector of the character strings will be removed  (after the string split has taken place)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_numbers</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then any numbers in the character string will be removed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trim_token</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then the string will be trimmed (left and/or right)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_string</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then the character string will be split using the <em>split_separator</em> as delimiter. The user can also specify multiple delimiters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>split_separator</code></td>
<td>
<p>a character string specifying the character delimiter(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>remove_stopwords</code></td>
<td>
<p>either TRUE, FALSE or a character vector of user defined stop words. If TRUE then by using the <em>language</em> parameter the corresponding stop words vector will be uploaded.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>language</code></td>
<td>
<p>a character string which defaults to english. If the <em>remove_stopwords</em> parameter is TRUE then the corresponding stop words vector will be uploaded. Available languages
are <em>afrikaans</em>, <em>arabic</em>, <em>armenian</em>, <em>basque</em>, <em>bengali</em>, <em>breton</em>, <em>bulgarian</em>, <em>catalan</em>,
<em>croatian</em>, <em>czech</em>, <em>danish</em>, <em>dutch</em>, <em>english</em>, <em>estonian</em>,
<em>finnish</em>, <em>french</em>, <em>galician</em>, <em>german</em>, <em>greek</em>, <em>hausa</em>, <em>hebrew</em>, <em>hindi</em>, <em>hungarian</em>,
<em>indonesian</em>, <em>irish</em>, <em>italian</em>, <em>latvian</em>, <em>marathi</em>,
<em>norwegian</em>, <em>persian</em>, <em>polish</em>, <em>portuguese</em>, <em>romanian</em>, <em>russian</em>, <em>slovak</em>, <em>slovenian</em>,
<em>somalia</em>, <em>spanish</em>, <em>swahili</em>, <em>swedish</em>, <em>turkish</em>, <em>yoruba</em>, <em>zulu</em></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_num_char</code></td>
<td>
<p>an integer specifying the minimum number of characters to keep. If the <em>min_num_char</em> is greater than 1 then character strings with more than 1 characters will be returned</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stemmer</code></td>
<td>
<p>a character string specifying the stemming method. Available method is the <em>porter2_stemmer</em>. See details for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>min_n_gram</code></td>
<td>
<p>an integer specifying the minimum number of n-grams. The minimum number of min_n_gram is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_n_gram</code></td>
<td>
<p>an integer specifying the maximum number of n-grams. The minimum number of max_n_gram is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_n_gram</code></td>
<td>
<p>an integer specifying the number of skip-n-grams. The minimum number of skip_n_gram is 1. The skip_n_gram gives the (max.) n-grams using the <em>skip_distance</em> parameter. If <em>skip_n_gram</em> is greater than 1 then both <em>min_n_gram</em> and <em>max_n_gram</em> should be set to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_distance</code></td>
<td>
<p>an integer specifying the skip distance between the words. The minimum value for the skip distance is 0, in which case simple n-grams will be returned.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n_gram_delimiter</code></td>
<td>
<p>a character string specifying the n-gram delimiter (applies to both n-gram and skip-n-gram cases)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>an integer specifying the number of cores to run in parallel</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then information will be printed in the console</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The text file should have a structure (such as an xml-structure), so that subsets can be extracted using the <em>start_query</em> and <em>end_query</em> parameters
</p>
<p>For big files the <em>vocabulary_accumulator</em> method of the <em>big_tokenize_transform</em> class is appropriate
</p>
<p>Stemming of the english language is done using the porter2-stemmer, for details see <a href="https://github.com/smassung/porter2_stemmer">https://github.com/smassung/porter2_stemmer</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
## Not run: 

library(textTinyR)

 vps = vocabulary_parser(input_path_file = '/folder/input_data.txt',
                         start_query = 'start_word', end_query = 'end_word',
                         vocabulary_path_file = '/folder/vocab.txt',
                         to_lower = TRUE, split_string = TRUE)

## End(Not run)
</code></pre>


</div>