<div class="container">

<table style="width: 100%;"><tr>
<td>Hadamard product</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hadamard product</h2>

<h3>Description</h3>

<p>Computes the Hadamard product between two matrices
</p>


<h3>Usage</h3>

<pre><code class="language-R">Hadamard(A, B, IDrowA, IDrowB,
         IDcolA = NULL, IDcolB = NULL,
         a = 1, make.dimnames = FALSE,
         drop = TRUE, inplace = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(numeric) Numeric matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p>(numeric) Numeric matrix</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDrowA</code></td>
<td>
<p>(integer/character) Vector of length <i>m</i> with either indices or row names mapping from rows of <code>A</code> into the resulting Hadamard product. If 'missing', it is assumed to be equal to <code>1,...,nrow(A)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDrowB</code></td>
<td>
<p>(integer/character) Vector of length <i>m</i> with either indices or row names mapping from rows of <code>B</code> into the resulting Hadamard product. If 'missing', it is assumed to be equal to <code>1,...,nrow(B)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDcolA</code></td>
<td>
<p>(integer/character) (Optional) Similar to <code>IDrowA</code>, vector of length <i>n</i> for columns. If <code>NULL</code>, it is assumed to be equal to <code>IDrowA</code> if 
<i>m=n</i></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IDcolB</code></td>
<td>
<p>(integer/character) (Optional) Similar to <code>IDrowB</code>, vector of length <i>n</i> for columns. If <code>NULL</code>, it is assumed to be equal to <code>IDrowB</code> if
<i>m=n</i></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>(numeric) A constant to multiply the resulting Hadamard product by</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Either <code>TRUE</code> or <code>FALSE</code> to whether return a uni-dimensional vector when output is a matrix with either 1 row or 1 column as per the <code>rows</code> and <code>cols</code> arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>make.dimnames</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether add <code>rownames</code> and <code>colnames</code> attributes to the output</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inplace</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to whether operate directly on one input matrix (<code>A</code> or <code>B</code>) when this is used as is (i.e., is not indexed; therefore, needs to be of appropiate dimensions) in the Hadamard. When <code>TRUE</code> the output will be overwritten on the same address occupied by the non-indexed matrix. Default <code>inplace=FALSE</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Computes the <i>m</i> Ã— <i>n</i> Hadamard product (aka element-wise or entry-wise product) matrix between matrices 
<b>A</b> and <b>B</b>,
</p>
<p style="text-align:center">(<b>R</b><sub>1</sub><b>A</b> <b>C'</b><sub>1</sub>) &amp;odot; (<b>R</b><sub>2</sub><b>B</b> <b>C'</b><sub>2</sub>)</p>
<p>where
<b>R</b><sub>1</sub> and
<b>R</b><sub>2</sub> are incidence matrices mapping from rows of the resulting Hadamard to rows of <b>A</b> and <b>B</b>, respectively; and 
<b>C</b><sub>1</sub> and
<b>C</b><sub>2</sub> are incidence matrices mapping from columns of the resulting Hadamard to columns of <b>A</b> and <b>B</b>, respectively.
</p>
<p>Matrix <b>R</b><sub>1</sub><b>A</b> <b>C'</b><sub>1</sub>
can be obtained by matrix indexing as <code>A[IDrowA,IDcolA]</code>, where <code>IDrowA</code> and <code>IDcolA</code> are integer vectors whose entries are, respectively, the row and column number of 
<b>A</b> that are mapped at each row of 
<b>R</b><sub>1</sub> and 
<b>C</b><sub>1</sub>, respectively.
Likewise, matrix 
<b>R</b><sub>2</sub><b>B</b> <b>C'</b><sub>2</sub>
can be obtained as <code>B[IDrowB,IDcolB]</code>, where <code>IDrowB</code> and <code>IDcolB</code> are integer vectors whose entries are, respectively, the row and column number of 
<b>B</b> that are mapped at each row of 
<b>R</b><sub>2</sub> and 
<b>C</b><sub>2</sub>, respectively. Therefore, the Hadamard product can be obtained directly as
</p>
<p style="text-align:center;font-family:courier">A[IDrowA,IDcolA]*B[IDrowB,IDcolB]</p>
<p>The function computes the Hadamard product directly from <b>A</b> and <b>B</b> without forming <b>R</b><sub>1</sub><b>A</b> <b>C'</b><sub>1</sub> or 
<b>R</b><sub>2</sub><b>B</b> <b>C'</b><sub>2</sub>
matrices. The result can be multiplied by a constant <i>a</i>.
</p>


<h3>Value</h3>

<p>Returns a matrix containing the Hadamard product.
</p>


<h3>Examples</h3>

<pre><code class="language-R">  require(tensorEVD)
  
  # (a) Example 1. Indexing using row/column names
  # Generate rectangular matrices A (nrowA x ncolA) and B (nrowB x ncolB)
  nA = c(10,15)
  nB = c(12,8)
  A = matrix(rnorm(nA[1]*nA[2]), nrow=nA[1])
  B = matrix(rnorm(nB[1]*nB[2]), nrow=nB[1])
  dimnames(A) = list(paste0("row",seq(nA[1])), paste0("col",seq(nA[2])))
  dimnames(B) = list(paste0("row",seq(nB[1])), paste0("col",seq(nB[2])))
  
  # Define IDs for a Hadamard of size n1 x n2
  n = c(1000,500)
  IDrowA = sample(rownames(A), n[1], replace=TRUE)
  IDrowB = sample(rownames(B), n[1], replace=TRUE)
  IDcolA = sample(colnames(A), n[2], replace=TRUE)
  IDcolB = sample(colnames(B), n[2], replace=TRUE)
  
  K1 = Hadamard(A, B, IDrowA, IDrowB, IDcolA, IDcolB, make.dimnames=TRUE)
  
  # (it must equal to:)
  K2 = A[IDrowA,IDcolA]*B[IDrowB,IDcolB]
  dimnames(K2) = list(paste0(IDrowA,":",IDrowB), paste0(IDcolA,":",IDcolB))
  all.equal(K1,K2)
  
  # (b) Example 2. Indexing using integers
  # Generate squared symmetric matrices A and B 
  nA = 20
  nB = 15
  A = tcrossprod(matrix(rnorm(nA*nA), nrow=nA))
  B = tcrossprod(matrix(rnorm(nB*nB), nrow=nB))
  
  # Define IDs for a Hadamard of size n x n
  n = 1000
  IDA = sample(seq(nA), n, replace=TRUE)
  IDB = sample(seq(nB), n, replace=TRUE)
  
  K1 = Hadamard(A, B, IDA, IDB)
  
  # (it must equal to:)
  K2 = A[IDA,IDA]*B[IDB,IDB]
  all.equal(K1,K2)
  
  # (c) Inplace calculation
  # overwrite the output at the same address as the input:
  IDB = sample(seq(nB), nA, replace=TRUE)
  
  K1 = A[]                     # copy of A to be used as input
  add  = pryr::address(K1)     # address of K on entry
  K1 = Hadamard(K1, B, IDrowB=IDB)
  pryr::address(K1) == add     # on exit, K was moved to a different address
  
  K2 = A[]   
  add  = pryr::address(K2)
  K2 = Hadamard(K2, B, IDrowB=IDB, inplace=TRUE)
  pryr::address(K2) == add     # on exit, K remains at the same address
  all.equal(K1,K2)
</code></pre>


</div>