<div class="container">

<table style="width: 100%;"><tr>
<td>optimal.cutpoint</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Function to Find the First Cutpoint and its P Value
</h2>

<h3>Description</h3>

<p>This function finds the first optimal cutpoint for the time-varying regression effects based on the maximized score statistics
and calculates p-value based on a formula from Davies (1987) and O'Quigley and Pessione (1991). This is for depth 1 only.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optimal.cutpoint(survtime, survstatus, x, method = "breslow", acpf = 10, 
            iter.max = 20, eps = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>survtime</code></td>
<td>

<p>survival time/ follow up time of subjects
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>survstatus</code></td>
<td>

<p>survival status of subjects. 0 for censored and 1 for an event
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a data frame of covariates. In case of a single covariate, use <code>[,,drop =F]</code> to keep the data frame structure
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>argument for coxph function. Default is 'breslow'. See  <code>coxph</code> for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acpf</code></td>
<td>

<p>The search for the optimal cutpoint starts from the ((acpf/2)+1)th event until the (k - (acpf/2))th event, where k is the total number of events. Default is 10.	
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iter.max</code></td>
<td>

<p>the maximum number of iteration in coxph; default is 20. See  <code>coxph</code> for more details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>argument for coxph function; default is 0.000001. See  <code>coxph</code> for more details.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>optimal.cutpoint</code> takes in survival time, survival status, and covariates to find the first optimal cutpoint. 
</p>
<p>Currently, data need to be arranged in descending order of time and with no missing. 
</p>


<h3>Value</h3>

<p><code>optimal.cutpoint</code> returns the following information:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>breakpt</code></td>
<td>
<p>optimal cutpoint</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scoretest</code></td>
<td>
<p>Maximum score associated with the optimal cut point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>summary</code></td>
<td>
<p>3 output from <code>coxph</code> fitted with 1) entire data, 2) data before the optimal cutpoint, and 3) data after the optimal cutpoint.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pvalue</code></td>
<td>
<p>p-value to test the existance of a change point against none</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Davies, R. (1987). Hypothesis Testing when a Nuisance Parameter is Present Only Under the Alternatives. Biometrika,  74(1), 33-43.
</p>
<p>O'Quigley, J., and Pessione, F. (1991). The Problem of a Covariate-Time Qualitative Interaction in a Survival Study. Biometrics, 47(1), 101-115.
</p>


<h3>Examples</h3>

<pre><code class="language-R">##Call in alcohol data set
data('alcohol')
require(survival)

coxtree &lt;- optimal.cutpoint(alcohol[,'time'], alcohol[,'event'], 
                      x = alcohol[,'alc', drop = FALSE])
</code></pre>


</div>