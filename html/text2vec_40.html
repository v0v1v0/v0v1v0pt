<div class="container">

<table style="width: 100%;"><tr>
<td>LatentDirichletAllocation</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Creates Latent Dirichlet Allocation model.</h2>

<h3>Description</h3>

<p>Creates Latent Dirichlet Allocation model.
At the moment only 'WarpLDA' is implemented.
WarpLDA, an LDA sampler which achieves both the best O(1) time
complexity per token and the best O(K) scope of random access.
Our empirical results in a wide range of testing conditions demonstrate that
WarpLDA is consistently 5-15x faster than the state-of-the-art Metropolis-Hastings
based LightLDA, and is comparable or faster than the sparsity aware F+LDA.
</p>


<h3>Usage</h3>

<pre><code class="language-R">LatentDirichletAllocation

LDA
</code></pre>


<h3>Format</h3>

<p><code>R6Class</code> object.</p>


<h3>Fields</h3>


<dl>
<dt><code>topic_word_distribution</code></dt>
<dd>
<p>distribution of words for each topic. Available after model fitting with
<code>model$fit_transform()</code> method.</p>
</dd>
<dt><code>components</code></dt>
<dd>
<p>unnormalized word counts for each topic-word entry. Available after model fitting with
<code>model$fit_transform()</code> method.</p>
</dd>
</dl>
<h3>Usage</h3>

<p>For usage details see <b>Methods, Arguments and Examples</b> sections.
</p>
<pre>
lda = LDA$new(n_topics = 10L, doc_topic_prior = 50 / n_topics, topic_word_prior = 1 / n_topics)
lda$fit_transform(x, n_iter = 1000, convergence_tol = 1e-3, n_check_convergence = 10, progressbar = interactive())
lda$transform(x, n_iter = 1000, convergence_tol = 1e-3, n_check_convergence = 5, progressbar = FALSE)
lda$get_top_words(n = 10, topic_number = 1L:private$n_topics, lambda = 1)
</pre>


<h3>Methods</h3>


<dl>
<dt><code>$new(n_topics,
              doc_topic_prior = 50 / n_topics, # alpha
              topic_word_prior = 1 / n_topics, # beta
              method = "WarpLDA")</code></dt>
<dd>
<p>Constructor for LDA model.
For description of arguments see <b>Arguments</b> section.</p>
</dd>
<dt><code>$fit_transform(x, n_iter, convergence_tol = -1,
               n_check_convergence = 0, progressbar = interactive())</code></dt>
<dd>
<p>fit LDA model to input matrix
<code>x</code> and transforms input documents to topic space.
Result is a matrix where each row represents corresponding document.
Values in a row form distribution over topics.</p>
</dd>
<dt><code>$transform(x, n_iter, convergence_tol = -1,
               n_check_convergence = 0, progressbar = FALSE)</code></dt>
<dd>
<p> transforms new documents into topic space.
Result is a matrix where each row is a distribution of a documents over latent topic space.</p>
</dd>
<dt><code>$get_top_words(n = 10, topic_number = 1L:private$n_topics, lambda = 1)</code></dt>
<dd>
<p>returns "top words"
for a given topic (or several topics). Words for each topic can be
sorted by probability of chance to observe word in a given topic (<code>lambda = 1</code>) and by
"relevance" which also takes into account frequency of word in corpus (<code>lambda &lt; 1</code>).
From our experience in most cases setting <code> 0.2 &lt; lambda &lt; 0.4</code> works well.
See <a href="http://nlp.stanford.edu/events/illvi2014/papers/sievert-illvi2014.pdf">http://nlp.stanford.edu/events/illvi2014/papers/sievert-illvi2014.pdf</a> for details.</p>
</dd>
<dt><code>$plot(lambda.step = 0.1, reorder.topics = FALSE, ...)</code></dt>
<dd>
<p>plot LDA model using <a href="https://cran.r-project.org/package=LDAvis">https://cran.r-project.org/package=LDAvis</a> package.
<code>...</code> will be passed to <code>LDAvis::createJSON</code> and <code>LDAvis::serVis</code> functions</p>
</dd>
</dl>
<h3>Arguments</h3>


<dl>
<dt>lda</dt>
<dd>
<p>A <code>LDA</code> object</p>
</dd>
<dt>x</dt>
<dd>
<p>An input document-term matrix (should have column names = terms).
<b>CSR <code>RsparseMatrix</code> used internally</b>,
other formats will be tried to convert to CSR via <code>as()</code> function call.</p>
</dd>
<dt>n_topics</dt>
<dd>
<p><code>integer</code> desired number of latent topics. Also knows as <b>K</b></p>
</dd>
<dt>doc_topic_prior</dt>
<dd>
<p><code>numeric</code> prior for document-topic multinomial distribution.
Also knows as <b>alpha</b></p>
</dd>
<dt>topic_word_prior</dt>
<dd>
<p><code>numeric</code> prior for topic-word multinomial distribution.
Also knows as <b>eta</b></p>
</dd>
<dt>n_iter</dt>
<dd>
<p><code>integer</code> number of sampling iterations while fitting model</p>
</dd>
<dt>n_iter_inference</dt>
<dd>
<p><code>integer</code> number iterations used when sampling from converged model for inference.
In other words number of samples from distribution after burn-in.</p>
</dd>
<dt>n_check_convergence</dt>
<dd>
<p> defines how often calculate score to check convergence </p>
</dd>
<dt>convergence_tol</dt>
<dd>
<p><code>numeric = -1</code> defines early stopping strategy. We stop fitting
when one of two following conditions will be satisfied: (a) we have used
all iterations, or (b) <code>score_previous_check / score_current &lt; 1 + convergence_tol</code></p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
library(text2vec)
data("movie_review")
N = 500
tokens = word_tokenizer(tolower(movie_review$review[1:N]))
it = itoken(tokens, ids = movie_review$id[1:N])
v = create_vocabulary(it)
v = prune_vocabulary(v, term_count_min = 5, doc_proportion_max = 0.2)
dtm = create_dtm(it, vocab_vectorizer(v))
lda_model = LDA$new(n_topics = 10)
doc_topic_distr = lda_model$fit_transform(dtm, n_iter = 20)
# run LDAvis visualisation if needed (make sure LDAvis package installed)
# lda_model$plot()

## End(Not run)
</code></pre>


</div>