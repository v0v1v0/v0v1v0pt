<div class="container">

<table style="width: 100%;"><tr>
<td>TOHM_LRT</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute the Likelihood Ratio Test under non-standard conditions.</h2>

<h3>Description</h3>

<p>It implements the procedure described in Algeri and van Dyk (2018) to perform tests of hypothesis under non-regular conditions, and which can be formulated as test of hypothesis where a nuisance parameter is present only under the alternative.</p>


<h3>Usage</h3>

<pre><code class="language-R">TOHM_LRT(x, mll, null0, init, lowlim, uplim, THETA, ck,
type = c("Chi^2", "Chi-bar^2"), k = NULL, k_vec = NULL,
weights = NULL, ECdensities = NULL, ECs = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector or matrix collecting the data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mll</code></td>
<td>

<p>A function specifying the negative (profile) log-likelihood. See details. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null0</code></td>
<td>

<p>A   vector or scalar of the free parameters under the null hypothesis. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>init</code></td>
<td>

<p>A   vector or scalar  of initial values for the MLE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowlim</code></td>
<td>

<p>A   vector or scalar of lower bounds for the MLE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>uplim</code></td>
<td>

<p>A   vector or scalar of upper bounds for the MLE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>THETA</code></td>
<td>

<p>A vector or matrix of   grid values of the nuisance parameter with respect to which the search is performed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ck</code></td>
<td>
<p>Vector of thresholds defining the excursions sets with respect to which the ECs are computed.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>Type of random field. The possible options are <code>"Gaussian"</code>, <code>"Chi^2"</code>, and <code>"Chi-bar^2"</code>. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>If <code>type="Chi^2"</code>, degrees of freedom of the Chi-square random field.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k_vec</code></td>
<td>
<p>If <code>type="Chi-bar^2"</code> the degrees of freedom  of the Chi-square random fields  in the mixture.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p> If <code>type="Chi-bar^2"</code> the   weights of the mixure of Chi-square random fields in the mixture. The ordering should be the same as in <code>k_vec</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ECdensities</code></td>
<td>
<p>See datails.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ECs</code></td>
<td>
<p>A vector or matrix containing the Euler characteristics (ECs) computed over a Monte Carlo simulation of the random field under the null model. Each colum correspond to the ECs obtained for each of the thresholds in <code>ck</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>mll</code>  takes as first argument the vector of the parameters for which   the  MLE is generated. Other arguments of <code>mll</code>  are the data vector or matrix (<code>x</code>) and a scalar or vector corresponding to the fixed value for the nuisance parameter with respect to which the profilying is computed (<code>theta</code>, see <code>gLRT</code>). If the latter is a vector it must be of same length of the rows in <code>THETA</code>.
If the null model has nuisance parameters, <code>null0</code> takes as arguments the values of the parameters being tested under the null hypothesis, followed by the estimates of the nuisance parameters obtained assuming that the null hypothesis is true.
If <code>type="Chi-bar^2"</code> the degrees of freedom  of the Chi-square random fields involved in the mixture, as well as the respective weights, have to be spefcified in the arguments <code>k_vec</code> and <code>weights</code>.
If the distribution of the random field is not available in <code>type</code>, the user can specify in <code>ECdensities</code> a function taking <code>c</code> as argument and returning
the vector of the desired EC densities  to be evaluated at <code>c</code>. Notice that the length of the vector returned by the function specified in <code>ECdensities</code> must corresponds to one plus the dimension of the search area (since the first value should correspond to the EC density of order zero (see <code>ECden_vec</code>)). </p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>max_gLRT </code></td>
<td>
<p>Maximum observed of the LRT field.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta_max </code></td>
<td>
<p>Value of <code>THETA</code> at which the maximum is observed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>global_p </code></td>
<td>
<p>Global p-value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MCerror </code></td>
<td>
<p>Monte Carlo error associated to the global p-vaue.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Sara Algeri</p>


<h3>References</h3>

<p>S. Algeri and D.A. van Dyk. Testing one hypothesis multiple times: The multidimensional
case.   arXiv:1803.03858, submitted to the Journal of Computational and Graphical Statistics, 2018.</p>


<h3>See Also</h3>

<p><code>find_max</code>, <code>global_p</code>,<code>EC_T</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#generating data of interest
N&lt;-100
x&lt;-as.matrix(cbind(runif(N*2,172.5,217.5),runif(N*2,-2,58)))
x2&lt;-x[(x[,1]&lt;=217.5)&amp;(x[,1]&gt;=172.5),]
x_sel&lt;-x2[(x2[,2]&lt;=(28+sqrt(30^2-(x2[,1]-195)^2)))&amp;(x2[,2]&gt;=(28-
sqrt(30^2-(x2[,1]-195)^2))),]
data&lt;-x_sel[sample(seq(1:(dim(x_sel)[1])),N),]

#Specifying minus-log-likelihood
kg&lt;-function(theta){integrate(Vectorize(function(x) {
exp(-0.5*((x-theta[1])/0.5)^2)*integrate(function(y) {
exp(-0.5*((y-theta[2])/0.5)^2) }, 28-sqrt(30^2-(x-195)^2),
28+sqrt(30^2-(x-195)^2))$value}) , 172.5, 217.5)$value}
mll&lt;-function(eta,x,theta){
  -sum(log((1-eta)/(pi*(30)^2)+eta*exp(-0.5*((x[,1]-
  theta[1])/0.5)^2-
  0.5*((x[,2]-theta[2])/0.5)^2)/kg(theta)))}

#Specifying search region
theta1&lt;-seq(172.5,217.5,by=15)
theta2&lt;-seq(-2,58,by=10)
THETA&lt;-as.matrix(expand.grid(theta1,theta2))
originalR&lt;-dim(THETA)[1]
rownames(THETA)&lt;-1:(dim(THETA)[1])
THETA2&lt;-THETA[(THETA[,1]&lt;=217.5)&amp;(THETA[,1]&gt;=172.5),]
THETA_sel&lt;-THETA2[(THETA2[,2]&lt;=(28+sqrt(30^2-(THETA2[,1]-
195)^2)))&amp;(THETA2[,2]&gt;=(28-sqrt(30^2-(THETA2[,1]-195)^2))),]

#Generating toy EC
ECs&lt;-cbind(rpois(100,1.5),rpois(100,1))

TOHM_LRT(data,mll,null0=0,init=c(0.1),lowlim=c(0),uplim=c(1),
THETA=THETA_sel,ck=c(1,8),type=c("Chi-bar^2"),
k=NULL,k_vec=c(0,1),weights=c(0.5,0.5),
ECdensities=NULL,ECs=ECs)
  </code></pre>


</div>