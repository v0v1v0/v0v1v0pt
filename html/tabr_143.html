<div class="container">

<table style="width: 100%;"><tr>
<td>lp_chord_id</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>LilyPond chord notation</h2>

<h3>Description</h3>

<p>Obtain LilyPond quasi-chord notation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">lp_chord_id(root, chord, exact = FALSE, ...)

lp_chord_mod(root, chord, exact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>character, root note.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chord</code></td>
<td>
<p>character, <code>tabr</code> format chord name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exact</code></td>
<td>
<p>logical, return a more exact LilyPond chord representation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments passed to <code>transpose()</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>These functions take a <code>tabr</code> syntax representation of a chord name and
convert it to quasi-LilyPond syntax;
"quasi" because the result still uses <code style="white-space: pre;">⁠_⁠</code> for flats and <code style="white-space: pre;">⁠#⁠</code> for sharps,
whereas LilyPond itself uses <code>es</code> and <code>is</code> (mostly).
This is the format used by <code>tabr</code> functions involved in communicating with
LilyPond for music transcription, and they make these final conversions on
the fly.
This can be overridden with <code>exact = TRUE</code>.
</p>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class="language-R">lp_chord_id("a a a", "m M m7_5")
lp_chord_mod("a a a", "m M m7_5")
lp_chord_id("a a a", "m M m7_5", exact = TRUE)
lp_chord_mod("a a a", "m M m7_5", exact = TRUE)
</code></pre>


</div>