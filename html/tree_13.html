<div class="container">

<table style="width: 100%;"><tr>
<td>prune.tree</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Cost-complexity Pruning of Tree Object
</h2>

<h3>Description</h3>

<p>Determines a nested sequence of subtrees of the supplied tree by
recursively “snipping” off the least important splits.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prune.tree(tree, k = NULL, best = NULL, newdata, nwts,
           method = c("deviance", "misclass"), loss, eps = 1e-3)

prune.misclass(tree, k = NULL, best = NULL, newdata, 
               nwts, loss, eps = 1e-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>

<p>fitted model object of class <code>tree</code>.  This is assumed to be the result
of some function that produces an object with the same named
components as that returned by the <code>tree()</code> function.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>cost-complexity parameter defining either a specific subtree of <code>tree</code>
(<code>k</code> a scalar) or the (optional) sequence of subtrees minimizing the
cost-complexity measure (<code>k</code> a vector). If missing, <code>k</code> is
determined algorithmically.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>best</code></td>
<td>

<p>integer requesting the size (i.e. number of terminal nodes) of a
specific subtree in the cost-complexity sequence to be returned. This
is an alternative way to select a subtree than by supplying a scalar
cost-complexity parameter <code>k</code>.  If there is no tree in the sequence of
the requested size, the next largest is returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>

<p>data frame upon which the sequence of cost-complexity subtrees is
evaluated.  If missing, the data used to grow the tree are used.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nwts</code></td>
<td>

<p>weights for the <code>newdata</code> cases.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>

<p>character string denoting the measure of node heterogeneity used to
guide cost-complexity pruning.  For regression trees, only the
default, <code>deviance</code>, is accepted.  For classification trees, the
default is <code>deviance</code> and the alternative is <code>misclass</code>
(number of misclassifications or total loss).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loss</code></td>
<td>

<p>a matrix giving for each true class (row) the numeric loss of
predicting the class (column).  The classes should be in the order of
the levels of the response.  It is conventional for a loss matrix to
have a zero diagonal.  The default is 0–1 loss.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>a lower bound for the probabilities, used to compute deviances if
events of predicted probability zero occur in <code>newdata</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Determines a nested sequence of subtrees of the supplied tree by
recursively "snipping" off the least important splits, based upon
the cost-complexity measure.  <code>prune.misclass</code> is an abbreviation for
<code>prune.tree(method = "misclass")</code> for use with <code>cv.tree</code>.
</p>
<p>If <code>k</code> is supplied, the optimal subtree for that value is returned.
</p>
<p>The response as well as the predictors referred to in the right side
of the formula in <code>tree</code> must be present by name in
<code>newdata</code>. These data are dropped down each tree in the
cost-complexity sequence and deviances or losses calculated by
comparing the supplied response to the prediction.  The function
<code>cv.tree()</code> routinely uses the <code>newdata</code> argument
in cross-validating the pruning procedure.  A <code>plot</code> method
exists for objects of this class.  It displays the value of the
deviance, the number of misclassifications or the total loss for
each subtree in the cost-complexity sequence.  An additional axis
displays the values of the cost-complexity parameter at each subtree.
</p>


<h3>Value</h3>

<p>If <code>k</code> is supplied and is a scalar, a <code>tree</code> object is
returned that minimizes the cost-complexity measure for that <code>k</code>.
If <code>best</code> is supplied, a <code>tree</code> object of size <code>best</code>
is returned.  Otherwise, an object of class <code>tree.sequence</code>
is returned.  The object contains the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>size</code></td>
<td>

<p>number of terminal nodes in each tree in the cost-complexity pruning
sequence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deviance</code></td>
<td>

<p>total deviance of each tree in the cost-complexity pruning sequence.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>the value of the cost-complexity pruning parameter of each tree in 
the sequence.
</p>
</td>
</tr>
</table>
<h3>Examples</h3>

<pre><code class="language-R">data(fgl, package="MASS")
fgl.tr &lt;- tree(type ~ ., fgl)
print(fgl.tr); plot(fgl.tr)

fgl.cv &lt;- cv.tree(fgl.tr,, prune.tree)
for(i in 2:5)  fgl.cv$dev &lt;- fgl.cv$dev +
   cv.tree(fgl.tr,, prune.tree)$dev
fgl.cv$dev &lt;- fgl.cv$dev/5
plot(fgl.cv)
</code></pre>


</div>