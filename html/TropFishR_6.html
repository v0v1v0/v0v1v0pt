<div class="container">

<table style="width: 100%;"><tr>
<td>ELEFAN</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>ELEFAN</h2>

<h3>Description</h3>

<p>Electronic LEngth Frequency ANalysis for estimating growth parameter.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ELEFAN(
  lfq,
  Linf_fix = NA,
  Linf_range = NA,
  K_range = exp(seq(log(0.1), log(10), length.out = 100)),
  C = 0,
  ts = 0,
  MA = 5,
  addl.sqrt = FALSE,
  agemax = NULL,
  flagging.out = TRUE,
  method = "optimise",
  cross.date = NULL,
  cross.midLength = NULL,
  cross.max = FALSE,
  hide.progressbar = FALSE,
  plot = FALSE,
  contour = FALSE,
  add.values = TRUE,
  rsa.colors = terrain.colors(20),
  plot_title = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>lfq</code></td>
<td>
<p>a list consisting of following parameters:
</p>

<ul>
<li> <p><strong>midLengths</strong> midpoints of the length classes,
</p>
</li>
<li> <p><strong>dates</strong> dates of sampling times (class Date),
</p>
</li>
<li> <p><strong>catch</strong> matrix with catches/counts per length class (row)
and sampling date (column);
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Linf_fix</code></td>
<td>
<p>numeric; if used the K-Scan method is applied with a fixed
Linf value (i.e. varying K only).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Linf_range</code></td>
<td>
<p>numeric vector with potential Linf values. Default is the
last length class plus/minus 5 cm</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K_range</code></td>
<td>
<p>K values for which the score of growth functions should be
calculated
(by default: exp(seq(log(0.1),log(10),length.out = 100)))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>C</code></td>
<td>
<p>growth oscillation amplitude (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ts</code></td>
<td>
<p>onset of the first oscillation relative to t0 (summer point, default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MA</code></td>
<td>
<p>number indicating over how many length classes the moving average
should be performed (default: 5, for
more information see lfqRestructure).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addl.sqrt</code></td>
<td>
<p>Passed to lfqRestructure. Applied an additional square-root transformation of positive values according to Brey et al. (1988).
(default: FALSE, for more information see lfqRestructure).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>agemax</code></td>
<td>
<p>maximum age of species; default NULL, then estimated from Linf</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flagging.out</code></td>
<td>
<p>logical; should positive peaks be flagged out? (Default : TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Choose between the old FiSAT option to force VBGF crossing of a pre-defined
bin (method = "cross"), or the more sophisticated (but computationally expensive) option
to solve for t_anchor via a maximisation of reconstructed score
(default: method = "optimise").</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross.date</code></td>
<td>
<p>Date. For use with <code>method = "cross"</code>. In combination
with <code>cross.midLength</code>, defines the date of the crossed bin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross.midLength</code></td>
<td>
<p>Numeric. For use with <code>method = "cross"</code>. In combination
with <code>cross.date</code>, defines the mid-length of the crossed bin.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cross.max</code></td>
<td>
<p>logical. For use with <code>method = "cross"</code>. Forces growth function
to cross the bin with maximum positive score.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hide.progressbar</code></td>
<td>
<p>logical; should the progress bar be hidden? (default: FALSE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical; indicating if plot with restructured frequencies and growth curves should
be displayed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contour</code></td>
<td>
<p>if used in combination with response surface analysis, contour lines
are displayed rather than the score as text in each field of the score plot. Usage
can be logical (e.g. TRUE) or by providing a numeric which indicates the
number of levels (<code>nlevels</code> in <code>contour</code>). By default FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>add.values</code></td>
<td>
<p>logical. Add values to Response Surface Analysis plot (default: TRUE).
Overridden when <code>contour = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rsa.colors</code></td>
<td>
<p>vector of colors to be used with the Response Surface Analysis plot.
(default: terrain.colors(20))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot_title</code></td>
<td>
<p>logical; indicating whether title to score plots should be displayed</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This functions allows to perform the K-Scan and Response surface
analysis to estimate growth parameters.
It combines the step of restructuring length-frequency data
(lfqRestructure) followed by the fitting of VBGF
curves through the restructured data (lfqFitCurves). K-Scan is a
method used to search for the K
parameter with the best fit while keeping the Linf fixed. In contrast,
with response surface analysis
both parameters are estimated and the fits are displayed in a heatmap.
Both methods use <code>optimise</code> to find the best <code>t_anchor</code> value
for each combination of <code>K</code> and <code>Linf</code>. To find out more about
<code>t_anchor</code>, please refer to the Details description of
<code>lfqFitCurves</code>. The score value <code>Rn_max</code> is comparable with
the score values of the other ELEFAN functions (<code>ELEFAN_SA</code> or
<code>ELEFAN_GA</code>) when other settings are consistent
(e.g. 'MA', 'addl.sqrt', 'agemax', 'flagging.out').
</p>


<h3>Value</h3>

<p>A list with the input parameters and following list objects:
</p>

<ul>
<li> <p><strong>rcounts</strong>: restructured frequencies,
</p>
</li>
<li> <p><strong>peaks_mat</strong>: matrix with positive peaks with distinct values,
</p>
</li>
<li> <p><strong>ASP</strong>: available sum of peaks, sum of posititve peaks which
could be potential be hit by
growth curves,
</p>
</li>
<li> <p><strong>score_mat</strong>: matrix with scores for each Linf (only Linf_fix)
and K combination,
</p>
</li>
<li> <p><strong>t_anchor_mat</strong>: maximum age of species,
</p>
</li>
<li> <p><strong>ncohort</strong>: number of cohorts used for estimation,
</p>
</li>
<li> <p><strong>agemax</strong>: maximum age of species,
</p>
</li>
<li> <p><strong>par</strong>: a list with the parameters of the von Bertalanffy growth
function:
</p>

<ul>
<li> <p><strong>Linf</strong>: length infinity in cm,
</p>
</li>
<li> <p><strong>K</strong>: curving coefficient;
</p>
</li>
<li> <p><strong>t_anchor</strong>: time point anchoring growth curves in year-length
coordinate system, corrsponds to peak spawning month,
</p>
</li>
<li> <p><strong>C</strong>: amplitude of growth oscillation
(if <code>seasonalised</code> = TRUE),
</p>
</li>
<li> <p><strong>ts</strong>: summer point of oscillation (ts = WP - 0.5)
(if <code>seasonalised</code> = TRUE),
</p>
</li>
<li> <p><strong>phiL</strong>: growth performance index defined as
phiL = log10(K) + 2 * log10(Linf);
</p>
</li>
</ul>
</li>
<li> <p><strong>Rn_max</strong>: highest score value
</p>
</li>
</ul>
<h3>References</h3>

<p>Brey, T., Soriano, M., and Pauly, D. 1988. Electronic length frequency analysis: a revised and expanded
user's guide to ELEFAN 0, 1 and 2.
</p>
<p>Pauly, D. 1981. The relationship between gill surface area and growth performance in fish:
a generalization of von Bertalanffy's theory of growth. <em>Meeresforsch</em>. 28:205-211
</p>
<p>Pauly, D. and N. David, 1981. ELEFAN I, a BASIC program for the objective extraction of
growth parameters from length-frequency data. <em>Meeresforschung</em>, 28(4):205-211
</p>
<p>Pauly, D., 1985. On improving operation and use of ELEFAN programs. Part I: Avoiding
"drift" of K towards low values. <em>ICLARM Conf. Proc.</em>, 13-14
</p>
<p>Pauly, D., 1987. A review of the ELEFAN system for analysis of length-frequency data in
fish and aquatic invertebrates. <em>ICLARM Conf. Proc.</em>, (13):7-34
</p>
<p>Pauly, D. and G. R. Morgan (Eds.), 1987. Length-based methods in fisheries research.
(No. 13). WorldFish
</p>
<p>Pauly, D. and G. Gaschuetz. 1979. A simple method for fitting oscillating length growth data, with a
program for pocket calculators. I.C.E.S. CM 1979/6:24. Demersal Fish Cttee, 26 p.
</p>
<p>Pauly, D. 1984. Fish population dynamics in tropical waters: a manual for use with programmable
calculators (Vol. 8). WorldFish.
</p>
<p>Quenouille, M. H., 1956. Notes on bias in estimation. <em>Biometrika</em>, 43:353-360
</p>
<p>Somers, I. F., 1988. On a seasonally oscillating growth function. ICLARM Fishbyte 6(1): 8-11.
</p>
<p>Sparre, P., Venema, S.C., 1998. Introduction to tropical fish stock assessment.
Part 1. Manual. <em>FAO Fisheries Technical Paper</em>, (306.1, Rev. 2): 407 p.
</p>
<p>Tukey, J., 1958. Bias and confidence in not quite large samples.
<em>Annals of Mathematical Statistics</em>, 29: 614
</p>
<p>Tukey, J., 1986. The future of processes of data analysis. In L. V. Jones (Eds.),
The Collected Works of John W. Tukey-philosophy and principles of data analysis:
1965-1986 (Vol. 4, pp. 517-549). Monterey, CA, USA: Wadsworth &amp; Brooks/Cole
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(alba)

### Response Surface Analysis (varies Linf and K) ###

# 'cross' method (used in FiSAT)
fit1 &lt;- ELEFAN(
   lfq = alba, method = "cross",
   Linf_range = seq(from = 10, to = 20, length.out = 10),
   K_range = exp(seq(from = log(0.1), to = log(2), length.out = 20)),
   cross.date = alba$dates[3], cross.midLength = alba$midLengths[4],
   contour = TRUE
)
fit1$Rn_max; unlist(fit1$par)
plot(fit1); points(alba$dates[3], alba$midLengths[4], col=2, cex=2, lwd=2)

# 'cross' method (bin with maximum score crossed)
fit2 &lt;- ELEFAN(
   lfq = alba, method = "cross",
   Linf_range = seq(from = 10, to = 20, length.out = 20),
   K_range = exp(seq(from = log(0.1), to = log(2), length.out = 20)),
   cross.max = TRUE,
   contour = TRUE
)
fit2$Rn_max; unlist(fit2$par)
plot(fit2); points(alba$dates[7], alba$midLengths[9], col=2, cex=2, lwd=2)


# 'optimise' method (default)
fit3 &lt;- ELEFAN(
   lfq = alba, method = "optimise",
   Linf_range = seq(from = 10, to = 20, length.out = 10),
   K_range = exp(seq(from = log(0.1), to = log(2), length.out = 20)),
   contour = TRUE
)
fit3$Rn_max; unlist(fit3$par)
plot(fit3)


### K-Scan (varies K, Linf is fixed) ###

# 'cross' method
fit4 &lt;- ELEFAN(
   lfq = alba, method = "cross",
   Linf_fix = 10,
   K_range = round(exp(seq(from = log(0.1), to = log(2), length.out = 50)),2),
   cross.date = alba$dates[3], cross.midLength = alba$midLengths[4],
   plot = FALSE
)
fit4$Rn_max; unlist(fit4$par)
plot(fit4); points(alba$dates[3], alba$midLengths[4], col=2, cex=2, lwd=2)



</code></pre>


</div>