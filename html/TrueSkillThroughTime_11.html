<div class="container">

<table style="width: 100%;"><tr>
<td>History-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>History</h2>

<h3>Description</h3>

<p>History class
</p>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>composition</code></td>
<td>
<p>A list of list of player's names (id). Each position of the 
list is a list that represents the teams of a game, so the latter must contain
vectors of names representing the composition of each team in that game.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>results</code></td>
<td>
<p>A list of numeric vectors, representing the outcome of each 
game. It must have the same 
length as the <code>composition</code> list or be an empty list. The default value is an empty list.
When the list is empty, the outcomes of the games are inferred by the order of
the teams in the <code>composition</code> list: the teams appearing firstly in the list 
defeat those appearing later (no ties).
When the list is not empty, each vector of the list must represents the score of each team in the game. The team with the highest score is 
the winner, and the teams with the same score are tied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>A numeric vector, the timestamp of each game. It must have the 
same length as the <code>composition</code> list or be an empty list. The default value 
is an empty list. When the list is empty, all players' games are 
separated by a single timestamp, so a single dynamic uncertainty <code>gamma</code> will be added between games.
When the list is not empty, the amount of dynamic uncertainty will depend on the difference (measured in timestamps) that each player has between games.
In addition, the order of the timestamps determines the reading order of the <code>composition</code> and <code>results</code> lists.
If a player appears more than once in the same timestamp, no dynamic uncertainty will be added between those games.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>priors</code></td>
<td>
<p>A hash object, a dictionary of <code>Player</code> objects indexed by the 
players' name (id). Used to create players with special values. The default
value is an empty hash. In this case, one <code>Player</code> object for each unique 
name in the <code>composition</code> list is automatically initialized using the values 
of the parameters <code>mu</code>, <code>sigma</code>, <code>beta</code>, and <code>gamma</code>.
The names that appear in the hash are the only ones that will be initialized 
with special values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>A number, the prior mean. The deafult value is: <code>MU = 0</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>A number, the prior standar deviation. The deafult value is: 
<code>SIGMA = 6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>A number, the standard deviation of the performance. The default 
value is: <code>BETA = 1</code>. The parameter <code>beta</code> acts as the scale of the 
estimates. A real difference of one <code>beta</code> between two skills is equivalent 
to 76% probability of winning.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>A number, the amount of uncertainty (standar deviation) added to 
the estimates between events. The default value is: <code>GAMMA = 0.03</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p_draw</code></td>
<td>
<p>A number, the probability of a draw. The default value is 
<code>P_DRAW = 0</code>. A rule of thumb states that the probability of a draw must be 
initialized with the observed frequency of draws. If in doubt, it is a candidate 
parameter to be optimized or integrated by the sum rule. It is used to compute 
the prior probability of the observed result, so its value may affect an 
eventual model selection task.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>A number, the convergence threshold. Used to stop the convergence procedure. The default value is <code>EPSILON = 1e-6</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>iterations</code></td>
<td>
<p>A number, the maximum number of iterations for convergence. Used to stop the convergence procedure. The default value is <code>ITERATIONS = 30</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>History object
</p>


<h3>Fields</h3>


<dl>
<dt><code>size</code></dt>
<dd>
<p>A number, the amount of games.</p>
</dd>
<dt><code>batches</code></dt>
<dd>
<p>A vector of <code>Batch</code> objects. Where the games that occur at the same timestamp live.</p>
</dd>
<dt><code>agents</code></dt>
<dd>
<p>A hash, a dictionary indexed by the players' name (id).</p>
</dd>
<dt><code>time</code></dt>
<dd>
<p>A boolean, indicating whether the history was initialized with timestamps or not.</p>
</dd>
<dt><code>mu</code></dt>
<dd>
<p>A number, the default prior mean in this particular <code>History</code> object</p>
</dd>
<dt><code>sigma</code></dt>
<dd>
<p>A number, the default prior standard deviation in this particular <code>History</code> object</p>
</dd>
<dt><code>beta</code></dt>
<dd>
<p>A number, the default standar deviation of the performance in this particular <code>History</code> object</p>
</dd>
<dt><code>gamma</code></dt>
<dd>
<p>A number, the default dynamic uncertainty in this particular <code>History</code> object</p>
</dd>
<dt><code>p_draw</code></dt>
<dd>
<p>A number, the probability of a draw in this particular <code>History</code> object</p>
</dd>
<dt><code>h_epsilon</code></dt>
<dd>
<p>A number, the convergence threshold in this particular <code>History</code> object</p>
</dd>
<dt><code>h_iterations</code></dt>
<dd>
<p>A number, the maximum number of iterations for convergence in this particular <code>History</code> object</p>
</dd>
</dl>
<h3>Methods</h3>


<dl>
<dt><code>convergence(epsilon = NA, iterations = NA, verbose = TRUE)</code></dt>
<dd></dd>
<dt><code>initialize(
  composition,
  results = list(),
  times = c(),
  priors = hash(),
  mu = MU,
  sigma = SIGMA,
  beta = BETA,
  gamma = GAMMA,
  p_draw = P_DRAW,
  epsilon = EPSILON,
  iterations = ITERATIONS
)</code></dt>
<dd></dd>
<dt><code>learning_curves()</code></dt>
<dd></dd>
<dt><code>log_evidence()</code></dt>
<dd></dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">c1 = list(c("a"),c("b"))
c2 = list(c("b"),c("c"))
c3 = list(c("c"),c("a"))
composition = list(c1,c2,c3)
h = History(composition, gamma=0.0)

trueskill_learning_curves = h$learning_curves()
ts_a = trueskill_learning_curves[["a"]]
ts_a[[1]]$N; ts_a[[2]]$N
ts_a[[1]]$t; ts_a[[2]]$t
h$convergence()
trueskillThrougTime_learning_curves = h$learning_curves()
ttt_a = trueskillThrougTime_learning_curves[["a"]]
ttt_a[[1]]$N; ttt_a[[2]]$N
ttt_a[[1]]$t; ttt_a[[2]]$t

## Not run: 
# Synthetic example
library(hash)
N = 100
skill &lt;- function(experience, middle, maximum, slope){
return(maximum/(1+exp(slope*(-experience+middle)))) }
target = skill(seq(N), N/2, 2, 0.075)
opponents = rnorm(N,target,0.5)
composition = list(); results = list(); times = c(); priors = hash()
for(i in seq(N)){composition[[i]] = list(c("a"), c(toString(i)))}
for(i in
seq(N)){results[[i]]=if(rnorm(1,target[i])&gt;rnorm(1,opponents[i])){c(1,0)}else{c(0,1)}}
for(i in seq(N)){times = c(times,i)}
for(i in seq(N)){priors[[toString(i)]] = Player(Gaussian(opponents[i],0.2))}
h = History(composition, results, times, priors, gamma=0.1)
h$convergence(); lc_a = h$learning_curves()$a; mu = c()
for(tp in lc_a){mu = c(mu,tp[[2]]@mu)}
plot(target)
lines(mu)

# Plotting learning curves

# First solve your own example. Here is a dummy one.
agents &lt;- c("a", "b", "c", "d", "e")
composition &lt;- list()
for (i in 1:500) {
 who = sample(agents, 2)
 composition[[i]] &lt;- list(list(who[1]), list(who[2]))
}
h &lt;- History(composition = composition, gamma = 0.03, sigma = 1.0)
h$convergence(iterations=6)

# Then plot some learning curves
lc &lt;- h$learning_curves()
colors &lt;- c(rgb(0.2,0.2,0.8), rgb(0.2,0.8,0.2), rgb(0.8,0.2,0.2))
colors_alpha &lt;- c(rgb(0.2,0.2,0.8,0.2), rgb(0.2,0.8,0.2,0.2), rgb(0.8,0.2,0.2,0.2))
plot(0,0, xlim = c(0, 500), ylim = c(-1, 1), xlab = "t", ylab = "skill", type = "n")
for (i in 1:3) {
  agent &lt;- agents[i]
  t &lt;- c(); mu &lt;- c(); sigma &lt;- c()
  for(x in lc[[agent]]){
    t &lt;- c(t, x$t )
    mu &lt;- c(mu, x$N@mu)
    sigma &lt;- c(sigma, x$N@sigma)
  }
  lines(t, mu, col = colors[i], lwd = 2, type = "l")
  polygon(c(t, rev(t)), c(mu + sigma, rev(mu - sigma)), col = colors_alpha[i], border = NA)
}
legend("topright", legend = agents[1:3], col = colors, lwd = 2)


## End(Not run)
</code></pre>


</div>