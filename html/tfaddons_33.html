<div class="container">

<table style="width: 100%;"><tr>
<td>decoder_beam_search</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>BeamSearch sampling decoder</h2>

<h3>Description</h3>

<p>BeamSearch sampling decoder
</p>


<h3>Usage</h3>

<pre><code class="language-R">decoder_beam_search(
  object,
  cell,
  beam_width,
  embedding_fn = NULL,
  output_layer = NULL,
  length_penalty_weight = 0,
  coverage_penalty_weight = 0,
  reorder_tensor_arrays = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>Model or layer object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cell</code></td>
<td>
<p>An RNNCell instance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>beam_width</code></td>
<td>
<p>integer, the number of beams.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>embedding_fn</code></td>
<td>
<p>A callable that takes a vector tensor of ids (argmax ids).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output_layer</code></td>
<td>
<p>(Optional) An instance of tf.keras.layers.Layer,
i.e., tf$keras$layers$Dense. Optional layer to apply to the RNN output prior
to storing the result or sampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>length_penalty_weight</code></td>
<td>
<p>Float weight to penalize length. Disabled with 0.0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>coverage_penalty_weight</code></td>
<td>
<p>Float weight to penalize the coverage of source
sentence. Disabled with 0.0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reorder_tensor_arrays</code></td>
<td>
<p>If ‘TRUE', TensorArrays’ elements within the cell
state will be reordered according to the beam search path. If the TensorArray
can be reordered, the stacked form will be returned. Otherwise, the TensorArray
will be returned as is. Set this flag to False if the cell state contains
TensorArrays that are not amenable to reordering.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>A list, other keyword arguments for initialization.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>If you are using the 'BeamSearchDecoder' with a cell wrapped in
'AttentionWrapper', then you must ensure that:
- The encoder output has been tiled to 'beam_width' via
'tile_batch()' (NOT 'tf$tile').
- The 'batch_size' argument passed to the 'get_initial_state' method of
this wrapper is equal to 'true_batch_size * beam_width'.
- The initial state created with 'get_initial_state' above contains a
'cell_state' value containing properly tiled final state from the encoder.
</p>


</div>