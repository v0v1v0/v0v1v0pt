<div class="container">

<table style="width: 100%;"><tr>
<td>computePS</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A Vector Summary of the Persistence Silhouette Function</h2>

<h3>Description</h3>

<p>Vectorizes the persistence silhouette (PS) function constructed from a given persistence diagram. The <code class="reqn">p</code>th power silhouette function of a persistence diagram <code class="reqn">D=\{(b_i,d_i)\}_{i=1}^N</code> is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\phi_p(t) = \frac{\sum_{i=1}^N |d_i-b_i|^p\Lambda_i(t)}{\sum_{i=1}^N |d_i-b_i|^p},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_i(t) = \left\{
        \begin{array}{ll}
            t-b_i &amp; \quad t\in [b_i,\frac{b_i+d_i}{2}] \\
            d_i-t &amp; \quad t\in (\frac{b_i+d_i}{2},d_i]\\
            0 &amp; \quad \hbox{otherwise}
        \end{array}
    \right.</code>
</p>

<p>Points of <code class="reqn">D</code> with infinite death value are ignored
</p>


<h3>Usage</h3>

<pre><code class="language-R">computePS(D, homDim, scaleSeq, p=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>matrix with three columns containing the dimension, birth and death values respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>homDim</code></td>
<td>
<p>homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaleSeq</code></td>
<td>
<p>numeric vector of increasing scale values used for vectorization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>power of the weights for the silhouette function. By default, <code>p=1</code></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector whose elements are the average values of the <code class="reqn">p</code>th power silhouette function computed between each pair of
consecutive scale points of <code>scaleSeq</code>=<code class="reqn">\{t_1,t_2,\ldots,t_n\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta t_1}\int_{t_1}^{t_2}\phi_p(t) dt,\frac{1}{\Delta t_2}\int_{t_2}^{t_3}\phi_p(t)dt,\ldots,\frac{1}{\Delta t_{n-1}}\int_{t_{n-1}}^{t_n}\phi_p(t)dt\Big),</code>
</p>

<p>where <code class="reqn">\Delta t_k=t_{k+1}-t_k</code>
</p>


<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Chazal, F., Fasy, B. T., Lecci, F., Rinaldo, A., &amp; Wasserman, L. (2014). Stochastic convergence of persistence landscapes and silhouettes. In Proceedings of the thirtieth annual symposium on Computational geometry (pp. 474-483).
</p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- 100 
set.seed(123)
# sample N points uniformly from unit circle and add Gaussian noise
X &lt;- TDA::circleUnif(N,r=1) + rnorm(2*N,mean = 0,sd = 0.2)

# compute a persistence diagram using the Rips filtration built on top of X
D &lt;- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 

scaleSeq = seq(0,2,length.out=11) # sequence of scale values

# compute persistence silhouette (PS) for homological dimension H_0
computePS(D,homDim=0,scaleSeq,p=1)

# compute persistence silhouette (PS) for homological dimension H_1
computePS(D,homDim=1,scaleSeq,p=1)
</code></pre>


</div>