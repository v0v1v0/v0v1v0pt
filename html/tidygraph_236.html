<div class="container">

<table style="width: 100%;"><tr>
<td>node_measures</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Querying node measures</h2>

<h3>Description</h3>

<p>These functions are a collection of node measures that do not really fall
into the class of centrality measures. For lack of a better place they are
collected under the <code style="white-space: pre;">⁠node_*⁠</code> umbrella of functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">node_eccentricity(mode = "out")

node_constraint(weights = NULL)

node_coreness(mode = "out")

node_diversity(weights)

node_efficiency(weights = NULL, directed = TRUE, mode = "all")

node_bridging_score()

node_effective_network_size()

node_connectivity_impact()

node_closeness_impact()

node_fareness_impact()
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>How edges are treated. In <code>node_coreness()</code> it chooses which kind
of coreness measure to calculate. In <code>node_efficiency()</code> it defines how the
local neighborhood is created</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>The weights to use for each node during calculation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>Should the graph be treated as a directed graph if it is in
fact directed</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector of the same length as the number of nodes in the
graph.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>node_eccentricity()</code>: measure the maximum shortest path to all other nodes in the graph
</p>
</li>
<li> <p><code>node_constraint()</code>: measures Burts constraint of the node. See <code>igraph::constraint()</code>
</p>
</li>
<li> <p><code>node_coreness()</code>: measures the coreness of each node. See <code>igraph::coreness()</code>
</p>
</li>
<li> <p><code>node_diversity()</code>: measures the diversity of the node. See <code>igraph::diversity()</code>
</p>
</li>
<li> <p><code>node_efficiency()</code>: measures the local efficiency around each node. See <code>igraph::local_efficiency()</code>
</p>
</li>
<li> <p><code>node_bridging_score()</code>: measures Valente's Bridging measures for detecting structural bridges (<code>influenceR</code>)
</p>
</li>
<li> <p><code>node_effective_network_size()</code>: measures Burt's Effective Network Size indicating access to structural holes in the network (<code>influenceR</code>)
</p>
</li>
<li> <p><code>node_connectivity_impact()</code>: measures the impact on connectivity when removing the node (<code>NetSwan</code>)
</p>
</li>
<li> <p><code>node_closeness_impact()</code>: measures the impact on closeness when removing the node (<code>NetSwan</code>)
</p>
</li>
<li> <p><code>node_fareness_impact()</code>: measures the impact on fareness (distance between all node pairs) when removing the node (<code>NetSwan</code>)
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R"># Calculate Burt's Constraint for each node
create_notable('meredith') %&gt;%
  mutate(b_constraint = node_constraint())
</code></pre>


</div>