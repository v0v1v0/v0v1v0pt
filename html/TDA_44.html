<div class="container">

<table style="width: 100%;"><tr>
<td>ripsDiag</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Rips Persistence Diagram
</h2>

<h3>Description</h3>

<p>The function <code>ripsDiag</code> computes the persistence diagram of the Rips filtration built on top of a point cloud.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ripsDiag(
    X, maxdimension, maxscale, dist = "euclidean",
    library = "GUDHI", location = FALSE, printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>

<p>If <code>dist="euclidean"</code>, <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">n</code> is the number of points in the <code class="reqn">d</code>-dimensional euclidean space.
If <code>dist="arbitrary"</code>, <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">n</code> matrix of distances of <code class="reqn">n</code> points.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdimension</code></td>
<td>

<p>integer: max dimension of the homological features to be computed. (e.g. 0 for connected components, 1 for connected components and loops, 2 for connected components, loops, voids, etc.)
Currently there is a bug for computing homological features of dimension higher than 1 when the distance is arbitrary (<code>dist = "arbitrary"</code>) and library 'GUDHI' is used (<code>library = "GUDHI"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxscale</code></td>
<td>

<p>number: maximum value of the rips filtration.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dist</code></td>
<td>

<p><code>"euclidean"</code> for Euclidean distance, <code>"arbitrary"</code> for an arbitrary distance given in input as a distance matrix.
Currently there is a bug for the arbitrary distance (<code>dist = "arbitrary"</code>) when computing homological features of dimension higher than 1 and library 'GUDHI' is used (<code>library = "GUDHI"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>library</code></td>
<td>

<p>either a string or a vector of length two. When a vector is given, the first element specifies which library to compute the Rips filtration, and the second element specifies which library to compute the persistence diagram. If a string is used, then the same library is used. For computing the Rips filtration, if <code>dist = "euclidean"</code>, the user can use either the library <code>"GUDHI"</code> or <code>"Dionysus"</code>. If <code>dist = "arbitrary"</code>, the user can use either the library <code>"Dionysus"</code>. The default value is <code>"GUDHI"</code> if <code>dist = "euclidean"</code>, and <code>"Dionysus"</code> if <code>dist == "arbitrary"</code>. When <code>"GUDHI"</code> is used for <code>dist = "arbitrary"</code>, <code>"Dionysus"</code> is implicitly used. For computing the persistence diagram, the user can choose either the library <code>"GUDHI"</code>, <code>"Dionysus"</code>, or <code>"PHAT"</code>. The default value is <code>"GUDHI"</code>.
Currently there is a bug for 'GUDHI' (<code>library = "GUDHI"</code>) when computing homological features of dimension higher than 1 and the distance is arbitrary (<code>dist = "arbitrary"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>location</code></td>
<td>

<p>if <code>TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram, location of birth point and death point of each homological feature is returned. Additionaly if <code>library="Dionysus"</code>, location of representative cycles of each homological feature is also returned.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printProgress</code></td>
<td>

<p>logical: if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For Rips filtration based on Euclidean distance of the input point cloud, the user can decide to use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a> or <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>.
For Rips filtration based on arbitrary distance, the user can decide to the C++ library <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>.
Then for computing the persistence diagram from the Rips filtration, the user can use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>, <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>, or <a href="https://bitbucket.org/phat-code/phat/">PHAT</a>.
Currently there is a bug for computing homological features of dimension higher than 1 when the distance is arbitrary (<code>dist = "arbitrary"</code>) and library 'GUDHI' is used (<code>library = "GUDHI"</code>).
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>ripsDiag</code> returns a list with the following elements:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>diagram</code></td>
<td>

<p>an object of class <code>diagram</code>, a <code class="reqn">P</code> by 3 matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. The first column contains the dimension of each feature (0 for components, 1 for loops, 2 for voids, etc.). Second and third columns are Birth and Death of the features.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>birthLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: if <code>dist="euclidean"</code>, then <code>birthLocation</code> is a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the data point completing the simplex that gives birth to an homological feature. If <code>dist="arbitrary"</code>, then <code>birthLocation</code> is a vector of length <code class="reqn">P</code>. Each row represents the index of the data point completing the simplex that gives birth to an homological feature.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deathLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: if <code>dist="euclidean"</code>, then <code>deathLocation</code> is a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the data point completing the simplex that kills an homological feature. If <code>dist="arbitrary"</code>, then <code>deathLocation</code> is a vector of length <code class="reqn">P</code>. Each row represents the index of the data point completing the simplex that kills an homological feature.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cycleLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: if <code>dist="euclidean"</code>, then <code>cycleLocation</code> is a list of length <code class="reqn">P</code>, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each element is a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> by <code class="reqn">d</code> array for <code class="reqn">h_i</code> dimensional homological feature. It represents location of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices, where <code class="reqn">P_i</code> simplices constitutes the <code class="reqn">h_i</code> dimensional homological feature. If <code>dist = "arbitrary"</code>, then each element is a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> matrix for  for <code class="reqn">h_i</code> dimensional homological feature. It represents index of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices on a representative cycle of the <code class="reqn">h_i</code> dimensional homological feature.
</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Brittany T. Fasy, Jisu Kim, Fabrizio Lecci, and Clement Maria
</p>


<h3>References</h3>

<p>Maria C (2014). "GUDHI, Simplicial Complexes and Persistent Homology Packages." <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>.
</p>
<p>Morozov D (2007). "Dionysus, a C++ library for computing persistent homology". <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>
<p>Edelsbrunner H, Harer J (2010). "Computational topology: an introduction." American Mathematical Society.
</p>
<p>Fasy B, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). "Statistical Inference For Persistent Homology." (arXiv:1303.7117). Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code>summary.diagram</code>, <code>plot.diagram</code>, <code>gridDiag</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## EXAMPLE 1: rips diagram for circles (euclidean distance)
X &lt;- circleUnif(30)
maxscale &lt;- 5
maxdimension &lt;- 1
## note that the input X is a point cloud
DiagRips &lt;- ripsDiag(
    X = X, maxdimension = maxdimension, maxscale = maxscale,
    library = "Dionysus", location = TRUE, printProgress = TRUE)

# plot
layout(matrix(c(1, 3, 2, 2), 2, 2))
plot(X, cex = 0.5, pch = 19)
title(main = "Data")
plot(DiagRips[["diagram"]])
title(main = "rips Diagram")
one &lt;- which(
    DiagRips[["diagram"]][, 1] == 1 &amp;
    DiagRips[["diagram"]][, 3] - DiagRips[["diagram"]][, 2] &gt; 0.5)
plot(X, col = 2, main = "Representative loop of data points")
for (i in seq(along = one)) {
  for (j in seq_len(dim(DiagRips[["cycleLocation"]][[one[i]]])[1])) {
    lines(
	    DiagRips[["cycleLocation"]][[one[i]]][j, , ], pch = 19, cex = 1,
        col = i)
  }
}


## EXAMPLE 2: rips diagram with arbitrary distance
## distance matrix for triangle with edges of length: 1,2,4
distX &lt;- matrix(c(0, 1, 2, 1, 0, 4, 2, 4, 0), ncol = 3)
maxscale &lt;- 5
maxdimension &lt;- 1
## note that the input distXX is a distance matrix
DiagTri &lt;- ripsDiag(distX, maxdimension, maxscale, dist = "arbitrary",
                    printProgress = TRUE)
#points with lifetime = 0 are not shown. e.g. the loop of the triangle.
print(DiagTri[["diagram"]])
</code></pre>


</div>