<div class="container">

<table style="width: 100%;"><tr>
<td>ag_loop_vars</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Specify loop variables</h2>

<h3>Description</h3>

<p>This can be used to manually specify which variables are to be included
explicitly as <code>loop_vars</code> when autographing an expression into a
<code>tf.while_loop()</code> call, or the <code>loop_vars</code> equivalent when building a
<code>dataset.reduce()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ag_loop_vars(
  ...,
  list = character(),
  include = character(),
  exclude = character(),
  undef = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Variables as bare symbol names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list, include, exclude</code></td>
<td>
<p>optionally, the variable names as a character
vector (use this as an escape hatch from the <code>...</code> lazy evaluation
semantics).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>undef</code></td>
<td>
<p>character vector of symbols</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Use of this is usually not required as the loop variables are automatically
inferred. Inference is done by statically looking through the loop body and
finding the symbols that are the targets of the common assignment operators
from base R (<code style="white-space: pre;">⁠&lt;-⁠</code>, <code style="white-space: pre;">⁠-&gt;⁠</code>, <code>=</code>), from package:zeallot (<code style="white-space: pre;">⁠%&lt;-%⁠</code> and <code style="white-space: pre;">⁠%-&gt;%⁠</code>) and
package:magrittr (<code style="white-space: pre;">⁠%&lt;&gt;%⁠</code>).
</p>
<p>In certain circumstances, this approach may capture variables that are
intended to be local variables only. In those circumstances it is also
possible to specify them preceded with a <code>-</code>.
</p>
<p>Note, the specified loop vars are expected to exist before the autographed
expression, and a warning is issued otherwise (usually immediately preceding
an error thrown when attempting to actually autograph the expression)
</p>
<p>Only bare symbol names can be supplied as loop vars. In the future, support
may be expanded to allow for nested complex composites (e.g., specifying
variables that are nested within a more complex structure–passing
<code>ag_loop_vars(foo$bar$baz)</code> is currently not supported.)
</p>


<h3>Value</h3>

<p>the specified hint invisibly.
</p>


<h3>Note</h3>

<p>The semantics of this function are inspired by base::rm()
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
i &lt;- tf$constant(0L)

autograph({
  ag_loop_vars(x, i)
  while(x &gt; 0) {
    if(x %%2 == 0)
      i &lt;- i + 1L
    x &lt;- x - 1
  }
})

## sometimes, a variable is infered to be a loop_var unnecessarily. For example
x &lt;- tf$constant(1:10)

# imagine x is left over in the current scope from some previous calculations
# It's value is not important, but it exists
autograph({
  for(i in tf$constant(1:6)) {
    x &lt;- i * i
    tf$print(x)
  }
})

# this will throw an error because `x` was infered to be a `loop_var`,
# but it's shape witin the loop body is different from what it was before.
# there are two solutions to prevent `x` from being captured as a loop_var
## 1) remove `x` from the current scope like so:
rm(x)

## 2) provide a hint like so:
ag_loop_vars(-x)

## if your variable names are being dynamically generated, there is an
## escape hatch for the lazy evaluation semantics of ...
ag_loop_vars(exclude = "x")

## End(Not run)
</code></pre>


</div>