<div class="container">

<table style="width: 100%;"><tr>
<td>between_time</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Between (For Time Series): Range detection for date or date-time sequences</h2>

<h3>Description</h3>

<p>The easiest way to filter time series date or date-time vectors. Returns a
logical vector indicating which date or date-time values are within a range.
See <code>filter_by_time()</code> for the <code>data.frame</code> (<code>tibble</code>) implementation.
</p>


<h3>Usage</h3>

<pre><code class="language-R">between_time(index, start_date = "start", end_date = "end")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>A date or date-time vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_date</code></td>
<td>
<p>The starting date</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>end_date</code></td>
<td>
<p>The ending date</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><strong>Pure Time Series Filtering Flexibilty</strong>
</p>
<p>The <code>start_date</code>  and <code>end_date</code> parameters are designed with flexibility in mind.
</p>
<p>Each side of the <code>time_formula</code> is specified as the character
<code>'YYYY-MM-DD HH:MM:SS'</code>, but powerful shorthand is available.
Some examples are:
</p>

<ul>
<li> <p><strong>Year:</strong> <code style="white-space: pre;">⁠start_date = '2013', end_date = '2015'⁠</code>
</p>
</li>
<li> <p><strong>Month:</strong> <code style="white-space: pre;">⁠start_date = '2013-01', end_date = '2016-06'⁠</code>
</p>
</li>
<li> <p><strong>Day:</strong> <code style="white-space: pre;">⁠start_date = '2013-01-05', end_date = '2016-06-04'⁠</code>
</p>
</li>
<li> <p><strong>Second:</strong> <code style="white-space: pre;">⁠start_date = '2013-01-05 10:22:15', end_date = '2018-06-03 12:14:22'⁠</code>
</p>
</li>
<li> <p><strong>Variations:</strong> <code style="white-space: pre;">⁠start_date = '2013', end_date = '2016-06'⁠</code>
</p>
</li>
</ul>
<p><strong>Key Words: "start" and "end"</strong>
</p>
<p>Use the keywords "start" and "end" as shorthand, instead of specifying the
actual start and end values. Here are some examples:
</p>

<ul>
<li> <p><strong>Start of the series to end of 2015:</strong> <code style="white-space: pre;">⁠start_date = 'start', end_date = '2015'⁠</code>
</p>
</li>
<li> <p><strong>Start of 2014 to end of series:</strong> <code style="white-space: pre;">⁠start_date = '2014', end_date = 'end'⁠</code>
</p>
</li>
</ul>
<p><strong>Internal Calculations</strong>
</p>
<p>All shorthand dates are expanded:
</p>

<ul>
<li>
<p> The <code>start_date</code> is expanded to be the <em>first date</em> in that period
</p>
</li>
<li>
<p> The <code>end_date</code> side is expanded to be the <em>last date</em> in that period
</p>
</li>
</ul>
<p>This means that the following examples are equivalent (assuming your
index is a POSIXct):
</p>

<ul>
<li> <p><code>start_date = '2015'</code> is equivalent to <code>start_date = '2015-01-01 + 00:00:00' </code>
</p>
</li>
<li> <p><code>end_date = '2016'</code> is equivalent to <code style="white-space: pre;">⁠2016-12-31 + 23:59:59'⁠</code>
</p>
</li>
</ul>
<h3>Value</h3>

<p>A <code>logical</code> vector the same length as <code>index</code> indicating whether or not
the timestamp value was within the <code>start_date</code> and <code>end_date</code> range.
</p>


<h3>References</h3>


<ul><li>
<p> This function is based on the <code>tibbletime::filter_time()</code> function developed by Davis Vaughan.
</p>
</li></ul>
<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code>summarise_by_time()</code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code>mutate_by_time()</code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code>pad_by_time()</code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code>filter_by_time()</code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code>filter_period()</code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code>slice_period()</code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code>condense_period()</code> - Convert to a different periodicity
</p>
</li>
<li> <p><code>between_time()</code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code>slidify()</code> - Turn any function into a sliding (rolling) function
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">library(dplyr)

index_daily &lt;- tk_make_timeseries("2016-01-01", "2017-01-01", by = "day")
index_min   &lt;- tk_make_timeseries("2016-01-01", "2017-01-01", by = "min")

# How it works
# - Returns TRUE/FALSE length of index
# - Use sum() to tally the number of TRUE values
index_daily %&gt;% between_time("start", "2016-01") %&gt;% sum()

# ---- INDEX SLICING ----

# Daily Series: Month of January 2016
index_daily[index_daily %&gt;% between_time("start", "2016-01")]

# Daily Series: March 1st - June 15th, 2016
index_daily[index_daily %&gt;% between_time("2016-03", "2016-06-15")]

# Minute Series:
index_min[index_min %&gt;% between_time("2016-02-01 12:00", "2016-02-01 13:00")]

# ---- FILTERING WITH DPLYR ----
FANG %&gt;%
    group_by(symbol) %&gt;%
    filter(date %&gt;% between_time("2016-01", "2016-01"))

</code></pre>


</div>