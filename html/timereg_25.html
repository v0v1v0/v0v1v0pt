<div class="container">

<table style="width: 100%;"><tr>
<td>comp.risk</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Competings Risks Regression</h2>

<h3>Description</h3>

<p>Fits a semiparametric model for the cause-specific quantities : </p>
<p style="text-align: center;"><code class="reqn"> P(T &lt;
t, cause=1 | x,z) = P_1(t,x,z) = h( g(t,x,z) ) </code>
</p>
<p> for a known link-function
<code class="reqn">h()</code> and known prediction-function <code class="reqn">g(t,x,z)</code> for the probability
of dying from cause 1 in a situation with competing causes of death.
</p>


<h3>Usage</h3>

<pre><code class="language-R">comp.risk(
  formula,
  data = parent.frame(),
  cause,
  times = NULL,
  Nit = 50,
  clusters = NULL,
  est = NULL,
  fix.gamma = 0,
  gamma = 0,
  n.sim = 0,
  weighted = 0,
  model = "fg",
  detail = 0,
  interval = 0.01,
  resample.iid = 1,
  cens.model = "KM",
  cens.formula = NULL,
  time.pow = NULL,
  time.pow.test = NULL,
  silent = 1,
  conv = 1e-06,
  weights = NULL,
  max.clust = 1000,
  n.times = 50,
  first.time.p = 0.05,
  estimator = 1,
  trunc.p = NULL,
  cens.weights = NULL,
  admin.cens = NULL,
  conservative = 1,
  monotone = 0,
  step = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula object, with the response on the left of a '~'
operator, and the terms on the right. The response must be a survival object
as returned by the ‘Event’ function. The status indicator is not important
here. Time-invariant regressors are specified by the wrapper const(), and
cluster variables (for computing robust variances) by the wrapper cluster().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame with the variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cause</code></td>
<td>
<p>For competing risk models specificies which cause we consider.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>times</code></td>
<td>
<p>specifies the times at which the estimator is considered.
Defaults to all the times where an event of interest occurs, with the first
10 percent or max 20 jump points removed for numerical stability in
simulations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nit</code></td>
<td>
<p>number of iterations for Newton-Raphson algorithm.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusters</code></td>
<td>
<p>specifies cluster structure, for backwards compability.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>est</code></td>
<td>
<p>possible starting value for nonparametric component of model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fix.gamma</code></td>
<td>
<p>to keep gamma fixed, possibly at 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>starting value for constant effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sim</code></td>
<td>
<p>number of simulations in resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weighted</code></td>
<td>
<p>Not implemented. To compute a variance weighted version of
the test-processes used for testing time-varying effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>"additive", "prop"ortional, "rcif", or "logistic".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detail</code></td>
<td>
<p>if 0 no details are printed during iterations, if 1 details
are given.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>specifies that we only consider timepoints where the
Kaplan-Meier of the censoring distribution is larger than this value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resample.iid</code></td>
<td>
<p>to return the iid decomposition, that can be used to
construct confidence bands for predictions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cens.model</code></td>
<td>
<p>specified which model to use for the ICPW, KM is
Kaplan-Meier alternatively it may be "cox"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cens.formula</code></td>
<td>
<p>specifies the regression terms used for the regression
model for chosen regression model. When cens.model is specified, the default
is to use the same design as specified for the competing risks model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.pow</code></td>
<td>
<p>specifies that the power at which the time-arguments is
transformed, for each of the arguments of the const() terms, default is 1
for the additive model and 0 for the proportional model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.pow.test</code></td>
<td>
<p>specifies that the power the time-arguments is
transformed for each of the arguments of the non-const() terms. This is
relevant for testing if a coefficient function is consistent with the
specified form A_l(t)=beta_l t^time.pow.test(l). Default is 1 for the
additive model and 0 for the proportional model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>if 0 information on convergence problems due to non-invertible
derviates of scores are printed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>gives convergence criterie in terms of sum of absolute change of
parameters of model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>weights for estimating equations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.clust</code></td>
<td>
<p>sets the total number of i.i.d. terms in i.i.d.
decompostition. This can limit the amount of memory used by coarsening the
clusters. When NULL then all clusters are used.  Default is 1000 to save
memory and time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.times</code></td>
<td>
<p>only uses 50 points for estimation, if NULL then uses all
points, subject to p.start condition.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first.time.p</code></td>
<td>
<p>first point for estimation is pth percentile of cause
jump times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>estimator</code></td>
<td>
<p>default estimator is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trunc.p</code></td>
<td>
<p>truncation weight for delayed entry, P(T &gt; entry.time | Z_i),
typically Cox model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cens.weights</code></td>
<td>
<p>censoring weights can be given here rather than
calculated using the KM, cox or aalen models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>admin.cens</code></td>
<td>
<p>censoring times for the administrative censoring</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conservative</code></td>
<td>
<p>set to 0 to compute correct variances based on censoring
weights, default is conservative estimates that are much quicker.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>monotone</code></td>
<td>
<p>monotone=0, uses estimating equations </p>
<p style="text-align: center;"><code class="reqn"> (D_\beta P_1) w(t) ( Y(t)/G_c(t) - P_1(t,X))</code>
</p>
<p> montone=1 uses </p>
<p style="text-align: center;"><code class="reqn"> w(t) X ( Y(t)/G_c(t) - P_1(t,X)) </code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step</code></td>
<td>
<p>step size for Fisher-Scoring algorithm.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>We consider the following models : 1) the additive model where
<code class="reqn">h(x)=1-\exp(-x)</code> and </p>
<p style="text-align: center;"><code class="reqn"> g(t,x,z) = x^T A(t) + (diag(t^p) z)^T \beta
</code>
</p>
<p> 2) the proportional setting that includes the Fine &amp; Gray (FG) "prop"
model and some extensions where <code class="reqn">h(x)=1-\exp(-\exp(x))</code> and </p>
<p style="text-align: center;"><code class="reqn">
g(t,x,z) = (x^T A(t) + (diag(t^p) z)^T \beta) </code>
</p>
<p> The FG model is obtained
when <code class="reqn">x=1</code>, but the baseline is parametrized as <code class="reqn">\exp(A(t))</code>.
</p>
<p>The "fg" model is a different parametrization that contains the FG model,
where <code class="reqn">h(x)=1-\exp(-x)</code> and </p>
<p style="text-align: center;"><code class="reqn"> g(t,x,z) = (x^T A(t)) \exp((diag(t^p)
z)^T \beta) </code>
</p>
<p> The FG model is obtained when <code class="reqn">x=1</code>.
</p>
<p>3) a "logistic" model where <code class="reqn">h(x)=\exp(x)/( 1+\exp(x))</code> and </p>
<p style="text-align: center;"><code class="reqn">
g(t,x,z) = x^T A(t) + (diag(t^p) z)^T \beta</code>
</p>
 
<p>The "logistic2" is </p>
<p style="text-align: center;"><code class="reqn"> P_1(t,x,z) = x^T A(t) exp((diag(t^p) z)^T \beta)/
(1+ x^T A(t) exp((diag(t^p) z)^T \beta)) </code>
</p>
<p> The simple logistic model with
just a baseline can also be fitted by an alternative procedure that has
better small sample properties see prop.odds.subist().
</p>
<p>4) the relative cumulative incidence function "rcif" model where
<code class="reqn">h(x)=\exp(x)</code> and </p>
<p style="text-align: center;"><code class="reqn"> g(t,x,z) = x^T A(t) + (diag(t^p) z)^T \beta </code>
</p>

<p>The "rcif2" </p>
<p style="text-align: center;"><code class="reqn"> P_1(t,x,z) = (x^T A(t)) \exp((diag(t^p) z)^T \beta) </code>
</p>

<p>Where p by default is 1 for the additive model and 0 for the other models.
In general p may be powers of the same length as z.
</p>
<p>Since timereg version 1.8.4. the response must be specified with the
<code>Event</code> function instead of the <code>Surv</code> function and
the arguments. For example, if the old code was
</p>
<p>comp.risk(Surv(time,cause&gt;0)~x1+x2,data=mydata,cause=mydata$cause,causeS=1)
</p>
<p>the new code is
</p>
<p>comp.risk(Event(time,cause)~x1+x2,data=mydata,cause=1)
</p>
<p>Also the argument cens.code is now obsolete since cens.code is an argument
of <code>Event</code>.
</p>


<h3>Value</h3>

<p>returns an object of type 'comprisk'. With the following arguments:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>cum</code></td>
<td>
<p>cumulative timevarying regression coefficient estimates are
computed within the estimation interval.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.cum</code></td>
<td>
<p>pointwise variances
estimates.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma</code></td>
<td>
<p>estimate of proportional odds parameters of
model.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var.gamma</code></td>
<td>
<p>variance for gamma.  </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>score</code></td>
<td>
<p>sum of absolute
value of scores.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma2</code></td>
<td>
<p>estimate of constant effects based on the
non-parametric estimate. Used for testing of constant effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.testBeq0</code></td>
<td>
<p>observed absolute value of supremum of cumulative
components scaled with the variance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.testBeq0</code></td>
<td>
<p>p-value for
covariate effects based on supremum test.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.testBeqC</code></td>
<td>
<p>observed
absolute value of supremum of difference between observed cumulative process
and estimate under null of constant effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.testBeqC</code></td>
<td>
<p>p-value
based on resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obs.testBeqC.is</code></td>
<td>
<p>observed integrated squared
differences between observed cumulative and estimate under null of constant
effect.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pval.testBeqC.is</code></td>
<td>
<p>p-value based on resampling.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.band</code></td>
<td>
<p>resampling based constant to construct 95% uniform
confidence bands.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B.iid</code></td>
<td>
<p>list of iid decomposition of non-parametric
effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gamma.iid</code></td>
<td>
<p>matrix of iid decomposition of parametric
effects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test.procBeqC</code></td>
<td>
<p>observed test process for testing of
time-varying effects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sim.test.procBeqC</code></td>
<td>
<p>50 resample processes for for
testing of time-varying effects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conv</code></td>
<td>
<p>information on convergence for
time points used for estimation.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Thomas Scheike
</p>


<h3>References</h3>

<p>Scheike, Zhang and Gerds (2008), Predicting cumulative incidence
probability by direct binomial regression,Biometrika, 95, 205-220.
</p>
<p>Scheike and Zhang (2007), Flexible competing risks regression modelling and
goodness of fit, LIDA, 14, 464-483.
</p>
<p>Martinussen and Scheike (2006), Dynamic regression models for survival data,
Springer.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(bmt); 

clust &lt;- rep(1:204,each=2)
addclust&lt;-comp.risk(Event(time,cause)~platelet+age+tcell+cluster(clust),data=bmt,
cause=1,resample.iid=1,n.sim=100,model="additive")
###

addclust&lt;-comp.risk(Event(time,cause)~+1+cluster(clust),data=bmt,cause=1,
		    resample.iid=1,n.sim=100,model="additive")
pad &lt;- predict(addclust,X=1)
plot(pad)

add&lt;-comp.risk(Event(time,cause)~platelet+age+tcell,data=bmt,
cause=1,resample.iid=1,n.sim=100,model="additive")
summary(add)

par(mfrow=c(2,4))
plot(add); 
### plot(add,score=1) ### to plot score functions for test

ndata&lt;-data.frame(platelet=c(1,0,0),age=c(0,1,0),tcell=c(0,0,1))
par(mfrow=c(2,3))
out&lt;-predict(add,ndata,uniform=1,n.sim=100)
par(mfrow=c(2,2))
plot(out,multiple=0,uniform=1,col=1:3,lty=1,se=1)

## fits additive model with some constant effects 
add.sem&lt;-comp.risk(Event(time,cause)~
const(platelet)+const(age)+const(tcell),data=bmt,
cause=1,resample.iid=1,n.sim=100,model="additive")
summary(add.sem)

out&lt;-predict(add.sem,ndata,uniform=1,n.sim=100)
par(mfrow=c(2,2))
plot(out,multiple=0,uniform=1,col=1:3,lty=1,se=0)

## Fine &amp; Gray model 
fg&lt;-comp.risk(Event(time,cause)~
const(platelet)+const(age)+const(tcell),data=bmt,
cause=1,resample.iid=1,model="fg",n.sim=100)
summary(fg)

out&lt;-predict(fg,ndata,uniform=1,n.sim=100)

par(mfrow=c(2,2))
plot(out,multiple=1,uniform=0,col=1:3,lty=1,se=0)

## extended model with time-varying effects
fg.npar&lt;-comp.risk(Event(time,cause)~platelet+age+const(tcell),
data=bmt,cause=1,resample.iid=1,model="prop",n.sim=100)
summary(fg.npar); 

out&lt;-predict(fg.npar,ndata,uniform=1,n.sim=100)
head(out$P1[,1:5]); head(out$se.P1[,1:5])

par(mfrow=c(2,2))
plot(out,multiple=1,uniform=0,col=1:3,lty=1,se=0)

## Fine &amp; Gray model with alternative parametrization for baseline
fg2&lt;-comp.risk(Event(time,cause)~const(platelet)+const(age)+const(tcell),data=bmt,
cause=1,resample.iid=1,model="prop",n.sim=100)
summary(fg2)

#################################################################
## Delayed entry models, 
#################################################################
nn &lt;- nrow(bmt)
entrytime &lt;- rbinom(nn,1,0.5)*(bmt$time*runif(nn))
bmt$entrytime &lt;- entrytime
times &lt;- seq(5,70,by=1)

bmtw &lt;- prep.comp.risk(bmt,times=times,time="time",entrytime="entrytime",cause="cause")

## non-parametric model 
outnp &lt;- comp.risk(Event(time,cause)~tcell+platelet+const(age),
		   data=bmtw,cause=1,fix.gamma=1,gamma=0,
 cens.weights=bmtw$cw,weights=bmtw$weights,times=times,n.sim=0)
par(mfrow=c(2,2))
plot(outnp)

outnp &lt;- comp.risk(Event(time,cause)~tcell+platelet,
		   data=bmtw,cause=1,
 cens.weights=bmtw$cw,weights=bmtw$weights,times=times,n.sim=0)
par(mfrow=c(2,2))
plot(outnp)


## semiparametric model 
out &lt;- comp.risk(Event(time,cause)~const(tcell)+const(platelet),data=bmtw,cause=1,
 cens.weights=bmtw$cw,weights=bmtw$weights,times=times,n.sim=0)
summary(out)


</code></pre>


</div>