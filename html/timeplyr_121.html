<div class="container">

<table style="width: 100%;"><tr>
<td>time_expandv</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Vector date and datetime functions</h2>

<h3>Description</h3>

<p>These are atomic vector-based functions
of the tidy equivalents which all have a "v" suffix to denote this.
These are more geared towards programmers and allow for working with date and
datetime vectors.
</p>


<h3>Usage</h3>

<pre><code class="language-R">time_expandv(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  g = NULL,
  use.g.names = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA")
)

time_span(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  g = NULL,
  use.g.names = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA")
)

time_completev(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA")
)

time_summarisev(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = FALSE,
  unique = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA"),
  as_interval = getOption("timeplyr.use_intervals", TRUE)
)

time_countv(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  sort = TRUE,
  unique = TRUE,
  complete = FALSE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1),
  roll_month = getOption("timeplyr.roll_month", "preday"),
  roll_dst = getOption("timeplyr.roll_dst", "NA"),
  as_interval = getOption("timeplyr.use_intervals", TRUE)
)

time_span_size(
  x,
  time_by = NULL,
  from = NULL,
  to = NULL,
  g = NULL,
  use.g.names = TRUE,
  time_type = getOption("timeplyr.time_type", "auto"),
  time_floor = FALSE,
  week_start = getOption("lubridate.week.start", 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Time variable. <br>
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, <code>yearqtr</code>,
<code>year_month</code> or <code>year_quarter</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_by</code></td>
<td>
<p>Time unit. <br>
Must be one of the following:
</p>

<ul>
<li>
<p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li>
<p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li>
<p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>Time series start date.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>Time series end date.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>Grouping object passed directly to <code>collapse::GRP()</code>.
This can for example be a vector or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use.g.names</code></td>
<td>
<p>Should the result include group names?
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_type</code></td>
<td>
<p>If "auto", <code>periods</code> are used for
the time expansion when days, weeks, months or years are specified,
and <code>durations</code> are used otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_floor</code></td>
<td>
<p>Should <code>from</code> be floored to the nearest unit specified
through the <code>time_by</code> argument?
This is particularly useful for starting sequences at the
beginning of a week or month for example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>week_start</code></td>
<td>
<p>day on which week starts following ISO conventions - 1
means Monday (default), 7 means Sunday.
This is only used when <code>time_floor = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roll_month</code></td>
<td>
<p>Control how impossible dates are handled when
month or year arithmetic is involved.
Options are "preday", "boundary", "postday", "full" and "NA".
See <code>?timechange::time_add</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>roll_dst</code></td>
<td>
<p>See <code>?timechange::time_add</code> for the full list of details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sort</code></td>
<td>
<p>Should the output be sorted? Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique</code></td>
<td>
<p>Should the result be unique or match the length of the vector?
Default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as_interval</code></td>
<td>
<p>Should result be a <code>time_interval</code>?
Default is <code>FALSE</code>. <br>
This can be controlled globally through <code>options(timeplyr.use_intervals)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>Logical. If <code>TRUE</code> implicit gaps in time are filled
before counting and after time aggregation (controlled using <code>time_by</code>).
The default is <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Vectors (typically the same class as <code>x</code>) of varying lengths depending
on the arguments supplied.
<code>time_countv()</code> returns a <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(timeplyr)
library(dplyr)
library(lubridate)
library(nycflights13)

x &lt;- unique(flights$time_hour)

# Number of missing hours
time_num_gaps(x)

# Same as above
time_span_size(x) - length(unique(x))

# Time sequence that spans the data
length(time_span(x)) # Automatically detects hour granularity
time_span(x, time_by = "month")
time_span(x, time_by = list("quarters" = 1),
             to = today(),
             # Floor start of sequence to nearest month
             time_floor = TRUE)

# Complete missing gaps in time using time_completev
y &lt;- time_completev(x, time_by = "hour")
identical(y[!y %in% x], time_gaps(x))

# Summarise time using time_summarisev
time_summarisev(y, time_by = "quarter")
time_summarisev(y, time_by = "quarter", unique = TRUE)
flights %&gt;%
  fcount(quarter = time_summarisev(time_hour, "quarter"))
# Alternatively
time_countv(flights$time_hour, time_by = "quarter")
# If you want the above as an atomic vector just use tibble::deframe

</code></pre>


</div>