<div class="container">

<table style="width: 100%;"><tr>
<td>mcmc_uncalibrated_langevin</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Runs one step of Uncalibrated Langevin discretized diffusion.</h2>

<h3>Description</h3>

<p>The class generates a Langevin proposal using <code style="white-space: pre;">⁠_euler_method⁠</code> function and
also computes helper <code>UncalibratedLangevinKernelResults</code> for the next
iteration.
Warning: this kernel will not result in a chain which converges to the
<code>target_log_prob</code>. To get a convergent MCMC, use
<code>MetropolisAdjustedLangevinAlgorithm(...)</code> or <code>MetropolisHastings(UncalibratedLangevin(...))</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcmc_uncalibrated_langevin(
  target_log_prob_fn,
  step_size,
  volatility_fn = NULL,
  parallel_iterations = 10,
  compute_acceptance = TRUE,
  seed = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>target_log_prob_fn</code></td>
<td>
<p>Function which takes an argument like
<code>current_state</code> (if it's a list <code>current_state</code> will be unpacked) and returns its
(possibly unnormalized) log-density under the target distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step_size</code></td>
<td>
<p><code>Tensor</code> or <code>list</code> of <code>Tensor</code>s representing the step
size for the leapfrog integrator. Must broadcast with the shape of
<code>current_state</code>. Larger step sizes lead to faster progress, but
too-large step sizes make rejection exponentially more likely. When
possible, it's often helpful to match per-variable step sizes to the
standard deviations of the target distribution in each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>volatility_fn</code></td>
<td>
<p>function which takes an argument like
<code>current_state</code> (or <code style="white-space: pre;">⁠*current_state⁠</code> if it's a list) and returns
volatility value at <code>current_state</code>. Should return a <code>Tensor</code> or
<code>list</code> of <code>Tensor</code>s that must broadcast with the shape of
<code>current_state</code>. Defaults to the identity function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel_iterations</code></td>
<td>
<p>the number of coordinates for which the gradients of
the volatility matrix <code>volatility_fn</code> can be computed in parallel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_acceptance</code></td>
<td>
<p>logical indicating whether to compute the
Metropolis log-acceptance ratio used to construct <code>MetropolisAdjustedLangevinAlgorithm</code> kernel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer to seed the random number generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>String prefixed to Ops created by this function.
Default value: <code>NULL</code> (i.e., 'mala_kernel').</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>list of
<code>next_state</code> (Tensor or Python list of <code>Tensor</code>s representing the state(s)
of the Markov chain(s) at each result step. Has same shape as
and <code>current_state</code>.) and
<code>kernel_results</code> (<code>collections$namedtuple</code> of internal calculations used to
'advance the chain).
</p>


<h3>See Also</h3>

<p>Other mcmc_kernels: 
<code>mcmc_dual_averaging_step_size_adaptation()</code>,
<code>mcmc_hamiltonian_monte_carlo()</code>,
<code>mcmc_metropolis_adjusted_langevin_algorithm()</code>,
<code>mcmc_metropolis_hastings()</code>,
<code>mcmc_no_u_turn_sampler()</code>,
<code>mcmc_random_walk_metropolis()</code>,
<code>mcmc_replica_exchange_mc()</code>,
<code>mcmc_simple_step_size_adaptation()</code>,
<code>mcmc_slice_sampler()</code>,
<code>mcmc_transformed_transition_kernel()</code>,
<code>mcmc_uncalibrated_hamiltonian_monte_carlo()</code>,
<code>mcmc_uncalibrated_random_walk()</code>
</p>


</div>