<div class="container">

<table style="width: 100%;"><tr>
<td>computePI</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>A Vector Summary of the Persistence Surface</h2>

<h3>Description</h3>

<p>For a given persistence diagram <code class="reqn">D=\{(b_i,p_i)\}_{i=1}^N</code>, <code>computePI()</code> computes the persistence image (PI) - a vector summary of the persistence surface: </p>
<p style="text-align: center;"><code class="reqn">\rho(x,y)=\sum_{i=1}^N f(b_i,p_i)\phi_{(b_i,p_i)}(x,y),</code>
</p>
<p> where <code class="reqn">\phi_{(b_i,p_i)}(x,y)</code> is 
the Gaussian distribution with mean <code class="reqn">(b_i,p_i)</code> and 
covariance matrix <code class="reqn">\sigma^2 I_{2\times 2}</code> and 
</p>
<p style="text-align: center;"><code class="reqn">f(b,p) = w(p)=\left\{
        \begin{array}{ll}
            0 &amp; \quad y\leq 0 \\
            p/p_{max} &amp; \quad 0&lt;p&lt;p_{max}\\
            1&amp; \quad y\geq p_{max}
        \end{array}
    \right.</code>
</p>

<p>is the weighting function with <code class="reqn">p_{max}</code> being the maximum persistence value among all persistence diagrams considered in the experiment. Points of <code class="reqn">D</code> with infinite persistence value are ignored
</p>


<h3>Usage</h3>

<pre><code class="language-R">computePI(D, homDim, xSeq, ySeq, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>matrix with three columns containing the dimension, birth and persistence values respectively</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>homDim</code></td>
<td>
<p>homological dimension (0 for <code class="reqn">H_0</code>, 1 for <code class="reqn">H_1</code>, etc.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xSeq</code></td>
<td>
<p>numeric vector of increasing x (birth) values used for vectorization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ySeq</code></td>
<td>
<p>numeric vector of increasing y (persistence) values used for vectorization</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>standard deviation of the Gaussian</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A numeric vector whose elements are the average values of the persistence surface computed over each cell of the two-dimensional grid constructred from <code>xSeq</code>=<code class="reqn">\{x_1,x_2,\ldots,x_n\}</code> and <code>ySeq</code>=<code class="reqn">\{y_1,y_2,\ldots,y_m\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\Big(\frac{1}{\Delta x_1\Delta y_1}\int_{[x_1,x_2]\times [y_1,y_2]}\rho(x,y)dA,\ldots,\frac{1}{\Delta x_{n-1}\Delta y_{m-1}}\int_{[x_{n-1},x_n]\times [y_{m-1},y_m]}\rho(x,y)dA\Big),</code>
</p>

<p>where <code class="reqn">dA=dxdy</code>, <code class="reqn">\Delta x_k=x_{k+1}-x_k</code> and <code class="reqn">\Delta y_j=y_{j+1}-y_j</code>
</p>


<h3>Author(s)</h3>

<p>Umar Islambekov</p>


<h3>References</h3>

<p>1. Adams, H., Emerson, T., Kirby, M., Neville, R., Peterson, C., Shipman, P., ... &amp; Ziegelmeier, L. (2017). Persistence images: A stable vector representation of persistent homology. Journal of Machine Learning Research, 18.
</p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- 100 
set.seed(123)
# sample N points uniformly from unit circle and add Gaussian noise
X &lt;- TDA::circleUnif(N,r=1) + rnorm(2*N,mean = 0,sd = 0.2)

# compute a persistence diagram using the Rips filtration built on top of X
D &lt;- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 

# switch from the birth-death to the birth-persistence coordinates
D[,3] &lt;- D[,3] - D[,2] 
colnames(D)[3] &lt;- "Persistence"

resB &lt;- 5 # resolution (or grid size) along the birth axis
resP &lt;- 5 # resolution (or grid size) along the persistence axis 

# compute PI for homological dimension H_0
minPH0 &lt;- min(D[D[,1]==0,3]); maxPH0 &lt;- max(D[D[,1]==0,3])
ySeqH0 &lt;- seq(minPH0,maxPH0,length.out=resP+1)
sigma &lt;- 0.5*(maxPH0-minPH0)/resP 
computePI(D,homDim=0,xSeq=NA,ySeqH0,sigma) 

# compute PI for homological dimension H_1
minBH1 &lt;- min(D[D[,1]==1,2]); maxBH1 &lt;- max(D[D[,1]==1,2])
minPH1 &lt;- min(D[D[,1]==1,3]); maxPH1 &lt;- max(D[D[,1]==1,3])
xSeqH1 &lt;- seq(minBH1,maxBH1,length.out=resB+1)
ySeqH1 &lt;- seq(minPH1,maxPH1,length.out=resP+1)
sigma &lt;- 0.5*(maxPH1-minPH1)/resP
computePI(D,homDim=1,xSeqH1,ySeqH1,sigma) 
</code></pre>


</div>