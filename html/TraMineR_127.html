<div class="container">

<table style="width: 100%;"><tr>
<td>seqipos</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Indicators for binary sequences of positive and negative states.</h2>

<h3>Description</h3>

<p>Indicators for the underlying binary sequences of positive and negative states.
Possible indicators are the proportion of positive states within each sequence, i.e. of positive spells if computed on the sequences of distinct successive states (DSS), objective volatility of the binary sequences, and capacity to integrate a positive state.
</p>


<h3>Usage</h3>

<pre><code class="language-R">  seqipos(seqdata, dss=NULL, pos.states=NULL, neg.states=NULL, index="share",
     pow=1, w=.5, with.missing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seqdata</code></td>
<td>
<p>a state sequence object (<code>stslist</code>) as returned by <code>seqdef</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dss</code></td>
<td>
<p>logical. Should the proportion be computed inside the DSS sequences? Defaults to <code>TRUE</code> when <code>index="share"</code> and to <code>FALSE</code> otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pos.states</code></td>
<td>
<p>vector of positive states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neg.states</code></td>
<td>
<p>vector of negative states.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>index</code></td>
<td>
<p>character string. One of <code>"share"</code> (proportion of positive states or spells), <code>"volatility"</code> (objective volatility), or <code>"integr"</code> (capability to integrate a positive state). See Details. Default is <code>"share"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pow</code></td>
<td>
<p>real. Recency exponent passed to <code>seqintegr</code>. Only used when <code>index="integr"</code>. Default is 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>real in range [0,1]. Relative weight of proportion of visited states in volatility (see <code>seqivolatility</code>). Only used when <code>index="volatility"</code>. Default is .5.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function transforms the provided state sequences into binary sequences of positive and negative states. When <code>dss = TRUE</code>, the counts of positive and negative elements give the number of positive and negative spells. The binary state sequence object is returned as an attribute.
</p>
<p>When <code>neg.states=NULL</code>, states not listed on the <code>pos.states</code> argument are considered as negative and conversely when <code>pos.states=NULL</code>. When <code>with.missing=TRUE</code>, the missing state <code>nr</code> will be considered as positive if included in the <code>pos.states</code> list or as negative if in <code>neg.states</code>.  When <code>with.missing=FALSE</code> (default) missing states are ignored. However, when missing values appear within a spell, such as in AA*ABB, the spell is split into two consecutive spells in a same state. For the example we would have AAB, i.e. if A is positive and B negative, a proportion of 2/3 of positive spells.
</p>
<p>When both <code>pos.states</code> and <code>neg.states</code> are provided, states of the alphabet (including the <code>nr</code> code when <code>with.missing=TRUE</code>) that belong nor to <code>pos.states</code> nor to <code>neg.states</code> are ignored.
</p>
<p>For <code>index="share"</code>, letting <code class="reqn">npos</code> be the number of positive states and <code class="reqn">nneg</code> the number of negative states in the sequence, the function returns the value of <code class="reqn">npos/(npos + nneg)</code> for each sequence. With <code>dss=TRUE</code>, this is the normative volatility of Brzinsky-Fay (2007,2018).
</p>
<p>For <code>index="volatility"</code>, the function returns the objective volatility of the binary sequences. See <code>seqivolatility</code>.
</p>
<p>For <code>index="integr"</code>, the function returns the index of integrative potential for the positive state. See <code>seqintegr</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of <br>
- when <code>index="share"</code>, the proportion of positive states (or spells) within each sequence;<br>
- when <code>index="volatility"</code>, the objective volatility of the binary sequences;<br>
- when <code>index="integration"</code>, the index of integration into a positive state.<br>
The binary sequence as an attribute <code>sbinary</code>.
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Brzinsky-Fay, C. (2007) Lost in Transition? Labour Market Entry Sequences of School Leavers in Europe, <em>European Sociological Review</em>, 23(4). <a href="https://doi.org/10.1093/esr/jcm011">doi:10.1093/esr/jcm011</a>
</p>
<p>Brzinsky-Fay, C. (2018) Unused Resources: Sequence and Trajectory Indicators. International Symposium on Sequence Analysis and Related Methods, Monte Verita, TI, Switzerland, October 10-12, 2018.
</p>
<p>Ritschard, G. (2023), "Measuring the nature of individual sequences", <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code>seqindic, seqintegr, seqivolatility</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(ex1)
sx &lt;- seqdef(ex1[,1:13], right="DEL")
nr &lt;- attr(sx,'nr') ## code for missing values

seqipos(sx, pos.states=c("A","B"))
seqipos(sx, pos.states=c("A","B"), with.missing=TRUE)

## ignoring state "D"
seqipos(sx, pos.states=c("A","B"), neg.states=c("C",nr), with.missing=TRUE)

seqipos(sx, pos.states=c("A","B"), dss=FALSE)
seqipos(sx, pos.states=c("A","B",nr), dss=FALSE, with.missing=TRUE)

seqipos(sx, pos.states=c("A","B"), index="volatility")
seqipos(sx, pos.states=c("A","B"), index="integr")

## retrieving the binary sequences
ip &lt;- seqipos(sx, pos.states=c("A","B"))
attr(ip,"sbinary")
ip &lt;- seqipos(sx, pos.states=c("A","B"), with.missing=TRUE)
attr(ip,"sbinary")

</code></pre>


</div>