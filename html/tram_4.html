<div class="container">

<table style="width: 100%;"><tr>
<td>tram-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Methods for Stratified Linear Transformation Models
</h2>

<h3>Description</h3>

<p>Methods for objects inheriting from class tram
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'tram'
as.mlt(object)
## S3 method for class 'tram'
model.frame(formula, ...)
## S3 method for class 'tram'
model.matrix(object, data = object$data, with_baseline = FALSE, ...) 
## S3 method for class 'stram'
model.matrix(object, data = object$data, with_baseline = FALSE, 
       what = c("shifting", "scaling"), ...) 
## S3 method for class 'tram'
coef(object, with_baseline = FALSE, ...) 
## S3 method for class 'Lm'
coef(object, as.lm = FALSE, ...)
## S3 method for class 'Survreg'
coef(object, as.survreg = FALSE, ...)
## S3 method for class 'tram'
vcov(object, with_baseline = FALSE, complete = FALSE, ...) 
## S3 method for class 'tram'
logLik(object, parm = coef(as.mlt(object), fixed = FALSE), ...)
## S3 method for class 'tram'
estfun(x, parm = coef(as.mlt(x), fixed = FALSE), ...)
## S3 method for class 'tram'
predict(object, newdata = model.frame(object), 
        type = c("lp", "trafo", "distribution", "logdistribution", 
             "survivor", "logsurvivor", "density", "logdensity", 
             "hazard", "loghazard", "cumhazard", "logcumhazard", 
             "odds", "logodds", "quantile"), ...) 
## S3 method for class 'stram'
predict(object, newdata = model.frame(object), 
        type = c("lp", "trafo", "distribution", "logdistribution", 
             "survivor", "logsurvivor", "density", "logdensity", 
             "hazard", "loghazard", "cumhazard", "logcumhazard", 
             "odds", "logodds", "quantile"), 
        what = c("shifting", "scaling"), ...)
## S3 method for class 'tram'
plot(x, newdata = model.frame(x), 
     which = c("QQ-PIT", "baseline only", "distribution"), 
     confidence = c("none", "interval", "band"), level = 0.95, 
     K = 50, cheat = K, col = "black", fill = "lightgrey", lwd = 1, ...)
## S3 method for class 'tram'
residuals(object, ...)
## S3 method for class 'tram'
PI(object, newdata = model.frame(object), reference = 0,
                  one2one = FALSE, ...)
## Default S3 method:
PI(object, prob, link = "logistic", ...)
## S3 method for class 'tram'
OVL(object, newdata = model.frame(object), reference = 0,
                  one2one = FALSE, ...)
## Default S3 method:
OVL(object, link = "logistic", ...)
## S3 method for class 'tram'
TV(object, newdata = model.frame(object), reference = 0,
                  one2one = FALSE, ...)
## Default S3 method:
TV(object, link = "logistic", ...)
## S3 method for class 'tram'
L1(object, newdata = model.frame(object), reference = 0,
                  one2one = FALSE, ...)
## Default S3 method:
L1(object, link = "logistic", ...)
## S3 method for class 'tram'
ROC(object, newdata = model.frame(object), reference = 0,
                   prob = 1:99 / 100, one2one = FALSE, ...)
## Default S3 method:
ROC(object, prob = 1:99 / 100, link = "logistic", ...)
## S3 method for class 'ROCtram'
plot(x, lty = 1:ncol(x), col = "black", 
     fill = "lightgrey", lwd = 1, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object, formula, x</code></td>
<td>
<p>a fitted stratified linear transformation model inheriting
from class <code>tram</code>. <code>PI</code> also takes a numeric
vector in the default method.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_baseline</code></td>
<td>
<p>logical, if <code>TRUE</code> all model parameters
are returned, otherwise parameters describing the
baseline transformation are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.lm</code></td>
<td>
<p>logical, return parameters in the <code>lm</code>
parameterisation if <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>as.survreg</code></td>
<td>
<p>logical, return parameters in the <code>survreg</code>
parameterisation in <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parm</code></td>
<td>
<p>model parameters, including baseline parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>complete</code></td>
<td>
<p>currently ignored</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>newdata</code></td>
<td>
<p>an optional data frame of new observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reference</code></td>
<td>
<p>an optional data frame of reference observations, or 
a numeric vector of reference values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>type of prediction, current options include
linear predictors (<code>"lp"</code>, of <code>x</code> variables in the
formula <code>y | s ~ x</code>), transformation functions
(<code>"trafo"</code>) or distribution functions on the
scale of the cdf (<code>"distribution"</code>),
survivor function, density function, log-density
function, hazard function, log-hazard function, cumulative
hazard function or quantile function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>which</code></td>
<td>
<p>type of plot, either a QQ plot of the probability-integral
transformed observations (<code>"QQ-PIT"</code>), of the
baseline transformation of the whole distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>what</code></td>
<td>
<p>type of model matrix / linear predictor: <code>shifting</code> returns model
model matrix / linear predictor for shift term, <code>scaling</code> for the scale term.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>confidence</code></td>
<td>
<p>type of uncertainty assessment.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>level</code></td>
<td>
<p>confidence level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>number of grid points in the response, see
<code>plot.ctm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cheat</code></td>
<td>
<p>reduced number of grid points for the computation
of confidence bands, see <code>confband</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>line color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>fill color.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lwd</code></td>
<td>
<p>line width.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lty</code></td>
<td>
<p>line type.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>a numeric vector of probabilities..</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>link</code></td>
<td>
<p>a character identifying a link function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>one2one</code></td>
<td>
<p>logical, compute the ROC curve (and derived measures) 
comparing each row in <code>newdata</code> with each row in
<code>reference</code> (<code>FALSE</code>, the default),
or compare observations rowwise (<code>TRUE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments to the underlying methods for class
<code>mlt</code>, see <code>mlt-methods</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>coef</code> can be used to get (and set) model parameters, 
<code>logLik</code> evaluates the log-likelihood (also for
parameters other than the maximum likelihood estimate); 
<code>vcov</code> returns the estimated variance-covariance matrix (possibly
taking <code>cluster</code> into account) and 
and <code>estfun</code> gives the score contribution by each observation.
<code>predict</code> and <code>plot</code> can be used to inspect the model on
different scales.
</p>
<p><code>PI</code> computes the probabilistic index (or concordance probability or
AUC) for all observations in <code>newdata</code>, relative to <code>reference</code>,
ie the probability </p>
<p style="text-align: center;"><code class="reqn">P(Y_1 \le Y_0 \mid x_0, x_1)</code>
</p>

<p>of observing a smaller value of a randomly sampled observation conditional
on <code class="reqn">x_1</code> compared to a randomly sampled reference observation, which
is conditional on <code class="reqn">x_0</code>. This is equivalent to the area under the
receiver operating curve (ROC). The probability only applies within
strata, response-varying coefficients are not allowed.
</p>
<p>Under the same setup, <code>OVL</code> gives the overlap coefficient, which is
one minus the total variation and one minus half the <code class="reqn">L_1</code> distance
between the two conditional densities. The overlap coefficient is
identical to the Youden index and the Smirnov statistic. 
</p>
<p><code>PI</code> and friends also accept an argument <code>conf.level</code> which
triggers computation of simultaneous 
Wald confidence intervals for these measures.
Arguments in ... are forwarded to <code>glht</code>.
</p>


<h3>References</h3>

<p>Torsten Hothorn, Lisa Moest, Peter Buehlmann (2018), Most Likely
Transformations, <em>Scandinavian Journal of Statistics</em>, <b>45</b>(1),
110â€“134, <a href="https://doi.org/10.1111/sjos.12291">doi:10.1111/sjos.12291</a>.
</p>


<h3>See Also</h3>

<p><code>mlt-methods</code>,  <code>plot.ctm</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
    data("BostonHousing2", package = "mlbench")

    ### fit non-normal Box-Cox type linear model with two
    ### baseline functions (for houses near and off Charles River)
    BC_BH_2 &lt;- BoxCox(cmedv | 0 + chas ~ crim + zn + indus + nox + 
                      rm + age + dis + rad + tax + ptratio + b + lstat,
                      data = BostonHousing2)
    logLik(BC_BH_2)

    ### classical likelihood inference
    summary(BC_BH_2)

    ### coefficients of the linear predictor
    coef(BC_BH_2)

    ### plot linear predictor (mean of _transformed_ response) 
    ### vs. observed values
    plot(predict(BC_BH_2, type = "lp"), BostonHousing2$cmedv)

    ### all coefficients
    coef(BC_BH_2, with_baseline = TRUE)

    ### compute predicted median along with 10% and 90% quantile for the first
    ### observations
    predict(BC_BH_2, newdata = BostonHousing2[1:3,], type = "quantile",
            prob = c(.1, .5, .9))

    ### plot the predicted density for these observations
    plot(BC_BH_2, newdata = BostonHousing2[1:3, -1],
         which = "distribution", type = "density", K = 1000)

    ### evaluate the two baseline transformations, with confidence intervals
    nd &lt;- model.frame(BC_BH_2)[1:2, -1]
    nd$chas &lt;- factor(c("0", "1"))
    library("colorspace")
    col &lt;- diverge_hcl(2, h = c(246, 40), c = 96, l = c(65, 90))
    fill &lt;- diverge_hcl(2, h = c(246, 40), c = 96, l = c(65, 90), alpha = .3)
    plot(BC_BH_2, which = "baseline only", newdata = nd, col = col,
         confidence = "interval", fill = fill, lwd = 2,
         xlab = "Median Value", ylab = expression(h[Y]))
    legend("bottomright", lty = 1, col = col, 
            title = "Near Charles River", legend = c("no", "yes"), bty = "n")

    ### cars data; with quantile functions
    plot(dist ~ speed, data = cars)
    m &lt;- Colr(dist ~ speed, data = cars)
    q &lt;- predict(as.mlt(m), newdata = data.frame(speed = s &lt;- 6:25),
                 type = "quantile", prob = c(1, 5, 9) / 10)
    lines(s, q[1,])
    lines(s, q[2,])
    lines(s, q[3,])

    nd &lt;- data.frame(speed = s &lt;- as.double(1:5 * 5))
    
    # Prob(dist at speed s &gt; dist at speed 0)
    # speed 0 is reference, not a good choice here
    PI(m, newdata = nd)

    # Prob(dist at speed s &gt; dist at speed 15)
    lp15 &lt;- c(predict(m, newdata = data.frame(speed = 15)))
    PI(m, newdata = nd, reference = lp15)
    PI(m, newdata = nd, reference = nd[3,,drop = FALSE])

    # Prob(dist at speed s' &gt; dist at speed s)
    PI(m, newdata = nd, reference = nd)
    # essentially:
    lp &lt;- predict(m, newdata = nd)
    PI(object = dist(lp))
    # same, with simultaneous confidence intervals
    PI(m, newdata = nd, reference = nd, conf.level = .95)

    # plot ROC curves + confidence bands
    # compare speed 20 and 25 to speed 15
    plot(ROC(m, newdata = nd[4:5,,drop = FALSE],
             reference = nd[3,,drop = FALSE],
             conf.level = 0.95))

    # Overlap of conditional densities at speed s' and s
    OVL(m, newdata = nd, reference = nd)

    ### ROC analysis (takes too long for CRAN Windows)
    if (require("mlbench") &amp;&amp; .Platform$OS.type != "windows") {

        layout(matrix(1:4, nrow = 2))
        data("PimaIndiansDiabetes2", package = "mlbench")
        dia &lt;- sort(unique(PimaIndiansDiabetes2$diabetes))
        nd &lt;- data.frame(diabetes = dia, 
                         age = 29, mass = 32) ### median values

        ### unconditional ROC analysis: glucose tolerance test
        m0 &lt;- Colr(glucose ~ diabetes, data = PimaIndiansDiabetes2)
        # ROC curve + confidence band
        plot(ROC(m0, newdata = nd[2,,drop = FALSE], conf.level = .95)) 
        # Wald interval for AUC
        PI(m0, newdata = nd[2,,drop = FALSE], conf.level = .95)
        # score interval for AUC
        PI(-c(coef(m0), score_test(m0)$conf.int[2:1]))

        ### adjusted ROC analysis for age and mass
        m1 &lt;- Colr(glucose ~ diabetes + age + mass, data = PimaIndiansDiabetes2)
        # ROC curve + confidence band (this is the same for all ages /
        # masses)
        plot(ROC(m1, newdata = nd[2,,drop = FALSE], 
                     reference = nd[1,,drop = FALSE], 
                 conf.level = .95))
        # Wald interval for adjusted AUC
        PI(m1, newdata = nd[2,,drop = FALSE], reference = nd[1,,drop = FALSE], 
           conf.level = .95)
        # Score interval for adjusted AUC
        PI(-c(coef(m1)[1], score_test(m1, names(coef(m1))[1])$conf.int[2:1]))

        ### conditional ROC analysis: AUC regression ~ age + mass
        m2 &lt;- Colr(glucose ~ diabetes * (age + mass), data = PimaIndiansDiabetes2)
        # ROC curve for a person with age = 29 and mass = 32
        plot(ROC(m2, newdata = nd[2,,drop = FALSE], 
                     reference = nd[1,,drop = FALSE], 
                 conf.level = .95))
        # AUC for persons ages 21:81, all with mass = 32
        nd1 &lt;- data.frame(diabetes = nd[1,"diabetes"], age = 21:81, mass = 32)
        nd2 &lt;- data.frame(diabetes = nd[2,"diabetes"], age = 21:81, mass = 32)
        auc &lt;- PI(m2, newdata = nd2, reference = nd1, one2one = TRUE,
                  conf.level = 0.95)
        plot(nd1$age, auc[, "Estimate"], xlab = "Age (in years)", ylab =
             "AUC", ylim = c(0, 1), type = "l")
        lines(nd1$age, auc[, "lwr"], lty = 3)
        lines(nd1$age, auc[, "upr"], lty = 3)
    }
</code></pre>


</div>