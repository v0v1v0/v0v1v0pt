<div class="container">

<table style="width: 100%;"><tr>
<td>speedfilter</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Filter track data for speed</h2>

<h3>Description</h3>

<p>Create a filter of a track for "bad" points implying a speed of motion that
is unrealistic.
</p>


<h3>Usage</h3>

<pre><code class="language-R">speedfilter(x, max.speed = NULL, test = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>trip object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.speed</code></td>
<td>
<p>speed in kilometres (or other unit) per hour, the unit is kilometres
if the trip is in longitude latitude coordinates, or in the unit of the
projection projection (usually metres per hour)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>test</code></td>
<td>
<p>cut the algorithm short and just return first pass</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Using an algorithm (McConnnell et al., 1992), points are tested for speed
between previous / next and 2nd previous / next points.  Contiguous sections
with an root mean square speed above a given maximum have their highest rms
point removed, then rms is recalculated, until all points are below the
maximum.  By default an (internal) root mean square function is used, this
can be specified by the user.
</p>
<p>If the coordinates of the <code>trip</code> data are not projected, or NA the
distance calculation assumes longlat and kilometres (great circle). For
projected coordinates the speed must match the units of the coordinate
system.  (The PROJ.4 argument "units=km" is suggested).
</p>


<h3>Value</h3>

<p>Logical vector matching positions in the coordinate records that pass the
filter.
</p>


<h3>Warning</h3>

<p>This algorithm is destructive, and provides little information about
location uncertainty.  It is provided because it's commonly used
and provides an illustrative benchmark for further work.
</p>
<p>It is possible for the filter to become stuck in an infinite loop, depending
on the function passed to the filter.  Several minutes is probably too long
for hundreds of points, test on smaller sections if unsure.
</p>


<h3>Note</h3>

<p>This algorithm was originally taken from IDL code by David Watts at the
Australian Antarctic Division, and used in various other environments before
the development of this version.
</p>


<h3>Author(s)</h3>

<p>David Watts and Michael D. Sumner
</p>


<h3>References</h3>

<p>The algorithm comes from McConnell, B. J. and Chambers, C. and Fedak, M. A.
(1992) Foraging ecology of southern elephant seals in relation to the
bathymetry and productivity of the southern ocean.  Antarctic Science
<em>4</em> 393-398
</p>


<h3>See Also</h3>

<p><code>sda</code> for a fast distance angle filter to combine with speed filtering
</p>


</div>