<div class="container">

<table style="width: 100%;"><tr>
<td>optim_sgd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>SGD optimizer</h2>

<h3>Description</h3>

<p>Implements stochastic gradient descent (optionally with momentum).
Nesterov momentum is based on the formula from
On the importance of initialization and momentum in deep learning.
</p>


<h3>Usage</h3>

<pre><code class="language-R">optim_sgd(
  params,
  lr = optim_required(),
  momentum = 0,
  dampening = 0,
  weight_decay = 0,
  nesterov = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>params</code></td>
<td>
<p>(iterable): iterable of parameters to optimize or dicts defining
parameter groups</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lr</code></td>
<td>
<p>(float): learning rate</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>momentum</code></td>
<td>
<p>(float, optional): momentum factor (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dampening</code></td>
<td>
<p>(float, optional): dampening for momentum (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_decay</code></td>
<td>
<p>(float, optional): weight decay (L2 penalty) (default: 0)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nesterov</code></td>
<td>
<p>(bool, optional): enables Nesterov momentum (default: FALSE)</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The implementation of SGD with Momentum-Nesterov subtly differs from
Sutskever et. al. and implementations in some other frameworks.
</p>
<p>Considering the specific case of Momentum, the update can be written as
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{array}{ll}
v_{t+1} &amp; = \mu * v_{t} + g_{t+1}, \\
p_{t+1} &amp; = p_{t} - \mbox{lr} * v_{t+1},
\end{array}
</code>
</p>

<p>where <code class="reqn">p</code>, <code class="reqn">g</code>, <code class="reqn">v</code> and <code class="reqn">\mu</code> denote the
parameters, gradient, velocity, and momentum respectively.
</p>
<p>This is in contrast to Sutskever et. al. and
other frameworks which employ an update of the form
</p>
<p style="text-align: center;"><code class="reqn">
  \begin{array}{ll}
v_{t+1} &amp; = \mu * v_{t} + \mbox{lr} * g_{t+1}, \\
p_{t+1} &amp; = p_{t} - v_{t+1}.
\end{array}
</code>
</p>

<p>The Nesterov version is analogously modified.
</p>


<h3>Warning</h3>

<p>If you need to move a model to GPU via <code style="white-space: pre;">⁠$cuda()⁠</code>, please do so before
constructing optimizers for it. Parameters of a model after <code style="white-space: pre;">⁠$cuda()⁠</code>
will be different objects from those before the call. In general, you
should make sure that the objects pointed to by model parameters subject
to optimization remain the same over the whole lifecycle of optimizer
creation and usage.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
## Not run: 
optimizer &lt;- optim_sgd(model$parameters(), lr = 0.1, momentum = 0.9)
optimizer$zero_grad()
loss_fn(model(input), target)$backward()
optimizer$step()

## End(Not run)

}
</code></pre>


</div>