<div class="container">

<table style="width: 100%;"><tr>
<td>est.analysis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Estimation Errors and TPR/TNR</h2>

<h3>Description</h3>

<p>Compute estimation errors and TPR/TNR of optimization for sparse tensor graphical models
</p>


<h3>Usage</h3>

<pre><code class="language-R">est.analysis(Omega.hat.list, Omega.true.list, offdiag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>Omega.hat.list</code></td>
<td>
<p>list of estimation of precision matrices of tensor, i.e., <code>Omega.hat.list[[k]]</code> is estimation of precision matrix 
for the kth tensor mode, <code class="reqn">k \in \{1 , \ldots, K\}</code>. For example, output of <code>Tlasso.fit</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Omega.true.list</code></td>
<td>
<p>list of true precision matrices of tensor, i.e., <code>Omega.true.list[[k]]</code> is true precision matrix 
for the kth tensor mode, <code class="reqn">k \in \{1 , \ldots, K\}</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>offdiag</code></td>
<td>
<p>logical; indicate if excludes diagnoal when computing performance measures. 
If <code>offdiag = TRUE</code>, diagnoal in each matrix is ingored 
when comparing two matrices. Default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function computes performance measures of optimazation for sparse tensor graphical models. 
Errors are measured in Frobenius norm and Max norm. Model selection measures are TPR and TNR. All these measures are computed in each 
mode, average across all modes, and kronecker production of precision matrices.
</p>


<h3>Value</h3>

<p>A list, named <code>Out</code>, of following performance measures:
</p>

<table>
<tr>
<td style="text-align: left;">
<code>Out$error.kro</code>  </td>
<td style="text-align: left;">  error in Frobenius norm of kronecker product </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$tpr.kro</code>  </td>
<td style="text-align: left;">   TPR of kronecker product </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$tnr.kro</code>  </td>
<td style="text-align: left;">     TNR of kronecker product </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$av.error.f</code>  </td>
<td style="text-align: left;">  averaged Frobenius norm error across all modes </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$av.error.max</code>  </td>
<td style="text-align: left;">  averaged Max norm error across all modes </td>
</tr>
<tr>
<td style="text-align: left;"> 
<code>Out$av.tpr</code>  </td>
<td style="text-align: left;">  averaged TPR across all modes </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$av.tnr</code>  </td>
<td style="text-align: left;">  averaged TNR across all modes </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$error.f</code>  </td>
<td style="text-align: left;">  vector; error in Frobenius norm of each mode  </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$error.max</code>  </td>
<td style="text-align: left;">  vector; error in Max norm of each mode  </td>
</tr>
<tr>
<td style="text-align: left;"> 
<code>Out$tpr</code>  </td>
<td style="text-align: left;">  vector; TPR of each mode </td>
</tr>
<tr>
<td style="text-align: left;">
<code>Out$tnr</code>  </td>
<td style="text-align: left;">   vector; TNR of each mode   </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Xiang Lyu, Will Wei Sun, Zhaoran Wang, Han Liu, Jian Yang, Guang Cheng.
</p>


<h3>See Also</h3>

<p><code>Tlasso.fit</code>, <code>NeighborOmega</code>, <code>ChainOmega</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
m.vec = c(5,5,5)  # dimensionality of a tensor 
n = 5   # sample size 
k=1 # index of interested mode
Omega.true.list = list()
Omega.true.list[[1]] = ChainOmega(m.vec[1], sd = 1)
Omega.true.list[[2]] = ChainOmega(m.vec[2], sd = 2)
Omega.true.list[[3]] = ChainOmega(m.vec[3], sd = 3)
lambda.thm = 20*c( sqrt(log(m.vec[1])/(n*prod(m.vec))), 
                   sqrt(log(m.vec[2])/(n*prod(m.vec))), 
                   sqrt(log(m.vec[3])/(n*prod(m.vec))))
DATA=Trnorm(n,m.vec,type='Chain') 
# obersavations from tensor normal distribution
out.tlasso = Tlasso.fit(DATA,T=1,lambda.vec = lambda.thm)   
# output is a list of estimation of precision matrices
est.analysis(out.tlasso, Omega.true.list, offdiag=TRUE)
# generate a list of performance measures

</code></pre>


</div>