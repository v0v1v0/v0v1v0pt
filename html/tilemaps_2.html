<div class="container">

<table style="width: 100%;"><tr>
<td>generate_map</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generate a Single Tile Map</h2>

<h3>Description</h3>

<p>Generate a single square or hexagon tile map.
</p>


<h3>Usage</h3>

<pre><code class="language-R">generate_map(
  data,
  square = TRUE,
  flat_topped = FALSE,
  prop = 0,
  interpolate = 1,
  smoothness = 0,
  shift = c(0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>An object of class <code>sfc_MULTIPOLYGON</code> or
<code>sfc_POLYGON</code>, which contains the regions that make up the original
map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>square</code></td>
<td>
<p>logical. If <code>TRUE</code>, generates a square tile map. If
<code>FALSE</code>, generates a hexagon tile map.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>flat_topped</code></td>
<td>
<p>logical. If <code>TRUE</code>, hexagons are flat-topped. If
<code>FALSE</code>, hexagons are pointy-topped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prop</code></td>
<td>
<p>A proportion used in specifying the standard deviation of
the Gaussian noise added to original region centroids. The standard
deviation of the Gaussian noise is calculated as the mean distance between
a region centroid and its neighboring regions' centroids multiplied by the
value provided for the <code>prop</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>
<p>A number between 0 and 1 controlling the linear
interpolation between the noisy region centroids and fully-transformed
region centroids. If 0, noisy region centroids are used. If 1,
fully-transformed centroids are used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smoothness</code></td>
<td>
<p>numeric. Controls the bandwidth of the Gaussian kernel
used for smoothing the transformed boundary polygon. The bandwidth is
calculated as the mean distance between adjacent boundary points
multiplied by the value provided for the <code>smoothness</code> argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>shift</code></td>
<td>
<p>A numeric vector of length two specifying the number of grid
steps to shift the candidate tile map in the x and y directions before
counting the number of tile centroids that lie within the transformed
boundary.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Implements an algorithm for generating tile maps proposed in
<em>"Generating Tile Maps"</em> (McNeill and Hale 2017). The regions of the
map must be contiguous. Coordinates cannot be in terms of latitude and
longitude. Instead the coordinate reference system must be an appropriate
planar projection.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>sfc_POLYGON</code>, containing the tiles of
the tile map in the same order as the original regions given to the
function.
</p>


<h3>References</h3>

<p>McNeill, Graham, and Scott A Hale. 2017. “Generating Tile Maps.”
In <em>Computer Graphics Forum</em>, 36:435–45. 3. Wiley Online Library.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(sf)
northeast &lt;- governors[c(6,7,17,18,19,27,28,30,36,37,43),]
northeast$tile_map &lt;- generate_map(northeast$geometry, square = FALSE,
                                   flat_topped = TRUE)

</code></pre>


</div>