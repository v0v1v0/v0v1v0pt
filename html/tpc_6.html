<div class="container">

<table style="width: 100%;"><tr>
<td>MeekRules</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Last Step of tPC Algorithm: Apply Meek's rules</h2>

<h3>Description</h3>

<p>This is a modified version of <code>pcalg::udag2pdagRelaxed</code>.
It applies Meek's rules to the partially oriented graph obtained after orienting edges
between time points / tiers.
</p>


<h3>Usage</h3>

<pre><code class="language-R">MeekRules(
  gInput,
  verbose = FALSE,
  unfVect = NULL,
  solve.confl = FALSE,
  rules = rep(TRUE, 4)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>gInput</code></td>
<td>
<p>'pcAlgo'-object containing skeleton and conditional indepedence information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>FALSE: No output; TRUE: Details</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unfVect</code></td>
<td>
<p>Vector containing numbers that encode ambiguous triples (as returned by
[tpc_cons_intern()]. This is needed in the conservative and majority rule PC algorithms.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>solve.confl</code></td>
<td>
<p>If <code>TRUE</code>, the orientation rules work with lists for candidate
sets and allow bi-directed edges to resolve conflicting edge orientations. Note that
therefore the resulting object is order-independent but might not be a PDAG because
bi-directed edges can be present.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rules</code></td>
<td>
<p>A vector of length 4 containing <code>TRUE</code> or <code>FALSE</code> for each rule.
<code>TRUE</code> in position i means that rule i (Ri) will be applied. By default, all rules are used.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If <code>unfVect = NULL</code> (no ambiguous triples), the four orientation
rules are applied to each eligible structure until no more edges can be
oriented. Otherwise, unfVect contains the numbers of all ambiguous triples in
the graph as determined by [tpc_cons_intern()]. Then the orientation
rules take this information into account. For example, if <code>a -&gt; b - c</code> and <code>&lt;a,b,c&gt;</code>
is an unambigous triple and a non-v-structure, then rule 1 implies <code>b -&gt; c</code>. On
the other hand, if <code>a -&gt; b - c</code> but <code>&lt;a,b,c&gt;</code> is an ambiguous triple, then the edge
<code>b - c</code> is not oriented.
</p>
<p>If <code>solve.confl = FALSE</code>, earlier edge orientations are overwritten by
later ones.
</p>
<p>If <code>solv.confl = TRUE</code>, both the v-structures and the orientation rules
work with lists for the candidate edges and allow bi-directed edges if there are
conflicting orientations. For example, two v-structures <code>a -&gt; b &lt;- c</code> and
<code>b -&gt; c &lt;- d</code> then yield <code>a -&gt; b &lt;-&gt; c &lt;- d</code>. This option can be used to get an
order-independent version of the PC algorithm (see Colombo and Maathuis (2014)).
</p>
<p>We denote bi-directed edges, for example between two variables i and j, in the
adjacency matrix M of the graph as <code>M[i,j]=2</code> and <code>M[j,i]=2</code>. Such edges should be
interpreted as indications of conflicts in the algorithm, for example due to
errors in the conditional independence tests or violations of the faithfulness
assumption.
</p>


<h3>Value</h3>

<p>An object of class <code>pcAlgo-class</code>.
</p>


<h3>Author(s)</h3>

<p>Original code by Markus Kalisch, modifications by Janine Witte.
</p>


<h3>References</h3>

<p>C. Meek (1995). Causal inference and causal explanation with
background knowledge. In: Proceedings of the Eleventh Conference on Uncertainty
in Artificial Intelligence (UAI-95), pp. 403-411. Morgan Kaufmann Publishers.
</p>
<p>D. Colombo and M.H. Maathuis (2014). Order-independent constraint-based causal
structure learning. Journal of Machine Learning Research 15:3741-3782.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(dat_sim)
sk.fit &lt;- skeleton(suffStat = list(C = cor(dat_sim), n = nrow(dat_sim)),
             indepTest = gaussCItest, labels = names(dat_sim), alpha = 0.05)
MeekRules(sk.fit)

</code></pre>


</div>