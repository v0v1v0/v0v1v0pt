<div class="container">

<table style="width: 100%;"><tr>
<td>travel_times</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate shortest travel times from a stop to all reachable stops</h2>

<h3>Description</h3>

<p>Function to calculate the shortest travel times from a stop (given by <code>stop_name</code>)
to all other stop_names of a feed. <code>filtered_stop_times</code> needs to be created before with
<code>filter_stop_times()</code> or <code>filter_feed_by_date()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">travel_times(
  filtered_stop_times,
  stop_name,
  time_range = 3600,
  arrival = FALSE,
  max_transfers = NULL,
  max_departure_time = NULL,
  return_coords = FALSE,
  return_DT = FALSE,
  stop_dist_check = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>filtered_stop_times</code></td>
<td>
<p>stop_times data.table (with transfers and stops tables as
attributes) created with <code>filter_stop_times()</code> where the
departure or arrival time has been set.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop_name</code></td>
<td>
<p>Stop name for which travel times should be calculated. A vector with
multiple names can be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_range</code></td>
<td>
<p>Either a range in seconds or a vector containing the
minimal and maximal departure time (i.e. earliest and
latest possible journey departure time) as seconds or
"HH:MM:SS" character.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arrival</code></td>
<td>
<p>If FALSE (default), all journeys <em>start</em> from <code>stop_name</code>. If
TRUE, all journeys <em>end</em> at <code>stop_name</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_transfers</code></td>
<td>
<p>The maximimum number of transfers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_departure_time</code></td>
<td>
<p>Deprecated. Use <code>time_range</code> to set the latest
possible departure time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_coords</code></td>
<td>
<p>Returns stop coordinates (lon/lat) as columns. Default is FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>return_DT</code></td>
<td>
<p>travel_times() returns a data.table if TRUE. Default is FALSE which
returns a tibble/tbl_df.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stop_dist_check</code></td>
<td>
<p>stop_names are not structured identifiers like
stop_ids or parent_stations, so it's possible that
stops with the same name are far apart. travel_times()
errors if the distance among stop_ids with the same name is
above this threshold (in meters).
Use FALSE to turn check off. However, it is recommended to
either use <code>raptor()</code> or fix the feed (see <code>cluster_stops()</code>)
in case of warnings.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function allows easier access to <code>raptor()</code> by using stop names instead of ids and
returning shortest travel times by default.
</p>
<p>Note however that stop_name might not be a suitable identifier for a feed. It is possible
that multiple stops have the same name while not being related or geographically close to
each other. <code>stop_group_distances()</code> and <code>cluster_stops()</code> can help identify and fix
issues with stop_names.
</p>


<h3>Value</h3>

<p>A table with travel times to/from all stops reachable by <code>stop_name</code> and their
corresponding journey departure and arrival times.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(dplyr)

# 1) Calculate travel times from two closely related stops
# The example dataset gtfs_duke has missing times (allowed in gtfs) which is
# why we run interpolate_stop_times beforehand
gtfs = interpolate_stop_times(gtfs_duke)

tts1 = gtfs %&gt;%
  filter_feed_by_date("2019-08-26") %&gt;%
  travel_times(c("Campus Dr at Arts Annex (WB)", "Campus Dr at Arts Annex (EB)"),
               time_range = c("14:00:00", "15:30:00"))

# you can use either filter_feed_by_date or filter_stop_times to prepare the feed
# the result is the same
tts2 = gtfs %&gt;%
 filter_stop_times("2019-08-26", "14:00:00") %&gt;%
 travel_times(c("Campus Dr at Arts Annex (WB)", "Campus Dr at Arts Annex (EB)"),
              time_range = 1.5*3600) # 1.5h after 14:00

all(tts1 == tts2)
# It's recommended to store the filtered feed, since it can be time consuming to
# run it for every travel time calculation, see the next example steps

# 2) separate filtering and travel time calculation for a more granular analysis
# stop_names in this feed are not restricted to an area, create clusters of stops to fix
nyc_path &lt;- system.file("extdata", "google_transit_nyc_subway.zip", package = "tidytransit")
nyc &lt;- read_gtfs(nyc_path)
nyc &lt;- cluster_stops(nyc, group_col = "stop_name", cluster_colname = "stop_name")

# Use journeys departing after 7 AM with arrival time before 9 AM on 26th June
stop_times &lt;- filter_stop_times(nyc, "2018-06-26", 7*3600, 9*3600)

# Calculate travel times from "34 St - Herald Sq"
tts &lt;- travel_times(stop_times, "34 St - Herald Sq", return_coords = TRUE)

# only keep journeys under one hour for plotting
tts &lt;- tts %&gt;% filter(travel_time &lt;= 3600)

# travel time to Queensboro Plaza is 810 seconds, 13:30 minutes
tts %&gt;%
  filter(to_stop_name == "Queensboro Plaza") %&gt;%
  mutate(travel_time = hms::hms(travel_time))

# plot a simple map showing travel times to all reachable stops
# this can be expanded to isochron maps
library(ggplot2)
ggplot(tts) + geom_point(aes(x=to_stop_lon, y=to_stop_lat, color = travel_time))

</code></pre>


</div>