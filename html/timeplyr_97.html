<div class="container">

<table style="width: 100%;"><tr>
<td>time_elapsed</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast grouped time elapsed</h2>

<h3>Description</h3>

<p>Calculate how much time has passed
on a rolling or cumulative basis. <br></p>


<h3>Usage</h3>

<pre><code class="language-R">time_elapsed(
  x,
  time_by = NULL,
  g = NULL,
  time_type = getOption("timeplyr.time_type", "auto"),
  rolling = TRUE,
  fill = NA,
  na_skip = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Time variable. <br>
Can be a <code>Date</code>, <code>POSIXt</code>, <code>numeric</code>, <code>integer</code>, <code>yearmon</code>, or <code>yearqtr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_by</code></td>
<td>
<p>Must be one of the three:
</p>

<ul>
<li>
<p> string, specifying either the unit or the number and unit, e.g
<code>time_by = "days"</code> or <code>time_by = "2 weeks"</code>
</p>
</li>
<li>
<p> named list of length one, the unit being the name, and
the number the value of the list, e.g. <code>list("days" = 7)</code>.
For the vectorized time functions, you can supply multiple values,
e.g. <code>list("days" = 1:10)</code>.
</p>
</li>
<li>
<p> Numeric vector. If time_by is a numeric vector and x is not a date/datetime,
then arithmetic is used, e.g <code>time_by = 1</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>Object to be used for grouping <code>x</code>, passed onto <code>collapse::GRP()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time_type</code></td>
<td>
<p>Time type, either "auto", "duration" or "period".
With larger data, it is recommended to use <code>time_type = "duration"</code> for
speed and efficiency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rolling</code></td>
<td>
<p>If <code>TRUE</code> (the default) then lagged
time differences are calculated on a rolling basis,
essentially like <code>diff()</code>. <br>
If <code>FALSE</code> then time differences compared to the index (first) time
are calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill</code></td>
<td>
<p>When <code>rolling = TRUE</code>, this is the value that fills
the first elapsed time. The default is <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_skip</code></td>
<td>
<p>Should <code>NA</code> values be skipped? Default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>time_elapsed()</code> is quite efficient when there are many groups,
especially if your data is sorted in order of those groups.
In the case that <code>g</code> is supplied, it is most efficient when your data is
sorted by <code>g</code> .
When <code>na_skip</code> is <code>TRUE</code> and <code>rolling</code> is also <code>TRUE</code>, <code>NA</code> values are simply
skipped and hence the time differences between the current value and the
previous non-NA value are calculated. For example,
<code>c(3, 4, 6, NA, NA, 9)</code> becomes <code>c(NA, 1, 2, NA, NA, 3)</code>. <br>
When <code>na_skip</code> is <code>TRUE</code> and <code>rolling</code> is <code>FALSE</code>, time differences between
the current value and the first non-NA value of the series are calculated.
For example,
<code>c(NA, NA, 3, 4, 6, NA, 8)</code> becomes <code>c(NA, NA, 0, 1, 3, NA, 5)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(timeplyr)
library(dplyr)
library(lubridate)

x &lt;- time_seq(today(), length.out = 25, time_by = "3 days")
time_elapsed(x)
time_elapsed(x, rolling = FALSE, time_by = "day")

# Grouped example
set.seed(99)
# ~ 100k groups, 1m rows
x &lt;- sample(time_seq_v2(20, today(), "day"), 10^6, TRUE)
g &lt;- sample.int(10^5, 10^6, TRUE)

time_elapsed(x, time_by = "day", g = g)

</code></pre>


</div>