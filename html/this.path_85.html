<div class="container">

<table style="width: 100%;"><tr>
<td>this.path</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine Script's Filename</h2>

<h3>Description</h3>

<p><code>this.path()</code> returns the
<code>normalized</code> path of
the script in which it was written.
</p>
<p><code>this.dir()</code> returns the directory of <code>this.path()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">this.path(verbose = getOption("verbose"), original = FALSE,
          for.msg = FALSE, contents = FALSE, local = FALSE,
          n = 0, envir = parent.frame(n + 1),
          matchThisEnv = getOption("topLevelEnvironment"),
          srcfile = if (n) sys.parent(n) else 0,
          default, else.)

this.dir(verbose = getOption("verbose"), local = FALSE,
         n = 0, envir = parent.frame(n + 1),
         matchThisEnv = getOption("topLevelEnvironment"),
         srcfile = if (n) sys.parent(n) else 0,
         default, else.)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; should the method in which the
path was determined be printed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>original</code></td>
<td>
<p><code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>; should the original
or the normalized path be returned? <code>NA</code> means the normalized path
will be returned if it has already been forced, and the original path
otherwise.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>for.msg</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; do you want the path for the
purpose of printing a diagnostic message / / warning / / error? This will
return <code>NA_character_</code> in most cases where an error
would have been thrown.
</p>
<p><code>for.msg = TRUE</code> will ignore <code>original = FALSE</code>, and will use
<code>original = NA</code> instead.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contents</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; should the contents of the
script be returned instead?
</p>
<p>In ‘Jupyter’, a list of character vectors will be returned, the
contents separated into cells. Otherwise, a character vector will be
returned. If the executing script cannot be determined and <code>for.msg</code>
is <code>TRUE</code>, <code>NULL</code> will be returned.
</p>
<p>You could use
<code>as.character(unlist(this.path(contents = TRUE)))</code>
if you require a character vector.
</p>
<p>This is intended for logging purposes. This is useful in ‘Rgui’,
‘RStudio’, ‘VSCode’, and ‘Emacs’ when the source
document has contents but no path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>local</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; should the search for the executing
script be confined to the local environment in which
<code>set.sys.path()</code> was called?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of additional generations to go back. By default,
<code>this.path()</code> will look for a path based on the
<code>srcref</code> of the call
to <code>this.path()</code> and the environment in which <code>this.path()</code> was
called. This can be changed to be based on the <code>srcref</code> of the call
and the calling environment <code>n</code> generations up the stack. See section
<strong>Argument 'n'</strong> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir, matchThisEnv</code></td>
<td>
<p>arguments passed to
<code>topenv()</code> to determine the top level
environment in which to search for an associated path.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>srcfile</code></td>
<td>
<p>source file in which to search for a pathname, or an object
containing a source file. This includes a source reference, a call, an
expression object, or a closure.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>default</code></td>
<td>
<p>this value is returned if there is no executing script.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>else.</code></td>
<td>
<p>function to apply if there is an executing script. See
<code>tryCatch2()</code> for inspiration.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>this.path()</code> starts by examining argument <code>srcfile</code>. It looks at
the bindings <code>filename</code> and <code>wd</code> to determine the associated file
path. A source file of class <code>"srcfilecopy"</code> in which binding
<code>isFile</code> is <code>FALSE</code> will be ignored. A source file of class
<code>"srcfilealias"</code> will use the aliased <code>filename</code> in determining the
associated path. Filenames such as <code>""</code>, <code>"clipboard"</code>, and
<code>"stdin"</code> will be ignored since they do not refer to files.
</p>
<p>If it does not find a path associated with <code>srcfile</code>, it will next
examine arguments <code>envir</code> and <code>matchThisEnv</code>. Specifically, it
calculates <code>topenv(envir, matchThisEnv)</code> then
looks for an associated path. It will find a path associated with the top
level environment in two ways:
</p>

<ul>
<li>
<p>from a <a href="https://CRAN.R-project.org/package=box"><span class="pkg">package:box</span></a> module's namespace
</p>
</li>
<li>
<p>from an attribute <code>"path"</code>
</p>
</li>
</ul>
<p>If it does not find an associated path with <code>envir</code> and
<code>matchThisEnv</code>, it will next examine the call stack looking for a source
call; a call to one of these functions: </p>
<ul>
<li>
<p><code>source()</code> </p>
</li>
<li>
<p><code>sys.source()</code> </p>
</li>
<li>
<p><a href="https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE"><code>debugSource</code></a><code>()</code> in ‘<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>’ </p>
</li>
<li>
<p><code>compiler::loadcmp()</code> </p>
</li>
<li>
<p><code>utils::Sweave()</code> </p>
</li>
<li>
<p><code>box::use()</code> </p>
</li>
<li>
<p><code>knitr::knit()</code> </p>
</li>
<li>
<p><code>plumber::plumb()</code> </p>
</li>
<li>
<p><code>shiny::runApp()</code> </p>
</li>
<li>
<p><code>targets::tar_callr_inner_try()</code> <br><code>targets::tar_load_globals()</code> <br><code>targets::tar_source()</code> <br><code>targets::tar_workspace()</code> </p>
</li>
<li>
<p><code>testthat::source_file()</code></p>
</li>
</ul>
<p> If a source call is
found, the file argument is returned from the function's evaluation
environment. If you have your own <code>source()</code>-like function that you would
like to be recognized by <code>this.path()</code>, please use
<code>set.sys.path()</code> or contact the package maintainer so that it can
be implemented.
</p>
<p>If no source call is found up the calling stack, it will next examine the GUI
in use. If <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is running from:
</p>

<dl>
<dt>a shell, such as the Windows command-line / / Unix terminal</dt>
<dd>
<p>then the shell arguments are searched for <span class="option">-f</span> <span class="option">FILE</span> or
<span class="option">--file=FILE</span> (the two methods of taking input from <span class="option">FILE</span>)
(<span class="option">-f</span> <span class="option">-</span> and <span class="option">--file=-</span> are ignored). The last
<span class="option">FILE</span> is extracted and returned. If no arguments of either type
are supplied, an error is thrown.
</p>
<p>If <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is running from a shell under a Unix-alike with <span class="option">-g</span>
<span class="option">Tk</span> or <span class="option">--gui=Tk</span>, an error is thrown. ‘Tk’ does
not make use of its <span class="option">-f</span> <span class="option">FILE</span>, <span class="option">--file=FILE</span>
arguments.</p>
</dd>
<dt>‘Rgui’</dt>
<dd>
<p>then the source document's filename (the document most recently
interacted with) is returned (at the time of evaluation). Please note
that minimized documents <em>WILL</em> be included when looking for the
most recently used document. It is important to not leave the current
document (either by closing the document or interacting with another
document) while any calls to <code>this.path()</code> have yet to be evaluated
in the run selection. If no documents are open or the source document
does not exist (not saved anywhere), an error is thrown.</p>
</dd>
<dt>‘<a href="https://posit.co/products/open-source/rstudio/">RStudio</a>’</dt>
<dd>
<p>then the active document's filename (the document in which the cursor is
active) is returned (at the time of evaluation). If the active document
is the <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> console, the source document's filename (the document open in
the current tab) is returned (at the time of evaluation). Please note
that the source document will <em>NEVER</em> be a document open in another
window (with the <strong>Show in new window</strong> button). Please also note
that an active document open in another window can sometimes lose focus
and become inactive, thus returning the incorrect path. It is best
<strong>NOT</strong> to not run <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> code from a document open in another window.
It is important to not leave the current tab (either by closing or
switching tabs) while any calls to <code>this.path()</code> have yet to be
evaluated in the run selection. If no documents are open or the source
document does not exist (not saved anywhere), an error is thrown.</p>
</dd>
<dt>‘<a href="https://code.visualstudio.com/">VSCode</a>’</dt>
<dd>
<p>then the source document's filename is returned (at the time of
evaluation). It is important to not leave the current tab (either by
closing or switching tabs) while any calls to <code>this.path()</code> have yet
to be evaluated in the run selection. If no documents are open or the
source document does not exist (not saved anywhere), an error is thrown.</p>
</dd>
<dt>‘<a href="https://jupyter.org/">Jupyter</a>’</dt>
<dd>
<p>then the source document's filename is guessed by looking for <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>
notebooks in the initial working directory, then searching the contents
of those files for an expression matching the top-level expression.
Please be sure to save your notebook before using <code>this.path()</code>, or
explicitly use <code>set.jupyter.path()</code>.</p>
</dd>
<dt>‘<a href="https://ess.r-project.org/">Emacs</a>’</dt>
<dd>
<p>then the source document's filename is returned (at the time of
evaluation). ‘Emacs’ must be running as a server, either by
running <code>(server-start)</code> (consider adding to your ‘<span class="file">~/.emacs</span>’
file) or typing <code>M-x server-start</code>. It is important to not leave the
current window (either by closing or switching buffers) while any calls
to <code>this.path()</code> have yet to be evaluated in the run selection. If
multiple frames are active, <code>this.path()</code> will pick the first frame
containing the corresponding <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> session.
</p>
<p>If multiple ‘Emacs’ sessions are active, <code>this.path()</code> will
only work in the primary session due to limitations in
</p>
<p>‘emacsclient’.
If you want to run multiple <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> sessions, it is better to run one
‘Emacs’ session with multiple frames, one <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> session per frame.
Use <code>M-x make-frame</code> to make a new frame, or <code>C-x 5 f</code> to visit
a file in a new frame.
</p>
<p>Additionally, never use <code>C-c C-b</code> to send the current buffer to the
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> process. This copies the buffer contents to a new file which is then
<code>source()</code>-ed. The source references now point to the wrong file.
Instead, use <code>C-x h</code> to select the entire buffer then <code>C-c C-r</code>
to evaluate the selection.</p>
</dd>
<dt>‘AQUA’</dt>
<dd>
<p>then the executing script's path cannot be determined. Unlike
‘Rgui’, ‘RStudio’, ‘VSCode’, ‘Jupyter’, and
‘Emacs’, there is currently no way to request the path of an open
document. Until such a time that there is a method for requesting the
path of an open document, consider using another GUI.</p>
</dd>
</dl>
<p>If <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span> is running in another manner, an error is thrown.
</p>
<p>If your GUI of choice is not implemented with <code>this.path()</code>, please
contact the package maintainer so that it can be implemented.
</p>


<h3>Value</h3>

<p>character string.
</p>


<h3>Argument 'n'</h3>

<p>By default, <code>this.path()</code> will look for a path based on the
<code>srcref</code> of the call to <code>this.path()</code> and the environment in which
<code>this.path()</code> was called. For example: </p>
<pre>{
#line 1 "file1.R"
fun &lt;- function() this.path::this.path(original = TRUE)
fun()
}


{
#line 1 "file2.R"
fun()
}</pre>
<p>Both of these will return <code>"file1.R"</code> because that is where the call to
<code>this.path()</code> is written.
</p>
<p>But suppose we do not care to know where <code>this.path()</code> is called, but
instead want to know where <code>fun()</code> is called. Pass argument <code>n = 1</code>;
<code>this.path()</code> will inspect the call and the calling environment one
generation up the stack: </p>
<pre>{
#line 1 "file1.R"
fun &lt;- function() this.path::this.path(original = TRUE, n = 1)
fun()
}


{
#line 1 "file2.R"
fun()
}</pre>
<p>These will return <code>"file1.R"</code> and <code>"file2.R"</code>, respectively,
because those are where the calls to <code>fun()</code> are written.
</p>
<p>But now suppose we wish to make a second function that uses <code>fun()</code>. We
do not care to know where <code>fun()</code> is called, but instead want to know
where <code>fun2()</code> is called. Add a formal argument <code>n = 0</code> to each
function and pass <code>n = n + 1</code> to each sub-function: </p>
<pre>{
#line 1 "file1.R"
fun &lt;- function(n = 0) {
    this.path::this.path(original = TRUE, n = n + 1)
}
fun()
}


{
#line 1 "file2.R"
fun2 &lt;- function(n = 0) fun(n = n + 1)
list(fun = fun(), fun2 = fun2())
}


{
#line 1 "file3.R"
fun3 &lt;- function(n = 0) fun2(n = n + 1)
list(fun = fun(), fun2 = fun2(), fun3 = fun3())
}</pre>
<p>Within each file, all these functions will return the path in which they are
called, regardless of how deep <code>this.path()</code> is called.
</p>


<h3>Note</h3>

<p>If you need to use <code>this.path()</code> inside a user profile, please use
<code>with_init.file()</code>. i.e. instead of writing:
</p>
<pre>&lt;expr 1&gt;
&lt;expr 2&gt;
&lt;...&gt;</pre>
<p>write this: </p>
<pre>this.path::with_init.file({
&lt;expr 1&gt;
&lt;expr 2&gt;
&lt;...&gt;
})</pre>


<h3>See Also</h3>

<p><code>shFILE()</code>
</p>
<p><code>set.sys.path()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">FILE1.R &lt;- tempfile(fileext = ".R")
writeLines("writeLines(sQuote(this.path::this.path()))", FILE1.R)

## 'this.path()' works with 'source()'
source(FILE1.R)

## 'this.path()' works with 'sys.source()'
sys.source(FILE1.R, envir = environment())

## 'this.path()' works with 'debugSource()' in 'RStudio'
if (.Platform$GUI == "RStudio")
    get("debugSource", "tools:rstudio", inherits = FALSE)(FILE1.R)

## 'this.path()' works with 'testthat::source_file()'
if (requireNamespace("testthat"))
    testthat::source_file(FILE1.R, chdir = FALSE, wrap = FALSE)

## 'this.path()' works with 'compiler::loadcmp()'
if (requireNamespace("compiler")) {
    FILE2.Rc &lt;- tempfile(fileext = ".Rc")
    compiler::cmpfile(FILE1.R, FILE2.Rc)
    compiler::loadcmp(FILE2.Rc)
    unlink(FILE2.Rc)
}

## 'this.path()' works with 'Rscript'
this.path:::.Rscript(c("--default-packages=NULL", "--vanilla", FILE1.R))

## 'this.path()' also works when 'source()'-ing a URL
## (included tryCatch in case an internet connection is not available)
tryCatch({
    source(paste0("https://raw.githubusercontent.com/ArcadeAntics/",
                  "this.path/main/tests/sys-path-with-urls.R"))
}, condition = this.path:::.cat_condition)

unlink(FILE1.R)
</code></pre>


</div>