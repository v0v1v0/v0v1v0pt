<div class="container">

<table style="width: 100%;"><tr>
<td>msda</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Fits a regularization path of Sparse Discriminant Analysis and predicts</h2>

<h3>Description</h3>

<p>Fits a regularization path of Sparse Discriminant Analysis at a sequence of regularization parameters lambda. Performs prediction when testing data is provided. The <code>msda</code> function solves classification problem by fitting a sparse discriminant analysis model. When covariates are provided, the function will first make adjustment on the training data. It provides three models: <code>binary</code> for fitting DSDA model to solve binary classification problems, <code>multi.original</code> and <code>multi.modified</code> for fitting MSDA model to solve multi-class classification problems. <code>multi.original</code> runs faster for small dimension case but the computation ability is limited to a relatively large dimension. <code>multi.modified</code> has no such limitation and works in ultra-high dimensions. User can specify method by argument or use the default settings.
</p>


<h3>Usage</h3>

<pre><code class="language-R">msda(x, z=NULL, y, testx=NULL,testz=NULL, model = NULL, lambda = NULL, 
 standardize=FALSE, alpha=1, nlambda = 100, 
 lambda.factor = ifelse((nobs - nclass)&lt;= nvars, 0.2, 1e-03), dfmax = nobs, 
 pmax = min(dfmax * 2 + 20, nvars), pf = rep(1, nvars), eps = 1e-04, 
 maxit = 1e+06, sml = 1e-06, verbose = FALSE, perturb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input matrix of predictors. <code>x</code> is of dimension <code class="reqn">N \times p</code>; each row is an observation vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>Input covariate matrix of dimension <code class="reqn">N \times q</code>, where <code class="reqn">q&lt;N</code>. <code>z</code> can be omitted if covariate is absent. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Class labl. This argument should be a factor for classification. For <code>model</code>=<code>'binary'</code>, <code>y</code> should be a binary variable with values 1 and 2. For <code>model</code>=<code>'multi.original'</code> or <code>'multi.modified'</code>, <code>y</code> should be a multi-class variable starting from 1.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testx</code></td>
<td>
<p>Input testing matrix. Each row is a test case. When <code>testx</code> is not provided, the function will only fit the model and return the classifier. When <code>testx</code> is provided, the function will predict response on <code>testx</code> as well.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>testz</code></td>
<td>
<p>Input testing covariate matrix. Can be omitted if covariate is absent. However, training covariates <code>z</code> and testing covariates <code>testz</code> must be provided or not at the same time.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>Method type. The <code>model</code> argument can be one of <code>'binary'</code>, <code>'multi.original'</code>, <code>'multi.modified'</code> and the default is NULL. The function supports fitting DSDA and MSDA models by specifying method type. Without specification, the function will automatically choose one of the methods. If the response variable is binary, the function will fit a DSDA model. If the response variable is multi-class, the function will fit an original MSDA model for dimension <code class="reqn">p&lt;=2000</code> and a modified MSDA model for dimension <code class="reqn">p&gt;2000</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>

<p>A user supplied <code>lambda</code> sequence. Typically, by leaving this option unspecified users can have the program compute its own <code>lambda</code> sequence based on
<code>nlambda</code> and <code>lambda.factor</code>. Supplying a value of
<code>lambda</code> overrides this. It is better to supply
a decreasing sequence of <code>lambda</code> values than a single (small) value, if not, the program will sort user-defined <code>lambda</code> sequence in decreasing order automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standardize</code></td>
<td>
<p>A logic object indicating whether x should be standardized before performing DSDA. Default is FALSE. This argument is only valid for <code>model = 'binary'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The elasticnet mixing parameter, the same as in glmnet. Default is alpha=1 so that the lasso penalty is used in DSDA. This argument is only valid for <code>model = 'binary'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlambda</code></td>
<td>
<p>The number of tuning values in sequence <code>lambda</code>. If users do not specify <code>lambda</code> values, the package will generate a solution path containing <code>nlambda</code> many tuning values of <code>lambda</code>. Default is 100 for <code>model = 'multi.original'</code> and 50 for <code>model = 'multi.modified'</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.factor</code></td>
<td>

<p>The factor for getting the minimal lambda in <code>lambda</code> sequence, where <code>min(lambda)</code> = <code>lambda.factor</code> * <code>max(lambda)</code>.  <code>max(lambda)</code> is the smallest value of <code>lambda</code> for which all coefficients are zero. The default depends on <code class="reqn">p</code> (the number of predictors) and its relationship with <code class="reqn">N</code> (the number of rows in the matrix of predictors). 
For Original MSDA, if <code class="reqn">N &gt; p</code>, the default is <code>0.0001</code>, close to zero.  If <code class="reqn">N&lt;p</code>, the default is <code>0.2</code>. For Modified MSDA, if <code class="reqn">p\le 5000</code>, the default is <code>0.2</code>. If <code class="reqn">5000&lt;p\le 30000</code>, the default is <code>0.4</code>. If <code class="reqn">p&gt;30000</code>, the default is <code>0.5</code>.
A very small value of <code>lambda.factor</code> will lead to a saturated fit. It takes no effect if there is user-defined <code>lambda</code> sequence. This argument is only valid for <code>multi.original</code> and <code>multi.modified</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dfmax</code></td>
<td>

<p>The maximum number of selected variables in the model. Default is the number of observations <code>N</code>. This argument is only valid for <code>multi.original</code> and <code>multi.modified</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmax</code></td>
<td>

<p>The maximum number of potential selected variables during iteration. In middle step, the algorithm can select at most <code>pmax</code> variables and then shrink part of them such that the nubmer of final selected variables is less than <code>dfmax</code>. Default is <code class="reqn">\min(dfmax\times 2+20, N)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pf</code></td>
<td>

<p>L1 penalty factor of length <code class="reqn">p</code>. Separate L1 penalty weights can be applied to each coefficient of <code class="reqn">\theta</code> to allow
differential L1 shrinkage. Can be 0 for some variables, which implies
no L1 shrinkage, and results in that variable always being included in the
model. Default is 1 for all variables (and implicitly infinity for
variables listed in <code>exclude</code>). This argument is only valid for <code>multi.original</code> and <code>multi.modified</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>

<p>Convergence threshold for coordinate descent. Each inner
coordinate descent loop continues until the relative change in any
coefficient. Defaults value is <code>1e-4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxit</code></td>
<td>

<p>Maximum number of outer-loop iterations allowed at fixed lambda value. Default is 1e6. If models do not converge, consider increasing <code>maxit</code>. This argument is only valid for <code>multi.original</code> and <code>multi.modified</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sml</code></td>
<td>

<p>Threshold for ratio of loss function change after each iteration to old loss function value. Default is <code>1e-06</code>. This argument is only valid for <code>multi.original</code> and <code>multi.modified</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>

<p>Whether to print out computation progress. The default is <code>FALSE</code>. This argument is only valid for <code>multi.original</code> and <code>multi.modified</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>perturb</code></td>
<td>
<p>A scalar number. If it is specified, the number will be added to each diagonal element of the covariance matrix as perturbation. The default is <code>NULL</code>. This argument is only valid for <code>multi.original</code> and <code>multi.modified</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>msda</code> function fits a linear discriminant analysis model for vector <code class="reqn">X</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{X}|Y=k\sim N(\boldsymbol{\mu}_k,\boldsymbol{\Sigma}).</code>
</p>

<p>The categorical response is predicted from the Bayes rule:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Y}=\arg\max_{k=1,\cdots,K}{(\mathbf{X}-\frac{\boldsymbol{\mu}_k}{2})^T\boldsymbol{\beta}_k+\log\pi_k}.</code>
</p>

<p>The parameter <code>model</code> specifies which method to use in estimating <code class="reqn">\boldsymbol{\beta}</code>. Users can use <code>binary</code> for binary problems and <code>binary</code> and <code>multi.modified</code> for multi-class problems. In <code>multi.original</code>, the algorithm first computes and stores <code class="reqn">\boldsymbol{\Sigma}</code>, while it doesn't compute or store the entire covariance matrix in <code>multi.modified</code>. Since the algorithm is element-wise based, <code>multi.modified</code> computes each element of covariance matrix when needed. Therefore, <code>multi.original</code> is faster for low dimension but <code>multi.modified</code> can fit model for a much higher dimension case.
</p>
<p>Note that for computing speed reason, if models are not converging or running slow, consider increasing <code>eps</code> and <code>sml</code>, or decreasing
<code>nlambda</code>, or increasing <code>lambda.factor</code> before increasing
<code>maxit</code>. Users can also reduce <code>dfmax</code> to limit the maximum number of variables in the model.
</p>
<p>The arguments list out all parameters in the three models, but not all of them are necessary in applying one of the methods. See the specific explaination of each argument for more detail. Meanwhile, the output of DSDA model only includes <code>beta</code> and <code>lambda</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>dsda</code> or <code>msda.original</code> and <code>msda.modified</code>.
</p>
<table>
<tr style="vertical-align: top;">
<td><code>beta</code></td>
<td>
<p>Output variable coefficients for each <code>lambda</code>, which is the estimation of <code class="reqn">\boldsymbol{\beta}</code> in the Bayes rule. <code>beta</code> is a list of length being the number of <code>lambda</code>s. Each element of <code>beta</code> is a matrix of dimension <code class="reqn">nvars\times (nclass-1)</code>. For <code>model = 'dsda'</code>, <code>beta</code> is a vector of length <code class="reqn">nvars+1</code>, where the first element is intercept.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>obj</code></td>
<td>
<p>The fitted value of the objective function for each value of <code>lambda</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dim</code></td>
<td>
<p>Dimension of each coefficient matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>The actual <code>lambda</code> sequence used. The user specified sequence or automatically generated sequence could be truncated by constraints on <code>dfmax</code> and <code>pmax</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The input matrix of predictors for training.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Class label in training data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>npasses</code></td>
<td>
<p>Total number of iterations (the most inner loop) summed over all lambda values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors, 0 if no error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigma</code></td>
<td>
<p>Estimated sigma matrix. This argument is only available in object <code>msda.original</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>delta</code></td>
<td>
<p>Estimated delta matrix. delta[k] = mu[k]-mu[1].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mu</code></td>
<td>
<p>Estimated mu vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prior</code></td>
<td>
<p>Prior probability that y belong to class k, estimated by mean(y that belong to k).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>call</code></td>
<td>
<p>The call that produced this object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pred</code></td>
<td>
<p>Predicted categorical response for each value in sequence <code>lambda</code> when <code>testx</code> is provided.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Yuqing Pan, Qing Mai, Xin Zhang
</p>


<h3>References</h3>

<p>Mai, Q., Zou, H. and Yuan, M. (2012), "A direct approach to sparse discriminant analysis in ultra-high dimensions." Biometrica, 99, 29-42.
</p>
<p>Mai, Q., Yang, Y., and Zou, H. (2017), "Multiclass sparse discriminant analysis." Statistica Sinica, in press.
</p>
<p>URL: <a href="https://github.com/emeryyi/msda">https://github.com/emeryyi/msda</a><br></p>


<h3>See Also</h3>

<p><code>cv.msda</code>, <code>predict.msda</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(GDS1615)
x&lt;-GDS1615$x
y&lt;-GDS1615$y
obj &lt;- msda(x = x, y = y)
</code></pre>


</div>