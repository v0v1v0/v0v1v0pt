<div class="container">

<table style="width: 100%;"><tr>
<td>PyH</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast persistent homology calculations with python.</h2>

<h3>Description</h3>

<p>This function is a wrapper of the python wrapper of the ripser engine for persistent cohomology, 
but is still faster than using the R package TDAstats (see the TDApplied package vignette for details).
</p>


<h3>Usage</h3>

<pre><code class="language-R">PyH(
  X,
  maxdim = 1,
  thresh,
  distance_mat = FALSE,
  ripser,
  ignore_infinite_cluster = TRUE,
  calculate_representatives = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>either a matrix or dataframe, representing either point cloud data or a distance matrix. In either case there
must be at least two rows and 1 column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxdim</code></td>
<td>
<p>the non-negative integer maximum dimension for persistent homology, default 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thresh</code></td>
<td>
<p>the non-negative numeric radius threshold for the Vietoris-Rips filtration.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distance_mat</code></td>
<td>
<p>a boolean representing whether the input X is a distance matrix or not, default FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ripser</code></td>
<td>
<p>the ripser python module.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore_infinite_cluster</code></td>
<td>
<p>a boolean representing whether to remove clusters (0 dimensional cycles) which
die at the threshold value. Default is TRUE as this is the default for TDAstats homology calculations, but can be set to
FALSE which is the default for python ripser.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>calculate_representatives</code></td>
<td>
<p>a boolean representing whether to return a list of representative cocycles for the
topological features found in the persistence diagram, default FALSE.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If 'distance_mat' is 'TRUE' then 'X' must be a square matrix. The 'ripser' parameter should be the
result of an 'import_ripser' function call, but since that function is slow the ripser object should
be explicitly created before a PyH function call (see examples). Cohomology is computed over Z2,
as is the case for the TDAstats function <code>calculate_homology</code> (this is also the
default for ripser in c++). If representative cocycles are returned, then they are stored in a list with
one element for each point in the persistence diagram, ignoring dimension 0 points. Each representative of
a dimension d cocycle (1 for loops, 2 for voids, etc.) is a kxd dimension matrix/array containing the row number-labelled
edges, triangles etc. in the cocycle.
</p>


<h3>Value</h3>

<p>Either a dataframe containing the persistence diagram if 'calculate_representatives' is 'FALSE' (the default), otherwise a list with two elements: 
diagram of class diagram, containing the persistence diagram,
and representatives, a list containing the edges, triangles etc. contained in each representative cocycle.
</p>


<h3>Author(s)</h3>

<p>Shael Brown - <a href="mailto:shaelebrown@gmail.com">shaelebrown@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# create sample data
df &lt;- data.frame(x = 1:10,y = 1:10)

# import the ripser module
ripser &lt;- import_ripser()

# calculate persistence diagram up to dimension 1 with a maximum
# radius of 5
phom &lt;- PyH(X = df,thresh = 5,ripser = ripser)

## End(Not run)
</code></pre>


</div>