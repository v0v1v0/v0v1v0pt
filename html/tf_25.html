<div class="container">

<table style="width: 100%;"><tr>
<td>fpc_wsvd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Eigenfunctions via weighted, regularized SVD</h2>

<h3>Description</h3>

<p>Compute (truncated) orthonormal eigenfunctions and scores
for (partially missing) data on a common (potentially non-equidistant) grid.
</p>


<h3>Usage</h3>

<pre><code class="language-R">fpc_wsvd(data, arg, pve = 0.995)

## S3 method for class 'matrix'
fpc_wsvd(data, arg, pve = 0.995)

## S3 method for class 'data.frame'
fpc_wsvd(data, arg, pve = 0.995)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>numeric matrix of function evaluations
(each row is one curve, no NAs)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arg</code></td>
<td>
<p>numeric vector of argument values</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pve</code></td>
<td>
<p>percentage of variance explained</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Performs a weighted SVD with trapezoidal quadrature weights s.t. returned
vectors represent (evaluations of)
orthonormal eigen<em>functions</em> <code class="reqn">\phi_j(t)</code>, not eigen<em>vectors</em>
<code class="reqn">\phi_j = (\phi_j(t_1), \dots, \phi_j(t_n))</code>, specifically:<br><code class="reqn">\int_T \phi_j(t)^2 dt \approx \sum_i \Delta_i \phi_j(t_i)^2 = 1</code>
given quadrature weights <code class="reqn">\Delta_i</code>, not
<code class="reqn">\phi_j'\phi_j = \sum_i \phi_j(t_i)^2 = 1</code>;<br><code class="reqn">\int_T \phi_j(t) \phi_k(t) dt = 0</code> not
<code class="reqn">\phi_j'\phi_k = \sum_i \phi_j(t_i)\phi_k(t_i) = 0</code>,
c.f. <code>mogsa::wsvd()</code>.<br>
For incomplete data, this uses an adaptation of <code>softImpute::softImpute()</code>,
see references. Note that will not work well for data on a common grid if more
than a few percent of data points are missing, and it breaks down completely
for truly irregular data with no/few common timepoints, even if observed very
densely. For such data, either re-evaluate on a common grid first or use more
advanced FPCA approaches like <code>refund::fpca_sc()</code>,
see last example for <code>tfb_fpc()</code>
</p>


<h3>Value</h3>

<p>a list with entries
</p>

<ul>
<li> <p><code>mu</code> estimated mean function (numeric vector)
</p>
</li>
<li> <p><code>efunctions</code> estimated FPCs (numeric matrix, columns represent FPCs)
</p>
</li>
<li> <p><code>scores</code> estimated FPC scores (one row per observed curve)
</p>
</li>
<li> <p><code>npc</code> how many FPCs were returned for the given <code>pve</code> (integer)
</p>
</li>
<li> <p><code>scoring_function</code> a function that returns FPC scores for new data
and given eigenfunctions, see <code>tf:::.fpc_wsvd_scores</code> for an example.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Trevor Hastie, Rahul Mazumder, Cheng Meng, Fabian Scheipl
</p>


<h3>References</h3>

<p>code adapted from / inspired by <code>mogsa::wsvd()</code> by Cheng Meng
and <code>softImpute::softImpute()</code> by Trevor Hastie and Rahul Mazumder.<br>
Meng C (2023).
<em><code>mogsa</code>: Multiple omics data integrative clustering and gene set analysis</em>.
<a href="https://bioconductor.org/packages/mogsa">https://bioconductor.org/packages/mogsa</a>.<br>
Mazumder, Rahul, Hastie, Trevor, Tibshirani, Robert (2010).
“Spectral regularization algorithms for learning large incomplete matrices.”
<em>The Journal of Machine Learning Research</em>, <b>11</b>, 2287-2322.<br>
Hastie T, Mazumder R (2021).
<em><code>softImpute</code>: Matrix Completion via Iterative Soft-Thresholded SVD</em>.
R package version 1.4-1, <a href="https://CRAN.R-project.org/package=softImpute">https://CRAN.R-project.org/package=softImpute</a>.
</p>


<h3>See Also</h3>

<p>Other tfb-class: 
<code>tfb</code>,
<code>tfb_fpc()</code>,
<code>tfb_spline()</code>
</p>
<p>Other tfb_fpc-class: 
<code>tfb_fpc()</code>
</p>


</div>