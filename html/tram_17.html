<div class="container">

<table style="width: 100%;"><tr>
<td>Mmlt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Multivariate Conditional Transformation Models
</h2>

<h3>Description</h3>

<p>Conditional transformation models for multivariate continuous, discrete,
or a mix of continuous and discrete outcomes
</p>


<h3>Usage</h3>

<pre><code class="language-R">Mmlt(..., formula = ~ 1, data, conditional = FALSE, theta = NULL, fixed = NULL,
     scale = FALSE, optim = mltoptim(auglag = list(maxtry = 5)), 
     args = list(seed = 1, type = c("MC", "ghalton"), M = 1000), 
     fit = c("jointML", "pseudo", "ACS", "sequential", "none"),
             ACSiter = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>marginal transformation models, one for each response, for
<code>Mmlt</code>. Additional arguments for the methods.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a model formula describing a model for the dependency
structure via the lambda parameters. The default is set to <code>~ 1</code> for constant lambdas.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data.frame.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conditional</code></td>
<td>
<p>logical; parameters are defined conditionally (only
possible when all models are probit models). This is the default as
described by Klein et al. (2022). If <code>FALSE</code>, parameters can be
directly interpreted marginally, this is explained in Section 2.6 by Klein
et al. (2022). Using <code>conditional = FALSE</code> with probit-only models
gives the same likelihood but different parameter estimates.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>an optional vector of starting values.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fixed</code></td>
<td>
<p>an optional named numeric vector of predefined parameter values
or a logical (for <code>coef</code>) indicating to also return fixed parameters
(only when <code>type = "all"</code>).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>a logical indicating if (internal) scaling shall be applied
to the model coefficients.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optim</code></td>
<td>
<p>a list of optimisers as returned by <code>mltoptim</code>
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>args</code></td>
<td>
<p>a list of arguments for <code>lpmvnorm</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fit</code></td>
<td>
<p>character vector describing how to fit the model. The default
is joint likelihood estimation of all parameters, <code>pseudo</code> fixes the
marginal parameters, <code>sequential</code> starts with a univariate model and
sequentially adds models, keeping the parameters of previously added models
fit. <code>ACS</code> implements Alternate Convex Search, starting with
<code>pseudo</code> and, in a second step, fixing the marginal parameters. This is
iterated for <code>ACSiter</code> iterations.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ACSiter</code></td>
<td>
<p>number of iterations for <code>fit = "ACS"</code>.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function implements multivariate conditional transformation models
as described by Klein et al (2020). 
Below is a simple example for an unconditional bivariate distribution.
See <code>demo("undernutrition", package = "tram")</code> for a conditional
three-variate example.
</p>


<h3>Value</h3>

<p>An object of class <code>Mmlt</code> with <code>coef</code> and <code>predict</code>
methods.
</p>


<h3>References</h3>

<p>Nadja Klein, Torsten Hothorn, Luisa Barbanti, Thomas Kneib (2022),
Multivariate Conditional Transformation Models. <em>Scandinavian Journal
of Statistics</em>, <b>49</b>, 116â€“142, <a href="https://doi.org/10.1111/sjos.12501">doi:10.1111/sjos.12501</a>.
</p>
<p>Torsten Hothorn (2024), On Nonparanormal Likelihoods. <a href="https://doi.org/10.48550/arXiv.2408.17346">doi:10.48550/arXiv.2408.17346</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
  data("cars")

  ### fit unconditional bivariate distribution of speed and distance to stop
  ## fit unconditional marginal transformation models
  m_speed &lt;- BoxCox(speed ~ 1, data = cars, support = ss &lt;- c(4, 25), 
                    add = c(-5, 5))
  m_dist &lt;- BoxCox(dist ~ 1, data = cars, support = sd &lt;- c(0, 120), 
                   add = c(-5, 5))

  ## fit multivariate unconditional transformation model
  m_speed_dist &lt;- Mmlt(m_speed, m_dist, formula = ~ 1, data = cars)

  ## log-likelihood
  logLik(m_speed_dist)
  sum(predict(m_speed_dist, newdata = cars, type = "density", log = TRUE))

  ## Wald test of independence of speed and dist (the "dist.speed.(Intercept)"
  ## coefficient)
  summary(m_speed_dist)

  ## LR test comparing to independence model
  LR &lt;- 2 * (logLik(m_speed_dist) - logLik(m_speed) - logLik(m_dist))
  pchisq(LR, df = 1, lower.tail = FALSE)

  ## constrain lambda to zero and fit independence model
  ## =&gt; log-likelihood is the sum of the marginal log-likelihoods
  mI &lt;- Mmlt(m_speed, m_dist, formula = ~1, data = cars, 
             fixed = c("dist.speed.(Intercept)" = 0))
  logLik(m_speed) + logLik(m_dist)
  logLik(mI)

  ## linear correlation, ie Pearson correlation of speed and dist after
  ## transformation to bivariate normality
  (r &lt;- coef(m_speed_dist, type = "Corr"))
  
  ## Spearman's rho (rank correlation) of speed and dist on original scale
  (rs &lt;- coef(m_speed_dist, type = "Spearman"))

  ## evaluate joint and marginal densities (needs to be more user-friendly)
  nd &lt;- expand.grid(c(nd_s &lt;- mkgrid(m_speed, 100), nd_d &lt;- mkgrid(m_dist, 100)))
  nd$d &lt;- predict(m_speed_dist, newdata = nd, type = "density")

  ## compute marginal densities
  nd_s &lt;- as.data.frame(nd_s)
  nd_s$d &lt;- predict(m_speed_dist, newdata = nd_s, margins = 1L,
                    type = "density")
  nd_d &lt;- as.data.frame(nd_d)
  nd_d$d &lt;- predict(m_speed_dist, newdata = nd_d, margins = 2L, 
                    type = "density")

  ## plot bivariate and marginal distribution
  col1 &lt;- rgb(.1, .1, .1, .9)
  col2 &lt;- rgb(.1, .1, .1, .5)
  w &lt;- c(.8, .2)
  layout(matrix(c(2, 1, 4, 3), nrow = 2), width = w, height = rev(w))
  par(mai = c(1, 1, 0, 0) * par("mai"))
  sp &lt;- unique(nd$speed)
  di &lt;- unique(nd$dist)
  d &lt;- matrix(nd$d, nrow = length(sp))
  contour(sp, di, d, xlab = "Speed (in mph)", ylab = "Distance (in ft)", xlim = ss, ylim = sd,
          col = col1)
  points(cars$speed, cars$dist, pch = 19, col = col2)
  mai &lt;- par("mai")
  par(mai = c(0, 1, 0, 1) * mai)
  plot(d ~ speed, data = nd_s, xlim = ss, type = "n", axes = FALSE, 
       xlab = "", ylab = "")
  polygon(nd_s$speed, nd_s$d, col = col2, border = FALSE)
  par(mai = c(1, 0, 1, 0) * mai)
  plot(dist ~ d, data = nd_d, ylim = sd, type = "n", axes = FALSE, 
       xlab = "", ylab = "")
  polygon(nd_d$d, nd_d$dist, col = col2, border = FALSE)

  ### NOTE: marginal densities are NOT normal, nor is the joint
  ### distribution. The non-normal shape comes from the data-driven 
  ### transformation of both variables to joint normality in this model.

</code></pre>


</div>