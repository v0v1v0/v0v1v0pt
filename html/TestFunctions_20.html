<div class="container">

<table style="width: 100%;"><tr>
<td>bananagramacy2Dexp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>bananagramacy2Dexp: bananagramacy2Dexp function
6 dimensional function.
First two dimensions are banana function,
next two are the gramacy2Dexp function,
last two are null dimensions</h2>

<h3>Description</h3>

<p>branin: A function.
2 dimensional function.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bananagramacy2Dexp(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

bananatimesgramacy2Dexp(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

gramacy2Dexp(x, scale_it = T, scale_low = -2, scale_high = 6, noise = 0, ...)

gramacy2Dexp3hole(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

gramacy6D(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

branin(
  x,
  scale_it = T,
  scale_low = c(-5, 0),
  scale_high = c(10, 15),
  noise = 0
)

borehole(
  x,
  scale_it = T,
  scale_low = c(0.05, 100, 63070, 990, 63.1, 700, 1120, 9855),
  scale_high = c(0.15, 50000, 115600, 1110, 116, 820, 1680, 12045),
  noise = 0
)

franke(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

zhou1998(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

currin1991(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

currin1991b(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

limpoly(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

limnonpoly(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

banana(
  x,
  scale_it = T,
  scale_low = c(-20, -10),
  scale_high = c(20, 5),
  noise = 0
)

banana_grad(
  x,
  scale_it = T,
  scale_low = c(-20, -10),
  scale_high = c(20, 5),
  noise = 0
)

gaussian1(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

sinumoid(x, scale_it = F, scale_low = c(0, 0), scale_high = c(1, 1), noise = 0)

waterfall(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0
)

sqrtsin(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0,
  freq = 2 * pi
)

powsin(
  x,
  scale_it = F,
  scale_low = c(0, 0),
  scale_high = c(1, 1),
  noise = 0,
  freq = 2 * pi,
  pow = 0.7
)

OTL_Circuit(
  x,
  scale_it = T,
  scale_low = c(50, 25, 0.5, 1.2, 0.25, 50),
  scale_high = c(150, 70, 3, 2.5, 1.2, 300),
  noise = 0
)

GoldsteinPrice(
  x,
  scale_it = T,
  scale_low = c(-2, -2),
  scale_high = c(2, 2),
  noise = 0
)

GoldsteinPriceLog(
  x,
  scale_it = T,
  scale_low = c(-2, -2),
  scale_high = c(2, 2),
  noise = 0
)

ackley(
  x,
  scale_it = T,
  scale_low = -32.768,
  scale_high = 32.768,
  noise = 0,
  a = 20,
  b = 0.2,
  c = 2 * pi
)

piston(
  x,
  scale_it = T,
  scale_low = c(30, 0.005, 0.002, 1000, 90000, 290, 340),
  scale_high = c(60, 0.02, 0.01, 5000, 110000, 296, 360),
  noise = 0
)

wingweight(
  x,
  scale_it = T,
  scale_low = c(150, 220, 6, -10, 16, 0.5, 0.08, 2.5, 1700, 0.025),
  scale_high = c(200, 300, 10, 10, 45, 1, 0.18, 6, 2500, 0.08),
  noise = 0
)

welch(x, scale_it = T, scale_low = c(-0.5), scale_high = c(0.5), noise = 0)

robotarm(
  x,
  scale_it = T,
  scale_low = rep(0, 8),
  scale_high = c(rep(2 * pi, 4), rep(1, 4)),
  noise = 0
)

RoosArnold(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0)

Gfunction(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0, ...)

beale(x, scale_it = T, scale_low = -4.5, scale_high = 4.5, noise = 0, ...)

easom(x, scale_it = T, scale_low = -4.5, scale_high = 4.5, noise = 0, ...)

griewank(x, scale_it = T, scale_low = -600, scale_high = 600, noise = 0, ...)

hump(x, scale_it = T, scale_low = -5, scale_high = 5, noise = 0, ...)

levy(x, scale_it = T, scale_low = -10, scale_high = 10, noise = 0, ...)

levytilt(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

michalewicz(x, scale_it = T, scale_low = 0, scale_high = pi, noise = 0, ...)

rastrigin(
  x,
  scale_it = T,
  scale_low = -5.12,
  scale_high = 5.12,
  noise = 0,
  ...
)

moon_high(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0, ...)

linkletter_nosignal(
  x,
  scale_it = F,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

morris(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

detpep8d(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

hartmann(x, scale_it = F, scale_low = 0, scale_high = 1, noise = 0, ...)

quad_peaks(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

quad_peaks_slant(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

SWNExpCos(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

logistic(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

logistic15(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

logistic_plateau(
  x,
  scale_it = T,
  scale_low = 0,
  scale_high = 1,
  noise = 0,
  ...
)

vertigrad(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

vertigrad_grad(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

beambending(
  x,
  scale_it = T,
  scale_low = c(10, 1, 0.1),
  scale_high = c(20, 2, 0.2),
  noise = 0,
  ...
)

chengsandu(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

steelcolumnstress(
  x,
  scale_it = T,
  scale_low = c(330, 4e+05, 420000, 420000, 200, 10, 100, 10, 12600),
  scale_high = c(470, 6e+05, 780000, 780000, 400, 30, 500, 50, 29400),
  noise = 0,
  ...
)

winkel(x, scale_it = T, scale_low = 0, scale_high = 1, noise = 0, ...)

boreholeMV(
  x,
  NOD = 51,
  scale_it = T,
  scale_low = c(0.05, 100, 63070, 990, 63.1, 700, 1120, 9855),
  scale_high = c(0.15, 50000, 115600, 1110, 116, 820, 1680, 12045),
  noise = 0
)

test_func_apply(func, x, scale_it, scale_low, scale_high, noise = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Input value, either a matrix whose rows are points or
a vector for a single point. Be careful with 1-D functions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_it</code></td>
<td>
<p>Should the data be scaled from [0, 1]^D to
[scale_low, scale_high]? This means the input data is confined
to be in [0, 1]^D, but the function isn't.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_low</code></td>
<td>
<p>Lower bound for each variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale_high</code></td>
<td>
<p>Upper bound for each variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>noise</code></td>
<td>
<p>If white noise should be added, specify the
standard deviation for normal noise</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional parameters for func</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>freq</code></td>
<td>
<p>Wave frequency for sqrtsin and powsin</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pow</code></td>
<td>
<p>Power for powsin</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>A constant for ackley()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>A constant for ackley()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p>A constant for ackley()</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NOD</code></td>
<td>
<p>number of output dimensions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>func</code></td>
<td>
<p>A function to evaluate</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Function values at x
</p>


<h3>References</h3>

<p>Gramacy, Robert B., and Herbert KH Lee.
"Adaptive design and analysis of supercomputer experiments."
Technometrics 51.2 (2009): 130-145.
</p>
<p>Gramacy, Robert B., and Herbert KH Lee.
"Adaptive design and analysis of supercomputer experiments."
Technometrics 51.2 (2009): 130-145.
</p>
<p>Gramacy, Robert B., and Herbert KH Lee.
"Adaptive design and analysis of supercomputer experiments."
Technometrics 51.2 (2009): 130-145.
</p>
<p>Dixon, L. C. W. (1978). The global optimization problem: an introduction. Towards Global Optimiation 2, 1-15.
</p>
<p>Morris, M. D., Mitchell, T. J., &amp; Ylvisaker, D. (1993). Bayesian design and analysis of computer experiments: use of derivatives in surface prediction. Technometrics, 35(3), 243-255.
</p>
<p>Worley, Brian A. Deterministic uncertainty analysis. No. ORNL-6428. Oak Ridge National Lab., TN (USA), 1987.
</p>
<p>Franke, R. (1979). A critical comparison of some methods for interpolation of scattered data. Monterey, California: Naval Postgraduate School. Page 13.
</p>
<p>An, J., &amp; Owen, A. (2001). Quasi-regression. Journal of complexity, 17(4), 588-607.
</p>
<p>Currin, C., Mitchell, T., Morris, M., &amp; Ylvisaker, D. (1991). Bayesian prediction of deterministic functions, with applications to the design and analysis of computer experiments. Journal of the American Statistical Association, 86(416), 953-963.
</p>
<p>Currin, C., Mitchell, T., Morris, M., &amp; Ylvisaker, D. (1991). Bayesian prediction of deterministic functions, with applications to the design and analysis of computer experiments. Journal of the American Statistical Association, 86(416), 953-963.
</p>
<p>Lim, Yong B., Jerome Sacks, W. J. Studden, and William J. Welch.
"Design and analysis of computer experiments when the output is highly
correlated over the input space."
Canadian Journal of Statistics 30, no. 1 (2002): 109-126.
</p>
<p>Lim, Yong B., Jerome Sacks, W. J. Studden, and William J. Welch.
"Design and analysis of computer experiments when the output is highly
correlated over the input space."
Canadian Journal of Statistics 30, no. 1 (2002): 109-126.
</p>
<p>Haario, H., Saksman, E., &amp; Tamminen, J. (1999). Adaptive proposal distribution for random walk Metropolis algorithm. Computational Statistics, 14(3), 375-396.
</p>
<p>Joseph, V. R., Dasgupta, T., Tuo, R., &amp; Wu, C. J. (2015). Sequential exploration of complex surfaces using minimum energy designs. Technometrics, 57(1), 64-74.
</p>
<p>Ben-Ari, Einat Neumann, and David M. Steinberg. "Modeling data
from computer experiments: an empirical comparison of kriging with MARS and
projection pursuit regression." Quality Engineering 19.4 (2007): 327-338.
</p>
<p>Kenett, Ron S., Shelemyahu Zacks, and Daniele Amberti.
Modern Industrial Statistics: with applications in R,
MINITAB and JMP. John Wiley &amp; Sons, 2013.
</p>
<p>Forrester, A., &amp; Keane, A. (2008). Engineering design via surrogate modelling: a practical guide. John Wiley &amp; Sons.
</p>
<p>http://www.abe.ufl.edu/jjones/ABE_5646/2010/Morris.1991
</p>
<p>http://www.tandfonline.com/doi/pdf/10.1198/TECH.2010.09157?needAccess=true
</p>
<p>Santner, T. J., Williams, B. J., &amp; Notz, W. (2003). The Design and Analysis of Computer Experiments. Springer Science &amp; Business Media.
</p>
<p>Cheng, Haiyan, and Adrian Sandu. "Collocation least-squares polynomial chaos method." In Proceedings of the 2010 Spring Simulation Multiconference, p. 80. Society for Computer Simulation International, 2010.
</p>
<p>Kuschel, Norbert, and Rudiger Rackwitz. "Two basic problems in reliability-based structural optimization." Mathematical Methods of Operations Research 46, no. 3 (1997): 309-333.
</p>
<p>Prikhodko, Pavel, and Nikita Kotlyarov. "Calibration of Sobol indices estimates in case of noisy output." arXiv preprint arXiv:1804.00766 (2018).
</p>
<p>Winkel, Munir A., Jonathan W. Stallings, Curt B. Storlie, and
Brian J. Reich. "Sequential Optimization in Locally Important Dimensions."
arXiv preprint arXiv:1804.10671 (2018).
</p>
<p>Morris, M. D., Mitchell, T. J., &amp; Ylvisaker, D. (1993). Bayesian design and analysis of computer experiments: use of derivatives in surface prediction. Technometrics, 35(3), 243-255.
</p>
<p>Worley, Brian A. Deterministic uncertainty analysis. No. ORNL-6428. Oak Ridge National Lab., TN (USA), 1987.
</p>


<h3>Examples</h3>

<pre><code class="language-R">bananagramacy2Dexp(runif(6))
bananagramacy2Dexp(matrix(runif(6*20),ncol=6))
bananatimesgramacy2Dexp(runif(6))
bananatimesgramacy2Dexp(matrix(runif(6*20),ncol=6))
gramacy2Dexp(runif(2))
gramacy2Dexp(matrix(runif(2*20),ncol=2))
gramacy2Dexp3hole(runif(2))
gramacy2Dexp3hole(matrix(runif(2*20),ncol=2))
gramacy6D(runif(6))
gramacy6D(matrix(runif(6*20),ncol=6))
branin(runif(2))
branin(matrix(runif(20), ncol=2))
borehole(runif(8))
borehole(matrix(runif(80), ncol=8))
franke(runif(2))
zhou1998(runif(2))
currin1991(runif(2))
currin1991b(runif(2))
limpoly(runif(2))
limnonpoly(runif(2))
banana(runif(2))
x &lt;- y &lt;- seq(0, 1, len=100)
z &lt;- outer(x, y, Vectorize(function(a, b){banana(c(a, b))}))
contour(x, y, z)
banana_grad(runif(2))
x &lt;- y &lt;- seq(0, 1, len=100)
z &lt;- outer(x, y, Vectorize(function(a, b){sum(banana_grad(c(a, b))^2)}))
contour(x, y, z)
gaussian1(runif(2))
sinumoid(runif(2))
x &lt;- y &lt;- seq(0, 1, len=100)
z &lt;- outer(x, y, Vectorize(function(a, b){sinumoid(c(a, b))}))
contour(x, y, z)
waterfall(runif(2))
sqrtsin(runif(1))
curve(sqrtsin(matrix(x,ncol=1)))
powsin(runif(1))#,pow=2)
OTL_Circuit(runif(6))
OTL_Circuit(matrix(runif(60),ncol=6))
GoldsteinPrice(runif(2))
GoldsteinPrice(matrix(runif(60),ncol=2))
GoldsteinPriceLog(runif(2))
GoldsteinPriceLog(matrix(runif(60),ncol=2))
ackley(runif(2))
ackley(matrix(runif(60),ncol=2))
piston(runif(7))
piston(matrix(runif(7*20),ncol=7))
wingweight(runif(10))
wingweight(matrix(runif(10*20),ncol=10))
welch(runif(20))
welch(matrix(runif(20*20),ncol=20))
robotarm(runif(8))
robotarm(matrix(runif(8*20),ncol=8))
RoosArnold(runif(8))
RoosArnold(matrix(runif(8*20),ncol=8))
Gfunction(runif(8))
Gfunction(matrix(runif(8*20),ncol=8))
beale(runif(2))
beale(matrix(runif(2*20),ncol=2))
easom(runif(2))
easom(matrix(runif(2*20),ncol=2))
griewank(runif(2))
griewank(matrix(runif(2*20),ncol=2))
hump(runif(2))
hump(matrix(runif(2*20),ncol=2))
levy(runif(2))
levy(matrix(runif(2*20),ncol=2))
levytilt(runif(2))
levytilt(matrix(runif(2*20),ncol=2))
michalewicz(runif(2))
michalewicz(matrix(runif(2*20),ncol=2))
rastrigin(runif(2))
rastrigin(matrix(runif(2*20),ncol=2))
moon_high(runif(20))
moon_high(matrix(runif(20*20),ncol=20))
linkletter_nosignal(runif(2))
linkletter_nosignal(matrix(runif(2*20),ncol=2))
morris(runif(20))
morris(matrix(runif(20*20),ncol=20))
detpep8d(runif(2))
detpep8d(matrix(runif(2*20),ncol=2))
hartmann(runif(2))
hartmann(matrix(runif(6*20),ncol=6))
quad_peaks(runif(2))
quad_peaks(matrix(runif(2*20),ncol=2))
quad_peaks_slant(runif(2))
quad_peaks_slant(matrix(runif(2*20),ncol=2))
SWNExpCos(runif(2))
SWNExpCos(matrix(runif(2*20),ncol=2))
curve(logistic, from=-5,to=5)
curve(logistic(x,offset=.5, scl=15))
logistic(matrix(runif(20),ncol=1))
curve(logistic15)
curve(logistic15(x,offset=.25))
logistic15(matrix(runif(20),ncol=1))
curve(logistic_plateau(matrix(x,ncol=1)))
logistic_plateau(matrix(runif(20),ncol=1))
vertigrad(runif(2))
vertigrad(matrix(runif(2*20),ncol=2))
vertigrad_grad(runif(2))
vertigrad_grad(matrix(runif(2*20),ncol=2))
beambending(runif(3))
beambending(matrix(runif(3*20),ncol=3))
chengsandu(runif(2))
chengsandu(matrix(runif(2*20),ncol=2))
steelcolumnstress(runif(8))
steelcolumnstress(matrix(runif(8*20),ncol=8))
winkel(runif(2))
winkel(matrix(runif(2*20),ncol=2))
boreholeMV(runif(8))
boreholeMV(matrix(runif(80), ncol=8))
x &lt;- matrix(seq(0,1,length.out=10), ncol=1)
y &lt;- test_func_apply(sin, x, TRUE, 0, 2*pi, .05)
plot(x,y)
curve(sin(2*pi*x), col=2, add=TRUE)
</code></pre>


</div>