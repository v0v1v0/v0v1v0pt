<div class="container">

<table style="width: 100%;"><tr>
<td>bsmote</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>borderline-SMOTE Algorithm</h2>

<h3>Description</h3>

<p>BSMOTE generates generate new examples of the minority class using nearest
neighbors of these cases in the border region between classes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">bsmote(df, var, k = 5, over_ratio = 1, all_neighbors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>data.frame or tibble. Must have 1 factor variable and remaining
numeric variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>var</code></td>
<td>
<p>Character, name of variable containing factor variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
majority-to-minority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_neighbors</code></td>
<td>
<p>Type of two borderline-SMOTE method. Defaults to FALSE.
See details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This methods works the same way as <code>smote()</code>, expect that instead of
generating points around every point of of the minority class each point is
first being classified into the boxes "danger" and "not". For each point the
k nearest neighbors is calculated. If all the neighbors comes from a
different class it is labeled noise and put in to the "not" box. If more then
half of the neighbors comes from a different class it is labeled "danger.
</p>
<p>If <code>all_neighbors = FALSE</code> then points will be generated between nearest
neighbors in its own class. If <code>all_neighbors = TRUE</code> then points will be
generated between any nearest neighbors. See examples for visualization.
</p>
<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
</p>
<p>All columns used in this step must be numeric with no missing data.
</p>


<h3>Value</h3>

<p>A data.frame or tibble, depending on type of <code>df</code>.
</p>


<h3>References</h3>

<p>Hui Han, Wen-Yuan Wang, and Bing-Huan Mao. Borderline-smote:
a new over-sampling method in imbalanced data sets learning. In
International Conference on Intelligent Computing, pages 878â€“887. Springer,
2005.
</p>


<h3>See Also</h3>

<p><code>step_bsmote()</code> for step function of this method
</p>
<p>Other Direct Implementations: 
<code>adasyn()</code>,
<code>nearmiss()</code>,
<code>smotenc()</code>,
<code>smote()</code>,
<code>tomek()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">circle_numeric &lt;- circle_example[, c("x", "y", "class")]

res &lt;- bsmote(circle_numeric, var = "class")

res &lt;- bsmote(circle_numeric, var = "class", k = 10)

res &lt;- bsmote(circle_numeric, var = "class", over_ratio = 0.8)

res &lt;- bsmote(circle_numeric, var = "class", all_neighbors = TRUE)
</code></pre>


</div>