<div class="container">

<table style="width: 100%;"><tr>
<td>Tlasso.fit</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Non-Convex Optimization for Sparse Tensor Graphical Models</h2>

<h3>Description</h3>

<p>An alternating optimization algorithm for estimation of precision matrices of sparse tensor graphical models. See <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Tlasso.fit(data, T = 1, lambda.vec = NULL, norm.type = 2, thres = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>tensor object stored in a m1 * m2 * ... * mK * n array, where n is sample size
and mk is dimension of the kth tensor mode.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>T</code></td>
<td>
<p>number of maximal iteration, default is 1. Each iteration involves update on all modes. 
If output change less than <code>thres</code> after certain iteration, in terms of summation on Frobenius norm, this function will be terminated (before Tth iteration).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda.vec</code></td>
<td>
<p>vector of tuning parameters (<code class="reqn">\lambda_1</code>,...,<code class="reqn">\lambda_K</code>). Defalut is NULL, s.t. it is tuned via <code>HUGE</code> package directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>norm.type</code></td>
<td>
<p>normalization method of precision matrix, i.e., <code class="reqn">\Omega_{11} = 1</code> 
if norm.type = 1 and <code class="reqn">\|\Omega\|_{F}=1</code> if norm.type = 2. Default value is 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thres</code></td>
<td>
<p>thresholding value that terminates algorithm before Tth iteration if output change less than <code>thres</code> after certain iteration, in terms of summation over Frobenius norm. 
If <code>thres</code> is negative or zero, this algorithm will iterate T times.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function conducts an alternating optimization algorithm to sparse tensor graphical model. The output is optimal consistent even when <code>T=1</code>, see <a href="https://arxiv.org/abs/1609.04522">Lyu et al. (2019)</a> for details.
There are two ternimation criteria, <code>T</code> and <code>thres</code>. Algorithm will be terminated if output in certain iteration change less than <code>thres</code>. Otherwise, T iterations will be fully operated.
</p>


<h3>Value</h3>

<p>A length-K list of estimation of precision matrices.
</p>


<h3>Author(s)</h3>

<p>Xiang Lyu, Will Wei Sun, Zhaoran Wang, Han Liu, Jian Yang, Guang Cheng.
</p>


<h3>See Also</h3>

<p><code>varcor</code>, <code>biascor</code>, <code>huge</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
m.vec = c(5,5,5)  # dimensionality of a tensor 
n = 5   # sample size 
lambda.thm = 20*c( sqrt(log(m.vec[1])/(n*prod(m.vec))), 
                  sqrt(log(m.vec[2])/(n*prod(m.vec))), 
                  sqrt(log(m.vec[3])/(n*prod(m.vec))))
DATA=Trnorm(n,m.vec,type='Chain') 
# obersavations from tensor normal distribution
out.tlasso = Tlasso.fit(DATA,T=10,lambda.vec = lambda.thm,thres=10)   
# terminate by thres
out.tlasso = Tlasso.fit(DATA,T=3,lambda.vec = lambda.thm,thres=0)   
# thres=0, iterate 10 times


</code></pre>


</div>