<div class="container">

<table style="width: 100%;"><tr>
<td>roll_na_fill</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Fast grouped "locf" <code>NA</code> fill</h2>

<h3>Description</h3>

<p>A fast and efficient by-group method for
"last-observation-carried-forward" <code>NA</code> filling.
</p>


<h3>Usage</h3>

<pre><code class="language-R">roll_na_fill(x, g = NULL, fill_limit = Inf)

.roll_na_fill(x, fill_limit = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>An object use for grouping x
This may be a vector or data frame for example.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill_limit</code></td>
<td>
<p>(Optional) maximum number of consecutive NAs to fill
per <code>NA</code> cluster. Default is <code>Inf</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>



<h4>Method</h4>

<p>When supplying groups using <code>g</code>, this method uses <code>radixorder(g)</code> to
specify how to loop through <code>x</code>, making this extremely efficient.
</p>
<p>When <code>x</code> contains zero or all <code>NA</code> values, then <code>x</code> is returned with no copy
made.
</p>
<p><code>.roll_na_fill()</code> is the same as <code>roll_na_fill()</code> but without a g argument and
it performs no sanity checks. It is passed straight to c++ which makes it efficient for
loops.
</p>



<h3>Value</h3>

<p>A filled vector of <code>x</code> the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(timeplyr)
library(dplyr)
library(data.table)

words &lt;- do.call(paste0,
                 do.call(expand.grid, rep(list(letters), 3)))
groups &lt;- sample(words, size = 10^5, replace = TRUE)
x &lt;- sample.int(10^2, 10^5, TRUE)
x[sample.int(10^5, 10^4)] &lt;- NA

dt &lt;- data.table(x, groups)

filled &lt;- roll_na_fill(x, groups)

library(zoo)

  # Summary
# Latest version of vctrs with their vec_fill_missing
# Is the fastest but not most memory efficient
# For low repetitions and large vectors, data.table is best

# For large numbers of repetitions (groups) and data
# that is sorted by groups
# timeplyr is fastest

# No groups
bench::mark(e1 = dt[, filled1 := timeplyr::roll_na_fill(x)][]$filled1,
            e2 = dt[, filled2 := data.table::nafill(x, type = "locf")][]$filled2,
            e3 = dt[, filled3 := vctrs::vec_fill_missing(x)][]$filled3,
            e4 = dt[, filled4 := zoo::na.locf0(x)][]$filled4,
            e5 = dt[, filled5 := timeplyr::.roll_na_fill(x)][]$filled5)
# With group
bench::mark(e1 = dt[, filled1 := timeplyr::roll_na_fill(x, groups)][]$filled1,
            e2 = dt[, filled2 := data.table::nafill(x, type = "locf"), by = groups][]$filled2,
            e3 = dt[, filled3 := vctrs::vec_fill_missing(x), by = groups][]$filled3,
            e4 = dt[, filled4 := timeplyr::.roll_na_fill(x), by = groups][]$filled4)
# Data sorted by groups
setkey(dt, groups)
bench::mark(e1 = dt[, filled1 := timeplyr::roll_na_fill(x, groups)][]$filled1,
            e2 = dt[, filled2 := data.table::nafill(x, type = "locf"), by = groups][]$filled2,
            e3 = dt[, filled3 := vctrs::vec_fill_missing(x), by = groups][]$filled3,
            e4 = dt[, filled4 := timeplyr::.roll_na_fill(x), by = groups][]$filled4)


</code></pre>


</div>