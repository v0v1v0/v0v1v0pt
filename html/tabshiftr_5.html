<div class="container">

<table style="width: 100%;"><tr>
<td>.find</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Determine row or column on the fly</h2>

<h3>Description</h3>

<p>Find the location of a variable not based on it's columns/rows, but based on
a regular expression or function
</p>


<h3>Usage</h3>

<pre><code class="language-R">.find(
  fun = NULL,
  pattern = NULL,
  col = NULL,
  row = NULL,
  invert = FALSE,
  relative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p>[<code>character(1)</code>]<br> function to identify columns or rows in
the input table on the fly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pattern</code></td>
<td>
<p>[<code>character(1)</code>]<br> character string containing a regular
expression to identify columns or rows in the input table on the fly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col</code></td>
<td>
<p>[<code>integerish(1)</code>]<br> optionally, in case this function should
only be applied to certain columns, provides this here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row</code></td>
<td>
<p>[<code>integerish(1)</code>]<br> optionally, in case this function should
only be applied to certain rows, provides this here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>invert</code></td>
<td>
<p>[<code>logical(1)</code>]<br> whether or not the identified columns or
rows should be inverted, i.e., all other columns or rows should be
selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>relative</code></td>
<td>
<p>[<code>logical(1)</code>]<br> whether or not the values provided in
<code>col</code> or <code>row</code> are relative to the cluster position(s) or whether
they are absolute positions, i.e, refer to the overall table.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This functions is basically a wild-card for when columns or rows are
not known ad-hoc, but have to be assigned on the fly. This can be very
helpful when several tables contain the same variables, but the arrangement
may be slightly different.
</p>


<h3>Value</h3>

<p>the index values where the target was found.
</p>


<h3>How does this work</h3>

<p>The first step in using any schema is validating
it via the function <code>validateSchema</code>. This happens by default
in <code>reorganise</code>, but can also be done manually, for example
when debugging complicated schema descriptions.
</p>
<p>In case that function encounters a schema that wants to find columns or
rows on the fly via <code>.find</code>, it combines all cells of columns and all
cells of rows into one character string and matches the regular expression
or function on those. Columns/rows that have a match are returned as the
respective column/row value.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># use regular expressions to find cell positions
(input &lt;- tabs2shift$clusters_messy)

schema &lt;- setCluster(id = "territories",
                     left = .find(pattern = "comm*"), top = .find(pattern = "comm*")) %&gt;%
  setIDVar(name = "territories", columns = c(1, 1, 4), rows = c(2, 9, 9)) %&gt;%
  setIDVar(name = "year", columns = 4, rows = c(3:6), distinct = TRUE) %&gt;%
  setIDVar(name = "commodities", columns = c(1, 1, 4)) %&gt;%
  setObsVar(name = "harvested", columns = c(2, 2, 5)) %&gt;%
  setObsVar(name = "production", columns = c(3, 3, 6))

schema
validateSchema(schema = schema, input = input)

# use a function to find rows
(input &lt;- tabs2shift$messy_rows)

schema &lt;-
  setFilter(rows = .find(fun = is.numeric, col = 1, invert = TRUE)) %&gt;%
  setIDVar(name = "territories", columns = 1) %&gt;%
  setIDVar(name = "year", columns = 2) %&gt;%
  setIDVar(name = "commodities", columns = 3) %&gt;%
  setObsVar(name = "harvested", columns = 5) %&gt;%
  setObsVar(name = "production", columns = 6)

reorganise(schema = schema, input = input)
</code></pre>


</div>