<div class="container">

<table style="width: 100%;"><tr>
<td>diag.panel.splom.density</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Diagonal Density Panels</h2>

<h3>Description</h3>

<p>Plots univariate density estimates estimates to be used in a
<code>lattice::splom()</code> call with the <code>diag.panel</code> argument.
</p>


<h3>Usage</h3>

<pre><code class="language-R">diag.panel.splom.density(
  x,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  weights = NULL,
  n = 512,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>data vector corresponding to that row / column (which will be the
same for diagonal 'panels').</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>
<p>the smoothing bandwidth to be used.  The kernels are scaled
such that this is the standard deviation of the smoothing kernel.
(Note this differs from the reference books cited below, and from S-PLUS.)
</p>
<p><code>bw</code> can also be a character string giving a rule to choose the
bandwidth.  See <code>bw.nrd</code>. <br> The default,
<code>"nrd0"</code>, has remained the default for historical and
compatibility reasons, rather than as a general recommendation,
where e.g., <code>"SJ"</code> would rather fit, see also Venables and
Ripley (2002).
</p>
<p>The specified (or computed) value of <code>bw</code> is multiplied by
<code>adjust</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>
<p>the bandwidth used is actually <code>adjust*bw</code>.
This makes it easy to specify values like ‘half the default’
bandwidth.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>
<p>the smoothing kernel to be used. See <code>stats::density()</code> for
options.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>numeric vector of non-negative observation weights,
hence of same length as <code>x</code>. The default <code>NULL</code> is
equivalent to <code>weights = rep(1/nx, nx)</code> where <code>nx</code> is the
length of (the finite entries of) <code>x[]</code>.  If <code>na.rm = TRUE</code>
and there are <code>NA</code>'s in <code>x</code>, they <em>and</em> the
corresponding weights are removed before computations.  In that case,
when the original weights have summed to one, they are re-scaled to
keep doing so.
</p>
<p>Note that weights are <em>not</em> taken into account for automatic
bandwidth rules, i.e., when <code>bw</code> is a string.  When the weights
are proportional to true counts <code>cn</code>, <code>density(x = rep(x, cn))</code>
may be used instead of <code>weights</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of equally spaced points at which the density is
to be estimated.  When <code>n &gt; 512</code>, it is rounded up to a power
of 2 during the calculations (as <code>fft</code> is used) and the
final result is interpolated by <code>approx</code>.  So it almost
always makes sense to specify <code>n</code> as a power of two.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments passed on to <code>lattice::diag.panel.splom()</code> and
<code>lattice::panel.lines()</code>.</p>
</td>
</tr>
</table>
<h3>See Also</h3>

<p><code>lattice::diag.panel.splom()</code>, <code>lattice::splom()</code>,
<code>stats::density()</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">splom(~ iris[1:4],
  data = iris,
  diag.panel = diag.panel.splom.density,
  pscales = 0
)
</code></pre>


</div>