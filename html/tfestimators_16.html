<div class="container">

<table style="width: 100%;"><tr>
<td>column_embedding</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Construct a Dense Column</h2>

<h3>Description</h3>

<p>Use this when your inputs are sparse, but you want to convert them to a dense
representation (e.g., to feed to a DNN). Inputs must be a
categorical column created by any of the <code style="white-space: pre;">⁠column_categorical_*()⁠</code>
functions.
</p>


<h3>Usage</h3>

<pre><code class="language-R">column_embedding(
  categorical_column,
  dimension,
  combiner = "mean",
  initializer = NULL,
  ckpt_to_load_from = NULL,
  tensor_name_in_ckpt = NULL,
  max_norm = NULL,
  trainable = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>categorical_column</code></td>
<td>
<p>A categorical column created by a
<code style="white-space: pre;">⁠column_categorical_*()⁠</code> function. This column produces the sparse IDs
that are inputs to the embedding lookup.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dimension</code></td>
<td>
<p>A positive integer, specifying dimension of the embedding.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>combiner</code></td>
<td>
<p>A string specifying how to reduce if there are multiple
entries in a single row. Currently <code>"mean"</code>, <code>"sqrtn"</code> and <code>"sum"</code> are
supported, with <code>"mean"</code> the default. <code>"sqrtn"</code>' often achieves good
accuracy, in particular with bag-of-words columns. Each of this can be
thought as example level normalizations on the column.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>initializer</code></td>
<td>
<p>A variable initializer function to be used in embedding
variable initialization. If not specified, defaults to
<code>tf$truncated_normal_initializer</code> with mean <code>0.0</code> and standard deviation
<code>1 / sqrt(dimension)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ckpt_to_load_from</code></td>
<td>
<p>String representing checkpoint name/pattern from
which to restore column weights. Required if <code>tensor_name_in_ckpt</code> is not
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tensor_name_in_ckpt</code></td>
<td>
<p>Name of the <code>Tensor</code> in <code>ckpt_to_load_from</code> from
which to restore the column weights. Required if <code>ckpt_to_load_from</code> is not
<code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_norm</code></td>
<td>
<p>If not <code>NULL</code>, embedding values are l2-normalized to this
value.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trainable</code></td>
<td>
<p>Whether or not the embedding is trainable. Default is TRUE.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A dense column that converts from sparse input.
</p>


<h3>Raises</h3>


<ul>
<li>
<p> ValueError: if <code>dimension</code> not &gt; 0.
</p>
</li>
<li>
<p> ValueError: if exactly one of <code>ckpt_to_load_from</code> and <code>tensor_name_in_ckpt</code>
is specified.
</p>
</li>
<li>
<p> ValueError: if <code>initializer</code> is specified and is not callable.
</p>
</li>
</ul>
<h3>See Also</h3>

<p>Other feature column constructors: 
<code>column_bucketized()</code>,
<code>column_categorical_weighted()</code>,
<code>column_categorical_with_hash_bucket()</code>,
<code>column_categorical_with_identity()</code>,
<code>column_categorical_with_vocabulary_file()</code>,
<code>column_categorical_with_vocabulary_list()</code>,
<code>column_crossed()</code>,
<code>column_numeric()</code>,
<code>input_layer()</code>
</p>


</div>