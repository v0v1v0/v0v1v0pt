<div class="container">

<table style="width: 100%;"><tr>
<td>synth_method</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>synth_method</h2>

<h3>Description</h3>

<p>AUX Function: Original synthetic control method proposed by (Abadie et al.
2003, 2010, 2015) and implemented in <code>synth</code> package. Method has been
commandeered for internal use here.
</p>


<h3>Usage</h3>

<pre><code class="language-R">synth_method(
  treatment_unit_covariates = NULL,
  control_units_covariates = NULL,
  control_units_outcome = NULL,
  treatment_unit_outcome = NULL,
  custom.v = NULL,
  optimxmethod = c("Nelder-Mead", "BFGS"),
  genoud = FALSE,
  Margin.ipop = 5e-04,
  Sigf.ipop = 5,
  Bound.ipop = 10,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>treatment_unit_covariates</code></td>
<td>
<p>matrix of treated predictor data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_units_covariates</code></td>
<td>
<p>matrix of controls' predictor data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control_units_outcome</code></td>
<td>
<p>matrix of controls' outcome data for the
pre-treatment periods over which MSPE is to be minimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treatment_unit_outcome</code></td>
<td>
<p>matrix of treated outcome data for the
pre-treatment periods over which MSPE is to be minimized.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>custom.v</code></td>
<td>
<p>vector of weights for predictors supplied by the user. uses
synth to bypass optimization for solution.V. See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>optimxmethod</code></td>
<td>
<p>string vector that specifies the optimization algorithms
to be used. Permissible values are all optimization algorithms that are
currently implemented in the optimx function (see this function for
details). This list currently includes c("Nelder-Mead', 'BFGS', 'CG',
'L-BFGS-B', 'nlm', 'nlminb', 'spg', and 'ucminf"). If multiple algorithms
are specified, synth will run the optimization with all chosen algorithms
and then return the result for the best performing method. Default is
c("Nelder-Mead", "BFGS"). As an additional possibility, the user can also
specify 'All' which means that synth will run the results over all
algorithms in optimx.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>genoud</code></td>
<td>
<p>Logical flag. If true, synth embarks on a two step
optimization. In the first step, genoud, an optimization function that
combines evolutionary algorithm methods with a derivative-based
(quasi-Newton) method to solve difficult optimization problems, is used to
obtain a solution. See genoud for details. In the second step, the genoud
results are passed to the optimization algorithm(s) chosen in optimxmethod
for a local optimization within the neighborhood of the genoud solution.
This two step optimization procedure will require much more computing time,
but may yield lower loss in cases where the search space is highly
irregular.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Margin.ipop</code></td>
<td>
<p>setting for ipop optimization routine: how close we get to
the constrains (see ipop for details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sigf.ipop</code></td>
<td>
<p>setting for ipop optimization routine: Precision (default: 7
significant figures (see ipop for details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Bound.ipop</code></td>
<td>
<p>setting for ipop optimization routine: Clipping bound for
the variables (see ipop for details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Logical flag. If TRUE then intermediate results will be shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments to be passed to optimx and or genoud to
adjust optimization.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Synth works as the main engine of the <code>tidysynth</code> package. More on the method
and estimation procedures can be found in (Abadie et al. 2010).
</p>
<p>As proposed in Abadie and Gardeazabal (2003) and Abadie, Diamond,
Hainmueller (2010), the synth function routinely searches for the set of
weights that generate the best fitting convex combination of the control
units. In other words, the predictor weight matrix V is chosen among all
positive definite diagonal matrices such that MSPE is minimized for the
pre-intervention period. Instead of using this data-driven procedures to
search for the best fitting synthetic control group, the user may supply
his own vector of V weights, based on his subjective assessment of the
predictive power of the variables in treatment_unit_covariates and
control_units_covariates. In this case, the vector of V weights for each
variable should be supplied via the custom.V option in synth and the
optimization over the V matrices is bypassed.
</p>


<h3>Value</h3>

<p>solution.v =	vector of predictor weights; solution.w = vector of
weights across the controls; loss.v	= MSPE from optimization over v and w
weights; loss.w	= Loss from optimization over w weights; custom.v	=if this
argument was specified in the call to synth, this outputs the weight vector
specified; rgV.optim = Results from optimx() minimization. Could be used
for diagnostics.
</p>


</div>