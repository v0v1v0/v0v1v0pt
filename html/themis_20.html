<div class="container">

<table style="width: 100%;"><tr>
<td>step_bsmote</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Apply borderline-SMOTE Algorithm</h2>

<h3>Description</h3>

<p><code>step_bsmote()</code> creates a <em>specification</em> of a recipe step that generate new
examples of the minority class using nearest neighbors of these cases in the
border region between classes.
</p>


<h3>Usage</h3>

<pre><code class="language-R">step_bsmote(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  column = NULL,
  over_ratio = 1,
  neighbors = 5,
  all_neighbors = FALSE,
  skip = TRUE,
  seed = sample.int(10^5, 1),
  id = rand_id("bsmote")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>One or more selector functions to choose which
variable is used to sample the data. See <code>selections()</code>
for more details. The selection should result in <em>single
factor variable</em>. For the <code>tidy</code> method, these are not
currently used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>column</code></td>
<td>
<p>A character string of the variable name that will
be populated (eventually) by the <code>...</code> selectors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>over_ratio</code></td>
<td>
<p>A numeric value for the ratio of the
majority-to-minority frequencies. The default value (1) means
that all other levels are sampled up to have the same
frequency as the most occurring level. A value of 0.5 would mean
that the minority levels will have (at most) (approximately)
half as many rows than the majority level.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>neighbors</code></td>
<td>
<p>An integer. Number of nearest neighbor that are used
to generate the new examples of the minority class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>all_neighbors</code></td>
<td>
<p>Type of two borderline-SMOTE method. Defaults to FALSE.
See details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code>bake()</code>? While all operations are baked
when <code>prep()</code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>An integer that will be used as the seed when
smote-ing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This methods works the same way as <code>step_smote()</code>, expect that instead of
generating points around every point of of the minority class each point is
first being classified into the boxes "danger" and "not". For each point the
k nearest neighbors is calculated. If all the neighbors comes from a
different class it is labeled noise and put in to the "not" box. If more then
half of the neighbors comes from a different class it is labeled "danger.
</p>
<p>If all_neighbors = FALSE then points will be generated between nearest
neighbors in its own class. If all_neighbors = TRUE then points will be
generated between any nearest neighbors. See examples for visualization.
</p>
<p>The parameter <code>neighbors</code> controls the way the new examples are created.
For each currently existing minority class example X new examples will be
created (this is controlled by the parameter <code>over_ratio</code> as mentioned
above). These examples will be generated by using the information from the
<code>neighbors</code> nearest neighbor of each example of the minority class.
The parameter <code>neighbors</code> controls how many of these neighbor are used.
</p>
<p>All columns in the data are sampled and returned by <code>juice()</code>
and <code>bake()</code>.
</p>
<p>All columns used in this step must be numeric with no missing data.
</p>
<p>When used in modeling, users should strongly consider using the
option <code>skip = TRUE</code> so that the extra sampling is <em>not</em>
conducted outside of the training set.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> which is
the variable used to sample.
</p>


<h3>Tidying</h3>

<p>When you <code>tidy()</code> this step, a tibble with columns <code>terms</code>
(the selectors or variables selected) will be returned.
</p>


<h3>Tuning Parameters</h3>

<p>This step has 3 tuning parameters:
</p>

<ul>
<li> <p><code>over_ratio</code>: Over-Sampling Ratio (type: double, default: 1)
</p>
</li>
<li> <p><code>neighbors</code>: # Nearest Neighbors (type: integer, default: 5)
</p>
</li>
<li> <p><code>all_neighbors</code>: All Neighbors (type: logical, default: FALSE)
</p>
</li>
</ul>
<h3>Case weights</h3>

<p>The underlying operation does not allow for case weights.
</p>


<h3>References</h3>

<p>Hui Han, Wen-Yuan Wang, and Bing-Huan Mao. Borderline-smote:
a new over-sampling method in imbalanced data sets learning. In
International Conference on Intelligent Computing, pages 878â€“887. Springer,
2005.
</p>


<h3>See Also</h3>

<p><code>bsmote()</code> for direct implementation
</p>
<p>Other Steps for over-sampling: 
<code>step_adasyn()</code>,
<code>step_rose()</code>,
<code>step_smotenc()</code>,
<code>step_smote()</code>,
<code>step_upsample()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(recipes)
library(modeldata)
data(hpc_data)

hpc_data0 &lt;- hpc_data %&gt;%
  select(-protocol, -day)

orig &lt;- count(hpc_data0, class, name = "orig")
orig

up_rec &lt;- recipe(class ~ ., data = hpc_data0) %&gt;%
  # Bring the minority levels up to about 1000 each
  # 1000/2211 is approx 0.4523
  step_bsmote(class, over_ratio = 0.4523) %&gt;%
  prep()

training &lt;- up_rec %&gt;%
  bake(new_data = NULL) %&gt;%
  count(class, name = "training")
training

# Since `skip` defaults to TRUE, baking the step has no effect
baked &lt;- up_rec %&gt;%
  bake(new_data = hpc_data0) %&gt;%
  count(class, name = "baked")
baked

# Note that if the original data contained more rows than the
# target n (= ratio * majority_n), the data are left alone:
orig %&gt;%
  left_join(training, by = "class") %&gt;%
  left_join(baked, by = "class")

library(ggplot2)

ggplot(circle_example, aes(x, y, color = class)) +
  geom_point() +
  labs(title = "Without SMOTE")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_bsmote(class, all_neighbors = FALSE) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With borderline-SMOTE, all_neighbors = FALSE")

recipe(class ~ x + y, data = circle_example) %&gt;%
  step_bsmote(class, all_neighbors = TRUE) %&gt;%
  prep() %&gt;%
  bake(new_data = NULL) %&gt;%
  ggplot(aes(x, y, color = class)) +
  geom_point() +
  labs(title = "With borderline-SMOTE, all_neighbors = TRUE")
</code></pre>


</div>