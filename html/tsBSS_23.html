<div class="container">

<table style="width: 100%;"><tr>
<td>FixNA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
The FixNA Method for Blind Source Separation
</h2>

<h3>Description</h3>

<p>The FixNA (Fixed-point algorithm for maximizing the Nonlinear Autocorrelation; Shi et al., 2009) and FixNA2 (Matilainen et al., 2017) methods for blind source separation of time series with stochastic volatility. These methods are alternatives to vSOBI method.
</p>


<h3>Usage</h3>

<pre><code class="language-R">FixNA(X, ...)

## Default S3 method:
FixNA(X, k = 1:12, eps = 1e-06, maxiter = 1000, G = c("pow", "lcosh"),
      method = c("FixNA", "FixNA2"),
      ordered = FALSE, acfk = NULL, original = TRUE, alpha = 0.05, ...)
## S3 method for class 'ts'
FixNA(X, ...)
## S3 method for class 'xts'
FixNA(X, ...)
## S3 method for class 'zoo'
FixNA(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code>ts</code>, <code>xts</code> or <code>zoo</code>. Missing values are not allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>A vector of lags. It can be any non-zero positive integer, or a vector consisting of them. Default is <code>1:12</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Convergence tolerance.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>Function <code class="reqn">G(x)</code>. The choices are <code>"pow"</code> (default) and <code>"lcosh"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>The method to be used. The choices are <code>"FixNA"</code> (default) and <code>"FixNA2"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ordered</code></td>
<td>
<p>Whether to order components according to their volatility. Default is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>acfk</code></td>
<td>
<p>A vector of lags to be used in testing the presence of serial autocorrelation. Applicable only if <code>ordered = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>original</code></td>
<td>
<p>Whether to return the original components or their residuals based on ARMA fit. Default is <code>TRUE</code>, i.e. the original components are returned. Applicable only if <code>ordered = TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Alpha level for linear correlation detection. Default is 0.05.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T</code>,
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>. The algorithm for method FixNA finds an orthogonal matrix <code class="reqn">{\bf U}</code> by maximizing
</p>
<p style="text-align: center;"><code class="reqn">{\bf D}_1({\bf U}) = \sum_{k = 1}^K {\bf D}_{1k}({\bf U})= \sum_{k = 1}^K \sum_{i = 1}^p  \frac{1}{T - k}\sum_{t=1}^{T - k}[G({\bf u}_i' {\bf Y}_t) G({\bf u}_i' {\bf Y}_{t + k})]</code>
</p>

<p>and the algorithm for method FixNA2 finds an orthogonal matrix <code class="reqn">{\bf U}</code> by maximizing
</p>
<p style="text-align: center;"><code class="reqn">{\bf D}_2({\bf U}) = \sum_{k = 1}^K {\bf D}_{2k}({\bf U}) </code>
</p>

<p style="text-align: center;"><code class="reqn">= \sum_{k = 1}^K \sum_{i = 1}^p\left|\frac{1}{T - k}\sum_{t=1}^{T - k}[G({\bf u}_i' {\bf Y}_t) G({\bf u}_i' {\bf Y}_{t + k})] - \left(\frac{1}{T - k}\right)^2\sum_{t=1}^{T - k}[G({\bf u}_i' {\bf Y}_t)]\sum_{t=1}^{T - k}[G({\bf u}_i' {\bf Y}_{t + k})]\right|.</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, p</code>, <code class="reqn">k = 1, \ldots, K</code> and <code class="reqn">t = 1, \ldots, T</code>. For function <code class="reqn">G(x)</code> the choices are <code class="reqn">x^2</code> and log(cosh(<code class="reqn">x</code>)).
</p>
<p>The algorithm works iteratively starting with <code>diag(p)</code> as an initial value for an orthogonal matrix <code class="reqn">{\bf U} = ({\bf u}_1, {\bf u}_2, \ldots, {\bf u}_p)'</code>.
</p>
<p>Matrix <code class="reqn">{\bf T}_{mik}</code> is a partial derivative of <code class="reqn">{\bf D}_{mk}({\bf U})</code>, for <code class="reqn">m = 1, 2</code>, with respect to <code class="reqn">{\bf u}_i</code>.
Then <code class="reqn">{\bf T}_{mk} = ({\bf T}_{m1k}, \ldots, {\bf T}_{mpk})'</code>, where <code class="reqn">p</code> is the number of columns in <code class="reqn">{\bf Y}</code>, and <code class="reqn">{\bf T}_m = \sum_{k = 1}^K {\bf T}_{mk}</code>.
The update for the orthogonal matrix <code class="reqn">{\bf U}_{new} = ({\bf T}_m{\bf T}_m')^{-1/2}{\bf T}_m</code> is calculated at each iteration step. The algorithm stops when
</p>
<p style="text-align: center;"><code class="reqn">||{\bf U}_{new} - {\bf U}_{old}||</code>
</p>

<p>is less than <code>eps</code>.
The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf US}^{-1/2}</code>.
</p>
<p>For <code>ordered = TRUE</code> the function orders the sources according to their volatility. First a possible linear autocorrelation is removed using <code>auto.arima</code>. Then a squared autocorrelation test is performed for the sources (or for their residuals, when linear correlation is present). The sources are then put in a decreasing order according to the value of the test statistic of the squared autocorrelation test. For more information, see <code>lbtest</code>.
</p>


<h3>Value</h3>

<p>A list of class 'bssvol', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>W </code></td>
<td>
<p>The estimated unmixing matrix. If <code>ordered = TRUE</code>, the rows are ordered according to the order of the components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k </code></td>
<td>
<p>The vector of the used lags.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>S </code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances. If <code>ordered = TRUE</code>, then components are ordered according to their volatility. If <code>original = FALSE</code>, the sources with linear autocorrelation are replaced by their ARMA residuals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MU </code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td>
</tr>
</table>
<p>If <code>ordered = TRUE</code>, then also the following components included in the list:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Sraw </code></td>
<td>
<p>The ordered original estimated sources as time series object standardized to have mean 0 and unit variances. Returned only if <code>original = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fits </code></td>
<td>
<p>The ARMA fits for the components with linear autocorrelation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>armaeff </code></td>
<td>
<p>A logical vector. Is TRUE if ARMA fit was done to the corresponding component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linTS </code></td>
<td>
<p>The value of the modified Ljung-Box test statistic for each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>linP </code></td>
<td>
<p>p-value based on the modified Ljung-Box test statistic for each component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>volTS </code></td>
<td>
<p>The value of the volatility clustering test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>volP </code></td>
<td>
<p>p-value based on the volatility clustering test statistic.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Markus Matilainen
</p>


<h3>References</h3>

<p>Hyvärinen, A. (2001), <em>Blind Source Separation by Nonstationarity of Variance: A Cumulant-Based Approach</em>, IEEE Transactions on Neural Networks, 12(6): 1471–1474.
</p>
<p>Matilainen, M., Miettinen, J., Nordhausen, K., Oja, H. and Taskinen, S. (2017), <em>On Independent Component Analysis with Stochastic Volatility Models</em>, Austrian Journal of Statistics, 46(3–4), 57–66.
</p>
<p>Shi, Z., Jiang, Z. and Zhou, F. (2009), <em> Blind Source Separation with Nonlinear Autocorrelation and Non-Gaussianity</em>, Journal of Computational and Applied Mathematics, 223(1): 908–915.
</p>


<h3>See Also</h3>

<p><code>vSOBI</code>, <code>lbtest</code>, <code>auto.arima</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(require("stochvol")) {
n &lt;- 10000
A &lt;- matrix(rnorm(9), 3, 3)

# Simulate SV models
s1 &lt;- svsim(n, mu = -10, phi = 0.8, sigma = 0.1)$y
s2 &lt;- svsim(n, mu = -10, phi = 0.9, sigma = 0.2)$y
s3 &lt;- svsim(n, mu = -10, phi = 0.95, sigma = 0.4)$y

# Create a daily time series
X &lt;- ts(cbind(s1, s2, s3) %*% t(A), end = c(2015, 338), frequency = 365.25)

res &lt;- FixNA(X)
res
coef(res)
plot(res)
head(bss.components(res))

MD(res$W, A) # Minimum Distance Index, should be close to zero
}
</code></pre>


</div>