<div class="container">

<table style="width: 100%;"><tr>
<td>tfd_vector_diffeomixture</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>VectorDiffeomixture distribution</h2>

<h3>Description</h3>

<p>A vector diffeomixture (VDM) is a distribution parameterized by a convex
combination of <code>K</code> component <code>loc</code> vectors, <code style="white-space: pre;">⁠loc[k], k = 0,...,K-1⁠</code>, and <code>K</code>
<code>scale</code> matrices <code style="white-space: pre;">⁠scale[k], k = 0,..., K-1⁠</code>.  It approximates the following
<a href="https://en.wikipedia.org/wiki/Compound_probability_distribution">compound distribution</a>
<code style="white-space: pre;">⁠p(x) = int p(x | z) p(z) dz⁠</code>, where z is in the K-simplex, and
<code style="white-space: pre;">⁠p(x | z) := p(x | loc=sum_k z[k] loc[k], scale=sum_k z[k] scale[k])⁠</code>
</p>


<h3>Usage</h3>

<pre><code class="language-R">tfd_vector_diffeomixture(
  mix_loc,
  temperature,
  distribution,
  loc = NULL,
  scale = NULL,
  quadrature_size = 8,
  quadrature_fn = tfp$distributions$quadrature_scheme_softmaxnormal_quantiles,
  validate_args = FALSE,
  allow_nan_stats = TRUE,
  name = "VectorDiffeomixture"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mix_loc</code></td>
<td>
<p><code>float</code>-like <code>Tensor</code> with shape <code style="white-space: pre;">⁠[b1, ..., bB, K-1]⁠</code>.
In terms of samples, larger <code>mix_loc[..., k]</code> ==&gt;
<code>Z</code> is more likely to put more weight on its <code>kth</code> component.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>temperature</code></td>
<td>
<p><code>float</code>-like <code>Tensor</code>. Broadcastable with <code>mix_loc</code>.
In terms of samples, smaller <code>temperature</code> means one component is more
likely to dominate.  I.e., smaller <code>temperature</code> makes the VDM look more
like a standard mixture of <code>K</code> components.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>distribution</code></td>
<td>
<p><code>tfp$distributions$Distribution</code>-like instance. Distribution
from which <code>d</code> iid samples are used as input to the selected affine
transformation. Must be a scalar-batch, scalar-event distribution.
Typically <code>distribution$reparameterization_type = FULLY_REPARAMETERIZED</code>
or it is a function of non-trainable parameters. WARNING: If you
backprop through a VectorDiffeomixture sample and the <code>distribution</code>
is not <code>FULLY_REPARAMETERIZED</code> yet is a function of trainable variables,
then the gradient will be incorrect!</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>loc</code></td>
<td>
<p>Length-<code>K</code> list of <code>float</code>-type <code>Tensor</code>s. The <code>k</code>-th element
represents the <code>shift</code> used for the <code>k</code>-th affine transformation.  If
the <code>k</code>-th item is <code>NULL</code>, <code>loc</code> is implicitly <code>0</code>.  When specified,
must have shape <code style="white-space: pre;">⁠[B1, ..., Bb, d]⁠</code> where <code>b &gt;= 0</code> and <code>d</code> is the event
size.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Length-<code>K</code> list of <code>LinearOperator</code>s. Each should be
positive-definite and operate on a <code>d</code>-dimensional vector space. The
<code>k</code>-th element represents the <code>scale</code> used for the <code>k</code>-th affine
transformation. <code>LinearOperator</code>s must have shape <code style="white-space: pre;">⁠[B1, ..., Bb, d, d]⁠</code>,
<code>b &gt;= 0</code>, i.e., characterizes <code>b</code>-batches of <code style="white-space: pre;">⁠d x d⁠</code> matrices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadrature_size</code></td>
<td>
<p><code>integer</code> scalar representing number of
quadrature points.  Larger <code>quadrature_size</code> means <code>q_N(x)</code> better
approximates <code>p(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quadrature_fn</code></td>
<td>
<p>Function taking <code>normal_loc</code>, <code>normal_scale</code>,
<code>quadrature_size</code>, <code>validate_args</code> and returning <code>tuple(grid, probs)</code>
representing the SoftmaxNormal grid and corresponding normalized weight.
normalized) weight.
Default value: <code>quadrature_scheme_softmaxnormal_quantiles</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>validate_args</code></td>
<td>
<p>Logical, default FALSE. When TRUE distribution parameters are checked
for validity despite possibly degrading runtime performance. When FALSE invalid inputs may
silently render incorrect outputs. Default value: FALSE.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>allow_nan_stats</code></td>
<td>
<p>Logical, default TRUE. When TRUE, statistics (e.g., mean, mode, variance)
use the value NaN to indicate the result is undefined. When FALSE, an exception is raised if
one or more of the statistic's batch members are undefined.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>name prefixed to Ops created by this class.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The integral <code style="white-space: pre;">⁠int p(x | z) p(z) dz⁠</code> is approximated with a quadrature scheme
adapted to the mixture density <code>p(z)</code>.  The <code>N</code> quadrature points <code style="white-space: pre;">⁠z_{N, n}⁠</code>
and weights <code style="white-space: pre;">⁠w_{N, n}⁠</code> (which are non-negative and sum to 1) are chosen such that
<code style="white-space: pre;">⁠q_N(x) := sum_{n=1}^N w_{n, N} p(x | z_{N, n}) --&gt; p(x)⁠</code> as <code style="white-space: pre;">⁠N --&gt; infinity⁠</code>.
</p>
<p>Since <code>q_N(x)</code> is in fact a mixture (of <code>N</code> points), we may sample from
<code>q_N</code> exactly.  It is important to note that the VDM is <em>defined</em> as <code>q_N</code>
above, and <em>not</em> <code>p(x)</code>.  Therefore, sampling and pdf may be implemented as
exact (up to floating point error) methods.
</p>
<p>A common choice for the conditional <code>p(x | z)</code> is a multivariate Normal.
The implemented marginal <code>p(z)</code> is the <code>SoftmaxNormal</code>, which is a
<code>K-1</code> dimensional Normal transformed by a <code>SoftmaxCentered</code> bijector, making
it a density on the <code>K</code>-simplex.  That is,
<code>Z = SoftmaxCentered(X)</code>, <code>X = Normal(mix_loc / temperature, 1 / temperature)</code>
</p>
<p>The default quadrature scheme chooses <code style="white-space: pre;">⁠z_{N, n}⁠</code> as <code>N</code> midpoints of
the quantiles of <code>p(z)</code> (generalized quantiles if <code>K &gt; 2</code>).
See Dillon and Langmore (2018) for more details.
</p>
<p>About <code>Vector</code> distributions in TensorFlow.
</p>
<p>The <code>VectorDiffeomixture</code> is a non-standard distribution that has properties
particularly useful in <a href="https://en.wikipedia.org/wiki/Variational_Bayesian_methods">variational Bayesian methods</a>.
Conditioned on a draw from the SoftmaxNormal, <code>X|z</code> is a vector whose
components are linear combinations of affine transformations, thus is itself
an affine transformation.
</p>
<p>Note: The marginals <code style="white-space: pre;">⁠X_1|v, ..., X_d|v⁠</code> are <em>not</em> generally identical to some
parameterization of <code>distribution</code>.  This is due to the fact that the sum of
draws from <code>distribution</code> are not generally itself the same <code>distribution</code>.
</p>
<p>About <code>Diffeomixture</code>s and reparameterization.
</p>
<p>The <code>VectorDiffeomixture</code> is designed to be reparameterized, i.e., its
parameters are only used to transform samples from a distribution which has no
trainable parameters. This property is important because backprop stops at
sources of stochasticity. That is, as long as the parameters are used <em>after</em>
the underlying source of stochasticity, the computed gradient is accurate.
Reparametrization means that we can use gradient-descent (via backprop) to
optimize Monte-Carlo objectives. Such objectives are a finite-sample
approximation of an expectation and arise throughout scientific computing.
</p>
<p>WARNING: If you backprop through a VectorDiffeomixture sample and the "base"
distribution is both: not <code>FULLY_REPARAMETERIZED</code> and a function of trainable
variables, then the gradient is not guaranteed correct!
</p>


<h3>Value</h3>

<p>a distribution instance.
</p>


<h3>References</h3>


<ul><li> <p><a href="https://arxiv.org/abs/1801.03080">Joshua Dillon and Ian Langmore. Quadrature Compound: An approximating family of distributions. <em>arXiv preprint arXiv:1801.03080</em>, 2018.</a>
</p>
</li></ul>
<h3>See Also</h3>

<p>For usage examples see e.g. <code>tfd_sample()</code>, <code>tfd_log_prob()</code>, <code>tfd_mean()</code>.
</p>
<p>Other distributions: 
<code>tfd_autoregressive()</code>,
<code>tfd_batch_reshape()</code>,
<code>tfd_bates()</code>,
<code>tfd_bernoulli()</code>,
<code>tfd_beta_binomial()</code>,
<code>tfd_beta()</code>,
<code>tfd_binomial()</code>,
<code>tfd_categorical()</code>,
<code>tfd_cauchy()</code>,
<code>tfd_chi2()</code>,
<code>tfd_chi()</code>,
<code>tfd_cholesky_lkj()</code>,
<code>tfd_continuous_bernoulli()</code>,
<code>tfd_deterministic()</code>,
<code>tfd_dirichlet_multinomial()</code>,
<code>tfd_dirichlet()</code>,
<code>tfd_empirical()</code>,
<code>tfd_exp_gamma()</code>,
<code>tfd_exp_inverse_gamma()</code>,
<code>tfd_exponential()</code>,
<code>tfd_gamma_gamma()</code>,
<code>tfd_gamma()</code>,
<code>tfd_gaussian_process_regression_model()</code>,
<code>tfd_gaussian_process()</code>,
<code>tfd_generalized_normal()</code>,
<code>tfd_geometric()</code>,
<code>tfd_gumbel()</code>,
<code>tfd_half_cauchy()</code>,
<code>tfd_half_normal()</code>,
<code>tfd_hidden_markov_model()</code>,
<code>tfd_horseshoe()</code>,
<code>tfd_independent()</code>,
<code>tfd_inverse_gamma()</code>,
<code>tfd_inverse_gaussian()</code>,
<code>tfd_johnson_s_u()</code>,
<code>tfd_joint_distribution_named_auto_batched()</code>,
<code>tfd_joint_distribution_named()</code>,
<code>tfd_joint_distribution_sequential_auto_batched()</code>,
<code>tfd_joint_distribution_sequential()</code>,
<code>tfd_kumaraswamy()</code>,
<code>tfd_laplace()</code>,
<code>tfd_linear_gaussian_state_space_model()</code>,
<code>tfd_lkj()</code>,
<code>tfd_log_logistic()</code>,
<code>tfd_log_normal()</code>,
<code>tfd_logistic()</code>,
<code>tfd_mixture_same_family()</code>,
<code>tfd_mixture()</code>,
<code>tfd_multinomial()</code>,
<code>tfd_multivariate_normal_diag_plus_low_rank()</code>,
<code>tfd_multivariate_normal_diag()</code>,
<code>tfd_multivariate_normal_full_covariance()</code>,
<code>tfd_multivariate_normal_linear_operator()</code>,
<code>tfd_multivariate_normal_tri_l()</code>,
<code>tfd_multivariate_student_t_linear_operator()</code>,
<code>tfd_negative_binomial()</code>,
<code>tfd_normal()</code>,
<code>tfd_one_hot_categorical()</code>,
<code>tfd_pareto()</code>,
<code>tfd_pixel_cnn()</code>,
<code>tfd_poisson_log_normal_quadrature_compound()</code>,
<code>tfd_poisson()</code>,
<code>tfd_power_spherical()</code>,
<code>tfd_probit_bernoulli()</code>,
<code>tfd_quantized()</code>,
<code>tfd_relaxed_bernoulli()</code>,
<code>tfd_relaxed_one_hot_categorical()</code>,
<code>tfd_sample_distribution()</code>,
<code>tfd_sinh_arcsinh()</code>,
<code>tfd_skellam()</code>,
<code>tfd_spherical_uniform()</code>,
<code>tfd_student_t_process()</code>,
<code>tfd_student_t()</code>,
<code>tfd_transformed_distribution()</code>,
<code>tfd_triangular()</code>,
<code>tfd_truncated_cauchy()</code>,
<code>tfd_truncated_normal()</code>,
<code>tfd_uniform()</code>,
<code>tfd_variational_gaussian_process()</code>,
<code>tfd_vector_exponential_diag()</code>,
<code>tfd_vector_exponential_linear_operator()</code>,
<code>tfd_vector_laplace_diag()</code>,
<code>tfd_vector_laplace_linear_operator()</code>,
<code>tfd_vector_sinh_arcsinh_diag()</code>,
<code>tfd_von_mises_fisher()</code>,
<code>tfd_von_mises()</code>,
<code>tfd_weibull()</code>,
<code>tfd_wishart_linear_operator()</code>,
<code>tfd_wishart_tri_l()</code>,
<code>tfd_wishart()</code>,
<code>tfd_zipf()</code>
</p>


</div>