<div class="container">

<table style="width: 100%;"><tr>
<td>test_arguments</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Test (multiple) arguments of a prediction algorithm</h2>

<h3>Description</h3>

<p>Test the performance of a prediction algorithm over a range of argument
values. Multiple arguments can be tested simultaneously.
</p>


<h3>Usage</h3>

<pre><code class="language-R">test_arguments(pred_fun, df_train, df_test, diagnostic_fun, arguments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>pred_fun</code></td>
<td>
<p>The prediction algorithm to be tested.
It should be a function with formal arguments <code>df_train</code> and <code>df_test</code>, which are data used to train the model and test out-of-sample predictive
performance, respectively, as well as any arguments which are to be tested.
The value of <code>pred_fun</code> should be a matrix-like object
with named columns and the same number of rows as <code>df_test</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_train</code></td>
<td>
<p>training data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df_test</code></td>
<td>
<p>testing data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic_fun</code></td>
<td>
<p>the criteria with which the predictive performance will be assessed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arguments</code></td>
<td>
<p>named list of arguments and their values to check</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For each combination of the supplied argument levels, the value of
<code>pred_fun()</code> is combined with <code>df_test</code> using <code>cbind()</code>,
which is then passed into <code>diagnostic_fun()</code> to compute the diagnostics.
Since the number of columns in the returned value of <code>pred_fun()</code> is arbitrary,
one can test both predictions and uncertainty quantification of the predictions
(e.g., by including prediction standard errors or predictive interval bounds)
</p>


<h3>Value</h3>

<p>an object of class <code>'testargs'</code> containing all information from the testing procedure
</p>


<h3>See Also</h3>

<p><code>plot_diagnostics</code>, <code>optimal_arguments</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library("testarguments")

## Simulate training and testing data
RNGversion("3.6.0"); set.seed(1)
n  &lt;- 1000                                          # sample size
x  &lt;- seq(-1, 1, length.out = n)                    # covariates
mu &lt;- exp(3 + 2 * x * (x - 1) * (x + 1) * (x - 2))  # polynomial function in x
Z  &lt;- rpois(n, mu)                                  # simulate data
df       &lt;- data.frame(x = x, Z = Z, mu = mu)
train_id &lt;- sample(1:n, n/2, replace = FALSE)
df_train &lt;- df[train_id, ]
df_test  &lt;- df[-train_id, ]

## Algorithm that uses df_train to predict over df_test. We use glm(), and
## test the degree of the regression polynomial and the link function.
pred_fun &lt;- function(df_train, df_test, degree, link) {

  M &lt;- glm(Z ~ poly(x, degree), data = df_train,
           family = poisson(link = as.character(link)))

  ## Predict over df_test
  pred &lt;- as.data.frame(predict(M, df_test, type = "link", se.fit = TRUE))

  ## Compute response level predictions and 90% prediction interval
  inv_link &lt;- family(M)$linkinv
  fit_Y &lt;- pred$fit
  se_Y  &lt;- pred$se.fit
  pred &lt;- data.frame(fit_Z = inv_link(fit_Y),
                     upr_Z = inv_link(fit_Y + 1.645 * se_Y),
                     lwr_Z = inv_link(fit_Y - 1.645 * se_Y))

  return(pred)
}

## Define diagnostic function. Should return a named vector
diagnostic_fun &lt;- function(df) {
  with(df, c(
    RMSE = sqrt(mean((Z - fit_Z)^2)),
    MAE = mean(abs(Z - fit_Z)),
    coverage = mean(lwr_Z &lt; mu &amp; mu &lt; upr_Z)
  ))
}

## Compute the user-defined diagnostics over a range of argument levels
testargs_object &lt;- test_arguments(
  pred_fun, df_train, df_test, diagnostic_fun,
  arguments = list(degree = 1:6, link = c("log", "sqrt"))
)

## Visualise the performance across all combinations of the supplied arguments
plot_diagnostics(testargs_object)

## Focus on a subset of the tested arguments
plot_diagnostics(testargs_object, focused_args = "degree")

## Compute the optimal arguments for each diagnostic
optimal_arguments(
  testargs_object,
  optimality_criterion = list(coverage = function(x) which.min(abs(x - 0.90)))
)
</code></pre>


</div>