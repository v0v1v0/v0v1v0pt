<div class="container">

<table style="width: 100%;"><tr>
<td>pad_tau</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Pad and unpad changepoint sets with boundary points</h2>

<h3>Description</h3>

<p>Pad and unpad changepoint sets with boundary points
</p>


<h3>Usage</h3>

<pre><code class="language-R">pad_tau(tau, n)

unpad_tau(padded_tau)

is_valid_tau(tau, n)

validate_tau(tau, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tau</code></td>
<td>
<p>a numeric vector of changepoint indices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the length of the original time series</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>padded_tau</code></td>
<td>
<p>Output from <code>pad_tau()</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>If a time series contains <code class="reqn">n</code> observations, we label them from 1
to <code class="reqn">n</code>.
Neither the 1st point nor the <code class="reqn">n</code>th point can be a changepoint, since the
regions they create on one side would be empty.
However, for dividing the time series into non-empty segments, we start with
1, add <code class="reqn">n+1</code>, and then divide the half-open interval <code class="reqn">[1, n+1)</code> into
half-open subintervals that define the regions.
</p>
<p><code>pad_tau()</code> ensures that 1 and <code class="reqn">n+1</code> are included.
</p>
<p><code>unpad_tau()</code> removes 1 and <code class="reqn">n+1</code>, should they exist.
</p>
<p><code>is_valid_tau()</code> checks to see if the supplied set of changepoints is valid
</p>
<p><code>validate_tau()</code> removes duplicates and boundary values.
</p>


<h3>Value</h3>


<ul><li> <p><code>pad_tau()</code>: an <code>integer</code> vector that starts with 0 and ends in <code class="reqn">n</code>.
</p>
</li></ul>
<ul><li> <p><code>unpad_tau()</code>: an <code>integer</code> vector stripped of its first and last entries.
</p>
</li></ul>
<ul><li> <p><code>is_valid_tau()</code>: a <code>logical</code> if all of the entries are between 2 and
<code class="reqn">n-1</code>.
</p>
</li></ul>
<ul><li> <p><code>validate_tau()</code>: an <code>integer</code> vector with only the <code>base::unique()</code>
entries between 2 and <code class="reqn">n-1</code>, inclusive.
</p>
</li></ul>
<h3>Examples</h3>

<pre><code class="language-R"># Anything less than 2 is not allowed
is_valid_tau(0, length(DataCPSim))
is_valid_tau(1, length(DataCPSim))

# Duplicates are allowed
is_valid_tau(c(42, 42), length(DataCPSim))
is_valid_tau(826, length(DataCPSim))

# Anything greater than \eqn{n} (in this case 1096) is not allowed
is_valid_tau(1096, length(DataCPSim))
is_valid_tau(1097, length(DataCPSim))

# Anything less than 2 is not allowed
validate_tau(0, length(DataCPSim))
validate_tau(1, length(DataCPSim))
validate_tau(826, length(DataCPSim))

# Duplicates are removed
validate_tau(c(826, 826), length(DataCPSim))

# Anything greater than \eqn{n} (in this case 1096) is not allowed
validate_tau(1096, length(DataCPSim))
validate_tau(1097, length(DataCPSim))

# Fix many problems
validate_tau(c(-4, 0, 1, 4, 5, 5, 824, 1096, 1097, 182384), length(DataCPSim))

</code></pre>


</div>