<div class="container">

<table style="width: 100%;"><tr>
<td>tpc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>PC Algorithm Accounting for a Partial Node Ordering</h2>

<h3>Description</h3>

<p>Like [pcalg::pc()], but takes into account a user-specified partial
ordering of the nodes/variables. This has two effects:
1) The conditional independence between <code>x</code> and <code>y</code> given <code>S</code> is
ot tested if any variable in <code>S</code> lies in the future of both <code>x</code> and <code>y</code>;
2) edges cannot be oriented from a higher-order to a lower-order node. In addition,
the user may specify individual forbidden edges and context variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tpc(
  suffStat,
  indepTest,
  alpha,
  labels,
  p,
  skel.method = c("stable", "stable.parallel"),
  forbEdges = NULL,
  m.max = Inf,
  conservative = FALSE,
  maj.rule = TRUE,
  tiers = NULL,
  context.all = NULL,
  context.tier = NULL,
  verbose = FALSE,
  numCores = NULL,
  cl.type = "PSOCK",
  clusterexport = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>suffStat</code></td>
<td>
<p>A [base::list()] of sufficient statistics, containing all necessary
elements for the conditional independence decisions in the function [indepTest()].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indepTest</code></td>
<td>
<p>A function for testing conditional independence. It is internally
called as <code>indepTest(x,y,S,suffStat)</code>, and tests conditional independence of
<code>x</code> and <code>y</code> given <code>S</code>. Here, <code>x</code> and <code>y</code> are variables, and
<code>S</code> is a (possibly empty) vector of variables (all variables are denoted by their
(integer) column positions in the adjacency matrix). <code>suffStat</code> is a list,
see the argument above. The return value of <code>indepTest</code> is the p-value of the
test for conditional independence.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>significance level (number in <em>(0,1)</em> for the individual conditional
independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>labels</code></td>
<td>
<p>(optional) character vector of variable (or "node") names.
Typically preferred to specifying <code>p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if <code>labels</code>
are not, in which case <code>labels</code> is set to <code>1:p</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skel.method</code></td>
<td>
<p>Character string specifying method; the default, "stable" provides
an order-independent skeleton, see [tpc::tskeleton()].</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>forbEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If <code>[i,j]</code> is TRUE, then the
directed edge i-&gt;j is forbidden. If both <code>[i,j]</code> and <code>[j,i]</code> are TRUE, then any type of
edge between i and j is forbidden.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conservative</code></td>
<td>
<p>Logical indicating if conservative PC should be used.
Defaults to FALSE. See [pcalg::pc()] for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maj.rule</code></td>
<td>
<p>Logical indicating if the majority rule should be used. Defaults
to TRUE. See [pcalg::pc()] for details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tiers</code></td>
<td>
<p>Numeric vector specifying the tier / time point for each variable.
Must be of length 'p', if specified, or have the same length as 'labels', if specified.
A smaller number corresponds to an earlier tier / time point.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>context.all</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or names
of global context variables. Global context variables have no incoming edges, i.e.
no parents, and are themselves parents of all non-context variables in the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>context.tier</code></td>
<td>
<p>Numeric or character vector. Specifies the positions or
names of tier-specific context variables. Tier-specific context variables have no
incoming edges, i.e. no parents, and are themselves parents of all non-context variables
in the same tier.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>if <code>TRUE</code>, detailed output is provided.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>numCores</code></td>
<td>
<p>The numbers of CPU cores to be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cl.type</code></td>
<td>
<p>The cluster type. Default value is <code>"PSOCK"</code>.
For High-performance clusters use <code>"MPI"</code>. See also <code>parallel::makeCluster</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clusterexport</code></td>
<td>
<p>Character vector. Lists functions to be exported to nodes if numCores &gt; 1.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <code>pcalg::pc</code> for further information on the PC algorithm.
The PC algorithm is named after its developers Peter Spirtes and Clark Glymour
(Spirtes et al., 2000).
</p>
<p>Specifying a tier for each variable using the <code>tier</code> argument has the
following effects:
1) In the skeleton phase and v-structure learing phases,
conditional independence testing is restricted such that if x is in tier t(x)
and y is in t(y), only those variables are allowed in the conditioning set whose
tier is not larger than t(x).
2) Following the v-structure phase, all
edges that were found between two tiers are directed into the direction of the
higher-order tier. If context variables are specified using <code>context.all</code>
and/or <code>context.tier</code>, the corresponding orientations are added in this step.
</p>


<h3>Value</h3>

<p>An object of <code>class</code> "<code>pcAlgo</code>"
(see [pcalg::pcalgo] containing an estimate of the equivalence class of
the underlying DAG.
</p>


<h3>Author(s)</h3>

<p>Original code by Markus Kalisch, Martin Maechler, and Diego Colombo.
Modifications by Janine Witte (Kalisch et al., 2012).
</p>


<h3>References</h3>

<p>M. Kalisch, M. Maechler, D. Colombo, M.H. Maathuis and P. Buehlmann (2012).
Causal Inference Using Graphical Models with the R Package pcalg.
Journal of Statistical Software 47(11): 1â€“26.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000). Causation, Prediction,
and Search, 2nd edition. The MIT Press. https://philarchive.org/archive/SPICPA-2.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># load simulated cohort data
data(dat_sim)
n &lt;- nrow(dat_sim)
lab &lt;- colnames(dat_sim)

# estimate skeleton without taking background information into account
tpc.fit &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
               indepTest = gaussCItest, alpha = 0.01, labels = lab)
pc.fit &lt;- pcalg::pc(suffStat = list(C = cor(dat_sim), n = n),
                    indepTest = gaussCItest, alpha = 0.01, labels = lab,
                    maj.rule = TRUE, solve.conf = TRUE)
identical(pc.fit@graph, tpc.fit@graph) # TRUE
# estimate skeleton with temporal ordering as background information
tiers &lt;- rep(c(1,2,3), times=c(3,3,3))
tpc.fit2 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                indepTest = gaussCItest, alpha = 0.01, labels = lab, tiers = tiers)

tpc.fit3 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                indepTest = gaussCItest, alpha = 0.01, labels = lab, tiers = tiers,
                skel.method = "stable.parallel",
                numCores = 2, clusterexport = c("cor", "ecdf"))

if(requireNamespace("Rgraphviz", quietly = TRUE)){
 data("true_sim")
 oldpar &lt;- par(mfrow = c(1,3))
 plot(true_sim, main = "True DAG")
 plot(tpc.fit, main = "PC estimate")
 plot(tpc.fit2, main = "tPC estimate")
 par(oldpar)
 }

 # require that there is no edge between A1 and A1, and that any edge between A2 and B2
 # or A2 and C2 is directed away from A2
 forb &lt;- matrix(FALSE, nrow=9, ncol=9)
 rownames(forb) &lt;- colnames(forb) &lt;- lab
 forb["A1","A3"] &lt;- forb["A3","A1"] &lt;- TRUE
 forb["B2","A2"] &lt;- TRUE
 forb["C2","A2"] &lt;- TRUE

 tpc.fit3 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                 indepTest = gaussCItest, alpha = 0.01,labels = lab,
                 forbEdges = forb, tiers = tiers)

 if (requireNamespace("Rgraphviz", quietly = TRUE)) {
 # compare estimated CPDAGs
   data("true_sim")
   oldpar &lt;- par(mfrow = c(1,2))
   plot(tpc.fit2, main = "old tPC estimate")
   plot(tpc.fit3, main = "new tPC estimate")
   par(oldpar)
 }
 # force edge from A1 to all other nodes measured at time 1
 # into the graph (note that the edge from A1 to A2 is then
 # forbidden)
 tpc.fit4 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                 indepTest = gaussCItest, alpha = 0.01, labels = lab,
                 tiers = tiers, context.tier = "A1")

 if (requireNamespace("Rgraphviz", quietly = TRUE)) {
 # compare estimated CPDAGs
  data("true_sim")
  plot(tpc.fit4, main = "alternative tPC estimate")
 }

 # force edge from A1 to all other nodes into the graph
 tpc.fit5 &lt;- tpc(suffStat = list(C = cor(dat_sim), n = n),
                 indepTest = gaussCItest, alpha = 0.01, labels = lab,
                 tiers = tiers, context.all = "A1")

 if (requireNamespace("Rgraphviz", quietly = TRUE)) {
 # compare estimated CPDAGs
 data("true_sim")
 plot(tpc.fit5, main = "alternative tPC estimate")
 }

</code></pre>


</div>