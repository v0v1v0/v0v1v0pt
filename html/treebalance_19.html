<div class="container">

<table style="width: 100%;"><tr>
<td>getDescMatrix</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Auxiliary functions</h2>

<h3>Description</h3>

<p><code>getDescMatrix</code> - Creates a matrix that contains the descendants of
node <code class="reqn">i</code> in row <code class="reqn">i</code>.
</p>
<p><code>getAncVec</code> - Creates a vector that contains the parent (direct ancestor) of
node <code class="reqn">i</code> at position <code class="reqn">i</code>.
</p>
<p><code>getNodesOfDepth</code> - Creates a matrix that contains the nodes of
depth <code class="reqn">i</code> in row <code class="reqn">i</code>.
</p>
<p><code>symBucketLexicoSort</code> - Sorts the pairs of numbers lexicographically and
returns ranking. Uses bucket sort.
</p>
<p><code>getAllAncestors</code> - Returns all ancestors of <code class="reqn">v</code> including <code class="reqn">v</code> itself.
</p>
<p><code>cPL_inv</code> - Returns the binary tree that belongs to the input label in an incomplete
Newick format.
</p>
<p><code>maxDepthLeaf</code> - Returns the maximumy&lt; depth of a leaf in the subtree that
is rooted at <code class="reqn">v</code>.
</p>
<p><code>get.subtreesize</code> - Creates a vector that contains at the <code class="reqn">i</code>-th position
the number of leaves in the pending subtree rooted at <code class="reqn">i</code>.
</p>
<p><code>getlca</code> - Returns the name of the lowest common ancestor of the two
input vertices <code class="reqn">v</code> and <code class="reqn">w</code>.
</p>
<p><code>we_eth</code> - Returns the Wedderburn-Etherington number <code class="reqn">we(n)</code>
for a given non-negative integer <code class="reqn">n</code>.
</p>
<p><code>getfurranks</code> - Returns for each vertex <code class="reqn">i</code> the Furnas rank of the
subtree rooted at <code class="reqn">i</code>.
</p>
<p><code>getsubtree</code> - Returns the pending subtree (in phylo format) that is
rooted at the input vertex. If the input vertex is a leaf, the function returns
the standard tree for <code class="reqn">n=1</code> (with 1 edge).
</p>
<p><code>is_binary</code> - Returns TRUE if the input tree is binary and FALSE otherwise.
</p>
<p><code>is_phylo</code> - Tests all requirements of the phylo format, and returns TRUE
if the tree is correctly formatted, else FALSE with detailed feedback on the
features that are not met.
</p>
<p><code>tree_decomposition</code> - Returns a list of length two, which
contains the two pending subtrees that are rooted at the children of the root
of the input tree. The
smaller one (according to the number of leaves) is stated first.
</p>
<p><code>tree_merge</code> - Returns a rooted tree <code class="reqn">T</code> in phylo
format, which contains the input trees <code class="reqn">tree1</code> and <code class="reqn">tree2</code> as
"left" and "right" maximal pending subtrees.
</p>
<p><code>treenumber</code> - Returns the unique tree number <code class="reqn">tn(T)</code> of the given tree.
<code class="reqn">tn(T)</code> is the rank of the tree <code class="reqn">T</code> among all
rooted binary trees in the left-light rooted ordering. It can
be calculated as follows: </p>
<p style="text-align: center;"><code class="reqn">tn(T)=F(T) + \sum_{i=1}^{n-1} we(i)</code>
</p>

<p>in which <code class="reqn">n</code> is the number of leaves in <code class="reqn">T</code>, <code class="reqn">F(T)</code> is the Furnas
rank of <code class="reqn">T</code>, i.e. the rank of <code class="reqn">T</code> in the left-light rooted ordering
of all rooted binary trees with <code class="reqn">n</code> leaves, and <code class="reqn">we(i)</code> is the
Wedderburn-Etherington number of <code class="reqn">i</code>.
The concept of assigning each rooted binary tree a unique tree number allows
to store many trees with minimal storage use.
For <code class="reqn">n=1</code> the function returns <code class="reqn">tn(T)=1</code> and a warning.
</p>
<p><code>treenumber_inv</code> - Returns the unique tree (in phylo format) for
the given tree number.
</p>
<p><code>auxE_l_X</code> - Returns the sum of all products of l different values in X.
</p>


<h3>Usage</h3>

<pre><code class="language-R">getDescMatrix(tree)

getAncVec(tree)

getNodesOfDepth(mat, root, n)

symBucketLexicoSort(workLabs)

getAllAncestors(tree, v)

cPL_inv(label)

maxDepthLeaf(tree, v = length(tree$tip.label) + 1)

get.subtreesize(tree)

getlca(tree, v, w)

we_eth(n)

getfurranks(tree)

getsubtree(tree, subroot)

is_binary(tree)

is_phylo(tree)

tree_decomposition(tree)

tree_merge(tree1, tree2)

treenumber(tree)

treenumber_inv(treenum)

auxE_l_X(subX, Xset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>tree</code></td>
<td>
<p>A rooted tree in phylo format, &gt;= 2 leaves</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>Descendants matrix from <code>getDescMatrix</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>root</code></td>
<td>
<p>Number (label) of the root of the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>Number of leaves of the tree</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>workLabs</code></td>
<td>
<p>numeric matrix (2 columns)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>v</code></td>
<td>
<p>A vertex of the tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>label</code></td>
<td>
<p>A Colijn-Plazotta label of desired tree, a positive integer.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>A vertex of the tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subroot</code></td>
<td>
<p>A vertex of the tree. It is not recommended to use
leaves as subroots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree1</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tree2</code></td>
<td>
<p>A rooted tree in phylo format.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>treenum</code></td>
<td>
<p>An integer denoting the tree number of the sought tree.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subX</code></td>
<td>
<p>integer &gt;=1, size of the subsets of X.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Xset</code></td>
<td>
<p>Vector (multiset) of numeric values.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>desc_mat</code> numeric matrix
</p>
<p><code>anc_vec</code> numeric vector
</p>
<p><code>nodes_of_depth</code> numeric matrix
</p>
<p><code>ranking</code> numeric vector
</p>
<p><code>vectorWithAncs</code> numeric vector
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting, Luise Kuehn and Lina Herbst
</p>


<h3>Examples</h3>

<pre><code class="language-R">mat &lt;- cbind(c(7,7,6,5,5,6),c(1,2,3,4,6,7))
tree &lt;- list(edge=mat, tip.label=c("","","",""), Nnode=3)
getDescMatrix(tree)
mat &lt;- cbind(c(5,5,5,5),c(1,2,3,4))
tree &lt;- list(edge=mat, tip.label=c("","","",""), Nnode=1)
getDescMatrix(tree)
getAncVec(tree)
getNodesOfDepth(mat=getDescMatrix(tree),root=length(tree$tip.label)+1,
n=length(tree$tip.label))
myWorkLabs &lt;- cbind(c(0,1,2,3,1,0),c(0,2,2,4,1,0))
symBucketLexicoSort(myWorkLabs)
getAllAncestors(tree,v=6)
cPL_inv(label=6)
maxDepthLeaf(tree,v=6)
get.subtreesize(tree)
getlca(tree,1,2)
we_eth(5)
getfurranks(tree)
getsubtree(tree,4)
is_binary(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
is_phylo(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
tree_decomposition(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
treeA &lt;- ape::read.tree(text="(((,),),(,));")
treeB &lt;- ape::read.tree(text="((,),);")
tree_merge(treeA, treeB)
treenumber(ape::read.tree(text="((((,),),(,)),(((,),),(,)));"))
treenumber_inv(192)
auxE_l_X(subX=3,Xset=c(1,1,2,2))
</code></pre>


</div>