<div class="container">

<table style="width: 100%;"><tr>
<td>tabular</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Compute complex table
</h2>

<h3>Description</h3>

<p>Computes a table of summary statistics, cross-classified by various variables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tabular(table, ...)
## Default S3 method:
tabular(table, ...)
## S3 method for class 'formula'
tabular(table, data = NULL, n, suppressLabels = 0, ...)
## S3 method for class 'tabular'
print(x, justification="n", ...)
## S3 method for class 'tabular'
format(x, digits=4, justification="n", latex=FALSE, html=FALSE, 
                         leftpad = TRUE, rightpad = TRUE, minus = TRUE, 
			 mathmode = TRUE, ...)
## S3 method for class 'tabular'
x[i, j, ..., drop=FALSE]
## S3 method for class 'tabular'
cbind(..., deparse.level = 1)
## S3 method for class 'tabular'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>

<p>A table expression.  See the Details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>

<p>An optional dataframe, list or environment in which to look for variables in the table.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>An optional value giving the length of the data.  See the Details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>suppressLabels</code></td>
<td>

<p>How many initial labels to suppress?
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
 
<p>The object to print, format, or subset.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits, ...</code></td>
<td>

<p>In the print and format methods, how many significant digits or other parameters to show by default?  See
Formatting below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>justification</code></td>
<td>

<p>The default justification to use in the table.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>latex</code></td>
<td>

<p>If <code>TRUE</code>, the <code>latexNumeric</code> function will be applied when formatting
numeric columns after <code>format</code>, to maintain spacing and handle signs properly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>html</code></td>
<td>

<p>If <code>TRUE</code>, the <code>htmlNumeric</code> function will be applied when formatting
numeric columns after <code>format</code>, to maintain spacing and handle signs properly.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leftpad, rightpad, minus, mathmode</code></td>
<td>

<p>Options to pass to <code>latexNumeric</code> or <code>htmlNumeric</code> to
control details of formatting.  See those pages for details.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i, j, drop</code></td>
<td>

<p>The usual arguments for matrix indexing, but see the Details below.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>deparse.level</code></td>
<td>

<p>Ignored.  (Present because the generic requires it.)
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For the purposes of this function, a "table" is a rectangular array of values, computed
using a formula expression.  The left hand side of the formula describes the rows
of the table, the right hand side describes the columns.
</p>
<p>Within the expression for the rows or columns, the operators <code>+</code>, <code>*</code>
and <code>=</code> have special meanings.  
</p>
<p>The <code>+</code> operator represents concatenation, so that <code>x + y ~ z</code> says to
show the rows corresponding to <code>x</code> above the rows corresponding to <code>y</code>.
</p>
<p>The <code>*</code> operator represents nesting, so that <code>x*y ~ z</code> says to
show the rows of <code>y</code> within each row corresponding to <code>x</code>.
</p>
<p>The <code>=</code> operator sets a new name for a term; it is an abbreviation
for the <code>Heading()</code> pseudo-function.  (“Pseudo-functions” are
described in the <code>tables</code> vignette.)  Note that
<code>=</code> has low operator precedence and may be confused by the parser
with setting function arguments, so parentheses are usually needed.
</p>
<p>Parentheses may be used to group terms in the usual arithmetic way, so 
<code>(x + y)*(u + v)</code> is equivalent to <code>x*u + x*v + y*u + y*v</code>.
</p>
<p>The names <code>Format</code>, <code>.Format</code>
and <code>Heading</code> have special meaning; see the section on Formatting below.
</p>
<p>The interpretation of other terms in the formulas depends on how they evaluate.  
</p>
<p>If the term evaluates to a function, it should be a summary function that 
produces a scalar value when applied to a vector of values, and that scalar will be displayed
in the table.  For example, <code> (mean + var) ~ x </code> will display the mean of
<code>x</code> above the variance of <code>x</code>.  If no function is specified, <code>length</code>
is assumed, so the table will display counts.  (At most one summary function may
be specified in any one term, so <code>mean*var</code> would be an error.)
</p>
<p>If the term evaluates to a logical vector, it is assumed to specify a subset.  For example,
<code> ~ (x &gt; 3) + (x &gt; 5)</code> will tabulate the counts of those two subsets.  
</p>
<p>If the term evaluates to a factor, it generates multiple rows or columns, corresponding
to the different levels of the factor.  For example if <code>A</code> has three levels, then
<code>A ~ mean*x</code> will calculate the mean of <code>x</code> within each level of <code>A</code>.
</p>
<p>If the term evaluates to a language object, it is treated as a macro, and expanded 
in place in the formula.
</p>
<p>Other terms are assumed to be R expressions producing a vector of values to be
summarized in the table.  Only one vector of values can be specified in any given term,
but different terms can summarize different values.  <code>is.atomic</code> must 
evaluate to <code>TRUE</code> for these values for them to be recognized.
</p>
<p>All logical, factor or other values in the table should be the same length, as if
they were columns in a dataframe (but they can be computed values).  If <code>n</code> is
missing but <code>data</code> is a dataframe, <code>n</code> is set from that.  Otherwise, if terms such
as <code>1</code> appear in a table, the length is assumed to be the same as for previous terms.
As a last resort, set the <code>n</code> argument in the call to <code>tabular()</code> explicitly.
</p>
<p>The <code>"["</code> method extracts a subset of the table.
For indexing, consider the table to consist of a matrix containing the values.
If <code>drop=TRUE</code>, the labels and attributes are dropped.  If <code>drop=FALSE</code>,
the default, the <code>i</code> and <code>j</code> indices must select 
a rectangular block of the table; matrix indexing (using a two column
matrix or a full matrix of logical values) is not supported.
</p>


<h3>Value</h3>

<p>An object of S3 class <code>"tabular"</code>.  This is a matrix of mode list,
whose entries are computed summary values, with the following attributes:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>rowLabels</code></td>
<td>
<p>A matrix of labels for the rows.  This will have the same number of rows
as the main matrix, but may have multiple columns for different nested levels of labels.
If a label covers multiple rows, it is entered in the first row, and <code>NA</code> is used to
fill following rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colLabels</code></td>
<td>
<p>Like <code>rowLabels</code>, but labelling the columns.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>table</code></td>
<td>
<p>The original table expression being displayed.  A list of the original
format specifications are attached as a <code>"fmtlist"</code> attribute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formats</code></td>
<td>
<p>A matrix of the same shape as the main result, containing <code>NA</code>
for default formatting, or an index into the format list.</p>
</td>
</tr>
</table>
<h3>Formatting</h3>

<p>The <code>tabular()</code> function does no formatting of computed values, but 
it records requests for formatting.
The <code>format.tabular()</code>, <code>print.tabular()</code> and <code>latex.tabular()</code> 
functions make use of these requests.
</p>
<p>By default, columns are formatted using the <code>format</code> function, with
arguments <code>digits</code> and any other arguments passed in <code>...</code>.  Each
column is formatted separately, similarly to how a matrix is printed by default.
</p>
<p>To request special formatting, four pseudo-functions are provided.  The first is
<code>Format</code>.  Normally it includes arguments to pass to the <code>format()</code>
function, e.g. <code>Format(digits=2)</code>.  It may instead include
a call to a function, e.g. <code>Format(sprintf("%.2f")</code>.  In either case
the summary values from
cells in the table that are nested below the <code>Format</code> specification
will be passed to that function in an argument named <code>x</code>, i.e. in the first
example, the values would be formatted using <code>format(digits=2, x=values)</code>, 
and in the second, using <code>sprintf("%.2f", x=values)</code>.  Users can supply
their own function to be used for formatting; it should take values in a named
argument <code>x</code> and return a character vector of the same length.
</p>
<p>This can be used to control formatting in multiple columns at once.  For example,
<code>Format(digits=2)*(mean + sd)</code> will print both the mean and standard deviation
in a single call to <code>format</code>, guaranteeing that the same number of decimal
places is used in both.  (The <code>iris</code> example below demonstrates this.)
</p>
<p>If the <code>latex</code> argument to <code>latex.tabular</code> is <code>TRUE</code>, then 
an effort is made to retain spacing, and to convert minus signs to the 
appropriate type of dash using the <code>latexNumeric</code> function. 
</p>
<p>The second pseudo-function <code>.Format</code> is mainly intended for internal use.  It
takes a single integer argument, saying that data governed by this call uses the
same formatting as another format specification.  In this way entries can be
commonly formatted even when they are not contiguous.  The integers are assigned
sequentially as the format specification is parsed; users will likely need
trial and error to find the right value in a complicated table with multiple formats.
</p>
<p>A third pseudo-function is <code>Justify</code>.  It takes character values or names as arguments;
how they are treated depends on the output format.  In <code>format.tabular</code>, coarse
justification is done to left, right or center, using <code>l</code>, <code>r</code> or <code>c</code>
respectively.
For LaTeX formatting, any string acceptable as a justification
string to LaTeX will be passed on.
</p>
<p>A final pseudo-function is <code>Heading</code>.  Use this function in the
row definitions to set a heading on the following column of row
labels.  (Internally this is how the headings on factor columns are
implemented.) If it is called with no argument, it suppresses the
following heading.  The <code>suppressLabels=n</code> argument to
<code>tabular()</code> is equivalent to repeating <code>Heading()</code> <code>n</code>
times at the start of the table formula.  The <code>=</code> operator is an
abbreviation for <code>Heading()</code>; see above.
</p>


<h3>
<code>tabular</code> methods</h3>

<p>The default <code>tabular</code> method just applies <code>as.formula</code> to
<code>table</code>, and then calls <code>tabular.formula</code>.
</p>
<p>The <code>tabular.formula</code> method is the main workhorse of the
package.  Other authors who wish to produce tables directly from their
own structures should normally create a formula whose environment
contains all mentioned variables and call <code>tabular.formula</code> with
appropriate arguments. 
</p>


<h3>Author(s)</h3>

<p>Duncan Murdoch
</p>


<h3>References</h3>

<p>This function was inspired by my 20 year old memories of the SAS TABULATE procedure.
</p>


<h3>See Also</h3>

<p><code>table</code> and <code>ftable</code> are base R functions which produce
tables of counts.  The <code>tables</code> vignette has many more examples and displays the
formatted output.
</p>


<h3>Examples</h3>

<pre><code class="language-R">tabular( (Species + 1) ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris )

# This example shows some of the less common options         
Sex &lt;- factor(sample(c("Male", "Female"), 100, replace = TRUE))
Status &lt;- factor(sample(c("low", "medium", "high"), 100, replace = TRUE))
z &lt;- rnorm(100)+5
fmt &lt;- function(x) {
  s &lt;- format(x, digits=2)
  even &lt;- ((1:length(s)) %% 2) == 0
  s[even] &lt;- sprintf("(%s)", s[even])
  s
}
tab &lt;- tabular( Justify(c)*Heading()*z*Sex*Heading(Statistic)*Format(fmt())*(mean+sd) 
                ~ Status )
tab
tab[1:2, c(2,3,1)]
</code></pre>


</div>