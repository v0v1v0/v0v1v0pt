<div class="container">

<table style="width: 100%;"><tr>
<td>scale_grass</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>GRASS scales</h2>

<h3>Description</h3>

<p>Implementation of <a href="https://grass.osgeo.org/grass83/manuals/r.colors.html">GRASS color tables</a>. The
following fill scales and palettes are provided:
</p>

<ul>
<li> <p><code style="white-space: pre;">⁠scale_*_grass_d()⁠</code>: For discrete values.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠scale_*_grass_c()⁠</code>: For continuous values.
</p>
</li>
<li> <p><code style="white-space: pre;">⁠scale_*_grass_b()⁠</code>: For binning continuous values.
</p>
</li>
<li> <p><code>grass.colors()</code>: Gradient color palette. See also
<code>grDevices::terrain.colors()</code> for details.
</p>
</li>
</ul>
<p>Additional parameters <code>...</code> would be passed on to:
</p>

<ul>
<li>
<p> Discrete values: <code>ggplot2::discrete_scale()</code>.
</p>
</li>
<li>
<p> Continuous values: <code>ggplot2::continuous_scale()</code>.
</p>
</li>
<li>
<p> Binned continuous values: <code>ggplot2::binned_scale()</code>.
</p>
</li>
</ul>
<p><strong>Note that</strong> <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> just documents a selection of these
additional parameters, check the <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> functions listed above to
see the full range of parameters accepted by these scales.
</p>
<p>These palettes are an implementation of <code>terra::map.pal()</code>, that is the
default color palettes provided by <code>terra::plot()</code> (<a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a>
<code style="white-space: pre;">⁠&gt; 1.7.78⁠</code>).
</p>


<h3>Usage</h3>

<pre><code class="language-R">scale_fill_grass_d(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_colour_grass_d(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  na.translate = FALSE,
  drop = TRUE
)

scale_fill_grass_c(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "colourbar"
)

scale_colour_grass_c(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "colourbar"
)

scale_fill_grass_b(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "coloursteps"
)

scale_colour_grass_b(
  palette = "viridis",
  ...,
  alpha = 1,
  direction = 1,
  values = NULL,
  limits = NULL,
  use_grass_range = TRUE,
  na.value = "transparent",
  guide = "coloursteps"
)

grass.colors(n, palette = "viridis", alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>palette</code></td>
<td>
<p>A valid palette name. The name is matched to the list of
available palettes, ignoring upper vs. lower case. See
grass_db for more info.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Arguments passed on to <code>ggplot2::discrete_scale</code>, <code>ggplot2::continuous_scale</code>, <code>ggplot2::binned_scale</code>
</p>

<dl>
<dt><code>breaks</code></dt>
<dd>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (the scale limits)
</p>
</li>
<li>
<p> A character vector of breaks
</p>
</li>
<li>
<p> A function that takes the limits as input and returns breaks
as output. Also accepts rlang lambda function
notation.
</p>
</li>
</ul>
</dd>
<dt><code>labels</code></dt>
<dd>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li>
<p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li>
<p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li>
<p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang lambda function
notation.
</p>
</li>
</ul>
</dd>
<dt><code>expand</code></dt>
<dd>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code>expansion()</code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</dd>
<dt><code>minor_breaks</code></dt>
<dd>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no minor breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks (one minor break between
each major break)
</p>
</li>
<li>
<p> A numeric vector of positions
</p>
</li>
<li>
<p> A function that given the limits returns a vector of minor breaks. Also
accepts rlang lambda function notation. When
the function has two arguments, it will be given the limits and major
breaks.
</p>
</li>
</ul>
</dd>
<dt><code>n.breaks</code></dt>
<dd>
<p>An integer guiding the number of major breaks. The algorithm
may choose a slightly different number to ensure nice break labels. Will
only have an effect if <code>breaks = waiver()</code>. Use <code>NULL</code> to use the default
number of breaks given by the transformation.</p>
</dd>
<dt><code>nice.breaks</code></dt>
<dd>
<p>Logical. Should breaks be attempted placed at nice values
instead of exactly evenly spaced between the limits. If <code>TRUE</code> (default)
the scale will ask the transformation object to create breaks, and this
may result in a different number of breaks than requested. Ignored if
breaks are given explicitly.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code>hsv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>direction</code></td>
<td>
<p>Sets the order of colors in the scale. If 1, the default,
colors are ordered from darkest to lightest. If -1, the order of colors is
reversed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.translate</code></td>
<td>
<p>Should <code>NA</code> values be removed from the legend? Default
is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>drop</code></td>
<td>
<p>Should unused factor levels be omitted from the scale? The
default (<code>TRUE</code>) removes unused factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>values</code></td>
<td>
<p>if colours should not be evenly positioned along the gradient
this vector gives the position (between 0 and 1) for each colour in the
<code>colours</code> vector. See <code>rescale()</code> for a convenience function
to map an arbitrary range to between 0 and 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li>
<p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li>
<p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang lambda function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code>coord_cartesian()</code>).
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>use_grass_range</code></td>
<td>
<p>Logical. Should the scale use the suggested range
when plotting? See <strong>Details</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.value</code></td>
<td>
<p>Missing values will be replaced with this value. By default,
<a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> uses <code>na.value = "transparent"</code> so cells with <code>NA</code> are
not filled. See also
<a href="https://github.com/dieghernan/tidyterra/issues/120">#120</a>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code>guides()</code> for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the
palette.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rev</code></td>
<td>
<p>logical indicating whether the ordering of the colors should
be reversed.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Some palettes are mapped by default to a specific range of values (see
grass_db). However, it is possible to modify this behaviour with the
<code>use_grass_range</code> argument, When <code>FALSE</code> the color scales would be mapped
to the range of values of the <code>color/fill</code> aesthethics, See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>The corresponding <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer with the values applied to the
<code>fill/colour</code> <code>aes()</code>.
</p>


<h3>
<a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code>terra::map.pal()</code>
</p>


<h3>Source</h3>

<p>Derived from <a href="https://github.com/OSGeo/grass/tree/main/lib/gis/colors">https://github.com/OSGeo/grass/tree/main/lib/gis/colors</a>. See
also <a href="https://grass.osgeo.org/grass83/manuals/r.colors.html">r.color - GRASS GIS Manual</a>.
</p>


<h3>References</h3>

<p>GRASS Development Team (2024). <em>Geographic Resources Analysis Support System
(GRASS) Software, Version 8.3.2</em>. Open Source Geospatial Foundation, USA.
<a href="https://grass.osgeo.org">https://grass.osgeo.org</a>.
</p>


<h3>See Also</h3>

<p>grass_db, <code>terra::plot()</code>,
<code>terra::minmax()</code>, <code>ggplot2::scale_fill_viridis_c()</code>.
</p>
<p>See also <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> docs on additional <code>...</code> parameters:
</p>
<p>Other gradient scales and palettes for hypsometry:
<code>scale_color_coltab()</code>,
<code>scale_cross_blended</code>,
<code>scale_hypso</code>,
<code>scale_princess</code>,
<code>scale_terrain</code>,
<code>scale_whitebox</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
filepath &lt;- system.file("extdata/volcano2.tif", package = "tidyterra")

library(terra)
volcano2_rast &lt;- rast(filepath)

# Palette
plot(volcano2_rast, col = grass.colors(100, palette = "haxby"))

library(ggplot2)
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_grass_c(palette = "terrain")

# Use with no default limits
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_grass_c(palette = "terrain", use_grass_range = FALSE)

# Full map with true tints

f_asia &lt;- system.file("extdata/asia.tif", package = "tidyterra")
asia &lt;- rast(f_asia)

ggplot() +
  geom_spatraster(data = asia) +
  scale_fill_grass_c(
    palette = "srtm_plus",
    labels = scales::label_number(),
    breaks = c(-10000, 0, 5000, 8000),
    guide = guide_colorbar(reverse = FALSE)
  ) +
  labs(fill = "elevation (m)") +
  theme(
    legend.position = "bottom",
    legend.title.position = "top",
    legend.key.width = rel(3),
    legend.ticks = element_line(colour = "black", linewidth = 0.3),
    legend.direction = "horizontal"
  )

# Binned
ggplot() +
  geom_spatraster(data = volcano2_rast) +
  scale_fill_grass_b(breaks = seq(70, 200, 25), palette = "sepia")


# With discrete values
factor &lt;- volcano2_rast %&gt;%
  mutate(cats = cut(elevation,
    breaks = c(100, 120, 130, 150, 170, 200),
    labels = c(
      "Very Low", "Low", "Average", "High",
      "Very High"
    )
  ))

ggplot() +
  geom_spatraster(data = factor, aes(fill = cats)) +
  scale_fill_grass_d(palette = "soilmoisture")


# Display all the GRASS palettes
data("grass_db")

pals_all &lt;- unique(grass_db$pal)

# In batches
pals &lt;- pals_all[c(1:25)]
# Helper fun for plotting

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = grass.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)

# Second batch
pals &lt;- pals_all[-c(1:25)]

ncols &lt;- 128
rowcol &lt;- grDevices::n2mfrow(length(pals))

opar &lt;- par(no.readonly = TRUE)
par(mfrow = rowcol, mar = rep(1, 4))

for (i in pals) {
  image(
    x = seq(1, ncols), y = 1, z = as.matrix(seq(1, ncols)),
    col = grass.colors(ncols, i), main = i,
    ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}
par(opar)
</code></pre>


</div>