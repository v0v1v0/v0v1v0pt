<div class="container">

<table style="width: 100%;"><tr>
<td>group-by.SpatVector</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Group a <code>SpatVector</code> by one or more variables</h2>

<h3>Description</h3>

<p>Most data operations are done on groups defined by variables.
<code>group_by.SpatVector()</code> adds new attributes to an existing <code>SpatVector</code>
indicating the corresponding groups. See <strong>Methods</strong>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'SpatVector'
group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))

## S3 method for class 'SpatVector'
ungroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data, x</code></td>
<td>
<p>A <code>SpatVector</code> object. See <strong>Methods</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code>group_by_drop_default()</code> for details.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See <strong>Details</strong> on <code>dplyr::group_by()</code>.
</p>


<h3>Value</h3>

<p>A <code>SpatVector</code> object with an additional attribute.
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code>dplyr::group_by()</code> family functions for
<code>SpatVector</code> objects.
</p>
<p><strong>When mixing</strong> <a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> <strong>and</strong> <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> <strong>syntax</strong> on a
grouped <code>SpatVector</code> (i.e, subsetting a <code>SpatVector</code> like <code>v[1:3,1:2]</code>) the
<code>groups</code> attribute can be corrupted. <a href="https://CRAN.R-project.org/package=tidyterra"><span class="pkg">tidyterra</span></a> would try to
re-group the <code>SpatVector</code>. This would be triggered the next time you use a
<a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verb on your <code>SpatVector</code>.
</p>
<p>Note also that some operations (as <code>terra::spatSample()</code>) would create a new
<code>SpatVector</code>. In these cases, the result won't preserve the <code>groups</code>
attribute. Use <code>group_by()</code> to re-group.
</p>


<h3>See Also</h3>

<p><code>dplyr::group_by()</code>, <code>dplyr::ungroup()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on group of rows:
<code>count.SpatVector()</code>,
<code>rowwise.SpatVector()</code>,
<code>summarise.SpatVector()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code>arrange.SpatVector()</code>,
<code>bind_cols.SpatVector</code>,
<code>bind_rows.SpatVector</code>,
<code>count.SpatVector()</code>,
<code>distinct.SpatVector()</code>,
<code>filter-joins.SpatVector</code>,
<code>filter.Spat</code>,
<code>glimpse.Spat</code>,
<code>mutate-joins.SpatVector</code>,
<code>mutate.Spat</code>,
<code>pull.Spat</code>,
<code>relocate.Spat</code>,
<code>rename.Spat</code>,
<code>rowwise.SpatVector()</code>,
<code>select.Spat</code>,
<code>slice.Spat</code>,
<code>summarise.SpatVector()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

library(terra)
f &lt;- system.file("ex/lux.shp", package = "terra")
p &lt;- vect(f)


by_name1 &lt;- p %&gt;% group_by(NAME_1)

# grouping doesn't change how the SpatVector looks
by_name1

# But add metadata for grouping: See the coercion to tibble

# Not grouped
p_tbl &lt;- as_tibble(p)
class(p_tbl)
head(p_tbl, 3)

# Grouped
by_name1_tbl &lt;- as_tibble(by_name1)
class(by_name1_tbl)
head(by_name1_tbl, 3)


# It changes how it acts with the other dplyr verbs:
by_name1 %&gt;% summarise(
  pop = mean(POP),
  area = sum(AREA)
)

# Each call to summarise() removes a layer of grouping
by_name2_name1 &lt;- p %&gt;% group_by(NAME_2, NAME_1)

by_name2_name1
group_data(by_name2_name1)

by_name2 &lt;- by_name2_name1 %&gt;% summarise(n = dplyr::n())
by_name2
group_data(by_name2)

# To removing grouping, use ungroup
by_name2 %&gt;%
  ungroup() %&gt;%
  summarise(n = sum(n))

# By default, group_by() overrides existing grouping
by_name2_name1 %&gt;%
  group_by(ID_1, ID_2) %&gt;%
  group_vars()


# Use add = TRUE to instead append
by_name2_name1 %&gt;%
  group_by(ID_1, ID_2, .add = TRUE) %&gt;%
  group_vars()

# You can group by expressions: this is a short-hand
# for a mutate() followed by a group_by()
p %&gt;%
  group_by(ID_COMB = ID_1 * 100 / ID_2) %&gt;%
  relocate(ID_COMB, .before = 1)

</code></pre>


</div>