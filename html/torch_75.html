<div class="container">

<table style="width: 100%;"><tr>
<td>linalg_cond</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes the condition number of a matrix with respect to a matrix norm.</h2>

<h3>Description</h3>

<p>Letting <code class="reqn">\mathbb{K}</code> be <code class="reqn">\mathbb{R}</code> or <code class="reqn">\mathbb{C}</code>,
the <strong>condition number</strong> <code class="reqn">\kappa</code> of a matrix
<code class="reqn">A \in \mathbb{K}^{n \times n}</code> is defined as
</p>


<h3>Usage</h3>

<pre><code class="language-R">linalg_cond(A, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>A</code></td>
<td>
<p>(Tensor): tensor of shape <code style="white-space: pre;">⁠(*, m, n)⁠</code> where <code>*</code> is zero or more batch dimensions
for <code>p</code> in <code style="white-space: pre;">⁠(2, -2)⁠</code>, and of shape <code style="white-space: pre;">⁠(*, n, n)⁠</code> where every matrix
is invertible for <code>p</code> in <code style="white-space: pre;">⁠('fro', 'nuc', inf, -inf, 1, -1)⁠</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p</code></td>
<td>
<p>(int, inf, -inf, 'fro', 'nuc', optional):
the type of the matrix norm to use in the computations (see above). Default: <code>NULL</code></p>
</td>
</tr>
</table>
<h3>Details</h3>


<p>Math could not be displayed. Please visit the package website.</p>

<p>The condition number of <code>A</code> measures the numerical stability of the linear system <code>AX = B</code>
with respect to a matrix norm.
</p>
<p>Supports input of float, double, cfloat and cdouble dtypes.
Also supports batches of matrices, and if <code>A</code> is a batch of matrices then
the output has the same batch dimensions.
</p>
<p><code>p</code> defines the matrix norm that is computed. See the table in 'Details' to
find the supported norms.
</p>
<p>For <code>p</code> is one of <code style="white-space: pre;">⁠('fro', 'nuc', inf, -inf, 1, -1)⁠</code>, this function uses
<code>linalg_norm()</code> and <code>linalg_inv()</code>.
</p>
<p>As such, in this case, the matrix (or every matrix in the batch) <code>A</code> has to be square
and invertible.
</p>
<p>For <code>p</code> in <code style="white-space: pre;">⁠(2, -2)⁠</code>, this function can be computed in terms of the singular values
<code class="reqn">\sigma_1 \geq \ldots \geq \sigma_n</code>
</p>

<p>Math could not be displayed. Please visit the package website.</p>

<p>In these cases, it is computed using <code>linalg_svd()</code>. For these norms, the matrix
(or every matrix in the batch) <code>A</code> may have any shape.
</p>

<table>
<tr>
<td style="text-align: left;">
   <code>p</code> </td>
<td style="text-align: left;"> matrix norm </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>NULL</code> </td>
<td style="text-align: left;"> <code>2</code>-norm (largest singular value) </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>'fro'</code> </td>
<td style="text-align: left;"> Frobenius norm </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>'nuc'</code> </td>
<td style="text-align: left;"> nuclear norm </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>Inf</code> </td>
<td style="text-align: left;"> <code>max(sum(abs(x), dim=2))</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>-Inf</code> </td>
<td style="text-align: left;"> <code>min(sum(abs(x), dim=2))</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>1</code> </td>
<td style="text-align: left;"> <code>max(sum(abs(x), dim=1))</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>-1</code> </td>
<td style="text-align: left;"> <code>min(sum(abs(x), dim=1))</code> </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>2</code> </td>
<td style="text-align: left;"> largest singular value </td>
</tr>
<tr>
<td style="text-align: left;">
   <code>-2</code> </td>
<td style="text-align: left;"> smallest singular value </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Value</h3>

<p>A real-valued tensor, even when <code>A</code> is complex.
</p>


<h3>Note</h3>

<p>When inputs are on a CUDA device, this function synchronizes that device with the CPU if
if <code>p</code> is one of <code style="white-space: pre;">⁠('fro', 'nuc', inf, -inf, 1, -1)⁠</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
a &lt;- torch_tensor(rbind(c(1., 0, -1), c(0, 1, 0), c(1, 0, 1)))
linalg_cond(a)
linalg_cond(a, "fro")
}
</code></pre>


</div>