<div class="container">

<table style="width: 100%;"><tr>
<td>geom_spatraster_rgb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Visualise <code>SpatRaster</code> objects as images</h2>

<h3>Description</h3>

<p>This geom is used to visualise <code>SpatRaster</code> objects (see <code>terra::rast()</code>) as
RGB images. The layers are combined such that they represent the red,
green and blue channel.
</p>
<p>For plotting <code>SpatRaster</code> objects by layer values use <code>geom_spatraster()</code>.
</p>
<p>The underlying implementation is based on <code>ggplot2::geom_raster()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">geom_spatraster_rgb(
  mapping = aes(),
  data,
  interpolate = TRUE,
  r = 1,
  g = 2,
  b = 3,
  alpha = 1,
  maxcell = 5e+05,
  max_col_value = 255,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mapping</code></td>
<td>
<p>Ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>A <code>SpatRaster</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r, g, b</code></td>
<td>
<p>Integer representing the number of layer of <code>data</code> to be
considered as the red (<code>r</code>), green (<code>g</code>) and blue (<code>b</code>) channel.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>The alpha transparency, a number in [0,1], see argument alpha in
<code>hsv</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for
the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max_col_value</code></td>
<td>
<p>Number giving the maximum of the color values range.
When this is <code>255</code> (the default), the result is computed most efficiently.
See <code>grDevices::rgb()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed on to <code>layer()</code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li>
<p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li>
<p> When constructing a layer using
a <code style="white-space: pre;">⁠stat_*()⁠</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li>
<p> Inversely, when constructing a layer using a
<code style="white-space: pre;">⁠geom_*()⁠</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li>
<p> The <code>key_glyph</code> argument of <code>layer()</code> may also be passed on through
<code>...</code>. This can be one of the functions described as
key glyphs, to change the display of the layer in the legend.
</p>
</li>
</ul>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> layer
</p>


<h3>
<a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code>terra::plotRGB()</code>
</p>


<h3>Aesthetics</h3>

<p>No <code>aes()</code> is required. In fact, <code>aes()</code> will be ignored.
</p>


<h3>Coords</h3>

<p>When the <code>SpatRaster</code> does not present a crs (i.e.,
<code>terra::crs(rast) == ""</code>) the geom does not make any assumption on the
scales.
</p>
<p>On <code>SpatRaster</code> that have a crs, the geom uses <code>ggplot2::coord_sf()</code> to
adjust the scales. That means that also the
<strong><code>SpatRaster</code> may be reprojected</strong>.
</p>


<h3>Source</h3>

<p>Based on the <code>layer_spatial()</code> implementation on <a href="https://CRAN.R-project.org/package=ggspatial"><span class="pkg">ggspatial</span></a> package.
Thanks to <a href="https://github.com/paleolimbot">Dewey Dunnington</a> and <a href="https://github.com/paleolimbot/ggspatial/graphs/contributors">ggspatial contributors</a>.
</p>


<h3>See Also</h3>

<p><code>ggplot2::geom_raster()</code>, <code>ggplot2::coord_sf()</code>, <code>grDevices::rgb()</code>.
</p>
<p>You can get also RGB tiles from the <a href="https://CRAN.R-project.org/package=maptiles"><span class="pkg">maptiles</span></a> package,
see <code>maptiles::get_tiles()</code>.
</p>
<p>Other <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> utils:
<code>autoplot.Spat</code>,
<code>fortify.Spat</code>,
<code>geom_spat_contour</code>,
<code>geom_spatraster()</code>,
<code>ggspatvector</code>,
<code>stat_spat_coordinates()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

# Tile of Castille and Leon (Spain) from OpenStreetMap
file_path &lt;- system.file("extdata/cyl_tile.tif", package = "tidyterra")

library(terra)
tile &lt;- rast(file_path)

library(ggplot2)


ggplot() +
  geom_spatraster_rgb(data = tile) +
  # You can use coord_sf
  coord_sf(crs = 3035)

# Combine with sf objects
vect_path &lt;- system.file("extdata/cyl.gpkg", package = "tidyterra")

cyl_sf &lt;- sf::st_read(vect_path)

ggplot(cyl_sf) +
  geom_spatraster_rgb(data = tile) +
  geom_sf(aes(fill = iso2)) +
  coord_sf(crs = 3857) +
  scale_fill_viridis_d(alpha = 0.7)

</code></pre>


</div>