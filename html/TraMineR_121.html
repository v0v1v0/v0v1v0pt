<div class="container">

<table style="width: 100%;"><tr>
<td>seqindic</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Sequence indicators</h2>

<h3>Description</h3>

<p>Table of per sequence values of selected indicators.
</p>


<h3>Usage</h3>

<pre><code class="language-R">seqindic(seqdata, indic=c("visited","trans","entr","cplx","turb2n"),
    with.missing=FALSE, ipos.args=list(), prec.args=list(), w=.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>seqdata</code></td>
<td>
<p>a state sequence object (class <code>stslist</code>) as returned by <code>seqdef</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indic</code></td>
<td>
<p>vector of character strings. List of selected indicators among <code>"lgth"</code> (sequence length), <code>"nonm"</code> (number of non-missing elements), <code>"dlgth"</code> (number of spells), <code>"visited"</code> (number of visited states), <code>"visitp"</code> (proportion of states visites), <code>"trans"</code> (number of state changes), <code>"transp"</code> (number of state changes as a proportion of maximum possible transitions), <code>"meand"</code> (mean spell duration),  <code>"dustd"</code> (duration standard deviation),
<code>"meand2"</code> (mean spell duration taking non-visited states into account), <code>"dustd2"</code> (duration standard deviation taking non-visited states into account),
<code>"entr"</code> (longitudinal normalized entropy), <code>"nsubs"</code> (number of subsequences of the DSS sequence), <code>"volat"</code> (objective volatility), <code>"cplx"</code> (complexity index),
<code>"turb"</code> (turbulence), <code>"turbn"</code> (normalized turbulence),
<code>"turb2"</code> (turbulence taking non-visited states into account), <code>"turb2n"</code> (normalized turbulence taking non-visited states into account),
<code>"ppos"</code> (proportion of positive states), <code>"nvolat"</code> (normative volatility), <code>"vpos"</code> objective volatility of positive-negative state sequences, <code>"integr"</code> (integrative potential),  <code>"degrad"</code> (degradation), <code>"bad"</code> (badness), <code>"prec"</code> (precarity index),  <code>"insec"</code> (insecurity). Can also be <code>"all"</code>, <code>"basic"</code>, <code>"diversity"</code>, <code>"complexity"</code>,  <code>"binary"</code>, and <code>"ranked"</code>, each selecting a subset of the indicators. Setting <code>indic="all"</code> selects all indicators but <code>"ppos"</code>, <code>"vpos"</code>, <code>"nvolat"</code>, <code>"integr"</code>, <code>"degrad"</code>, <code>"bad"</code>, <code>"prec"</code>, and <code>"insec"</code> that require an additional argument list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with.missing</code></td>
<td>
<p>logical: should non-void missing values be treated as a regular state? If <code>FALSE</code> (default) missing values are ignored.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ipos.args</code></td>
<td>
<p>list: when any of <code>"ppos"</code>, <code>"nvolat"</code>, <code>"vpos"</code>, or <code>"integr"</code> is requested, the arguments passed to <code>seqipos</code> together with <code>seqdata</code> and <code>with.missing</code>. See <code>seqipos</code></p>
</td>
</tr>
</table>
<table>
<tr style="vertical-align: top;">
<td><code>prec.args</code></td>
<td>
<p>list: when any of <code>"degrad"</code>, <code>"bad"</code>, <code>"prec"</code>, or <code>"insec"</code> is requested, the arguments passed to the underlying functions together with <code>seqdata</code> and <code>with.missing</code>. See <code>seqprecarity</code> and <code>seqibad</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>w</code></td>
<td>
<p>real in range [0,1]: when <code>volat</code> weight coefficient passed to <code>seqivolatility</code>. Default is .5.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The number of visited states is the number of different elements in the sequence, e.g. 2 for <code>aababba</code>. The recurrence index <code>'recu'</code> is the average number of visits of visited states, i.e. <code>Dlgth/Visited</code>, the number of spells on the number of visited states.
</p>
<p>The sequence length, number of transitions, longitudinal entropy, duration standard deviation, volatility, complexity, turbulence, degradation, badness, precarity, and insecurity are computed respectively with functions <code>seqlength</code>, <code>seqtransn</code>, <code>seqient</code>, <code>seqivardur</code>,  <code>seqivolatility</code>, <code>seqici</code>, <code>seqST</code>, <code>seqidegrad</code>, <code>seqibad</code>,  <code>seqprecarity</code>, and  <code>seqinsecurity</code>. The proportion of positive states, normative volatility, and integrative potential are computed with <code>seqipos</code>. See corresponding help pages for details.
</p>
<p>The proportion of positive states (<code>'ppos'</code>) and the normative volatility (<code>'nvolat'</code>) are the proportions of positive elements in respectively the original sequences and the DSS. They ignore the value of <code>dss</code> in the <code>ipos.args</code> list.
</p>
<p>The <code>with.missing</code> argument applies to all indicators but the length. <code>'lgth'</code> returns the length obtained with <code>with.missing=TRUE</code>, and <code>'nonm'</code> the length obtained with <code>with.missing=FALSE</code>.
</p>


<h3>Value</h3>

<p>A data frame with the selected indicators. Names are:
<br><code>Lght</code>: Length of the sequence
<br><code>NonM</code>: Number of non-missing elements
<br><code>Dlgth</code>: Number of spells (length of DSS)
<br><code>Visited</code>: Number of visited states
<br><code>Visitp</code>: Proportion of states visited
<br><code>Recu</code>: Recurrence: average number of visits to visited states
<br><code>Trans</code>: Number of transitions (state changes)
<br><code>Transp</code>: Number of state changes as a proportion of maximum number of transitions
<br><code>Entr</code>: Longitudinal entropy
<br><code>Meand</code>: Mean spell duration
<br><code>Dustd</code>: Duration standard deviation
<br><code>Meand2</code>: Mean spell duration taking non visited states into account
<br><code>Dustd2</code>: Duration standard deviation taking non visited states into account
<br><code>Nsubs</code>: Number of subsequences of the DSS sequence
<br><code>Volat</code>: Objective volatility
<br><code>Cplx</code>: Complexity
<br><code>Turb</code>: Turbulence
<br><code>Turbn</code>: Normalized turbulence
<br><code>Turb2</code>: Turbulence taking non visited states into account
<br><code>Turbn2</code>: Normalized turbulence taking non visited states into account
<br><code>Ppos</code>: Proportion of positive states
<br><code>Nvolat</code>: Normative volatility (proportion of positive spells)
<br><code>Vpos</code>: Objective volatility of positive-negative state sequences
<br><code>Integr</code>: Integrative capacity (potential)
<br><code>Degrad</code>: Degradation
<br><code>Bad</code>: Badness
<br><code>Prec</code>: Precarity
<br><code>Insec</code>: Insecurity
</p>


<h3>Author(s)</h3>

<p>Gilbert Ritschard</p>


<h3>References</h3>

<p>Ritschard, G. (2023), "Measuring the nature of individual sequences", <em>Sociological Methods and Research</em>, 52(4), 2016-2049. <a href="https://doi.org/10.1177/00491241211036156">doi:10.1177/00491241211036156</a>.
</p>


<h3>See Also</h3>

<p><code>seqlength</code>, <code>seqtransn</code>, <code>seqient</code>, <code>seqivardur</code>,  <code>seqivolatility</code>, <code>seqici</code>, <code>seqST</code>, <code>seqidegrad</code>, <code>seqibad</code>,  <code>seqprecarity</code>,  <code>seqinsecurity</code>, <code>seqipos</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">data(ex1)
sx &lt;- seqdef(ex1[,1:13], right="DEL")
print(sx, format='SPS')
seqindic(sx, indic=c("lgth","nonm","visited","turbn","cplx"))
seqindic(sx, indic=c("lgth","nonm","visited","turbn","cplx"), with.missing=TRUE)
seqindic(sx, indic=c("lgth","dlgth","ppos","integr","prec"), with.missing=TRUE,
          ipos.args=list(pos.states=c("A","B")),
          prec.args=list(state.order=c("A","B","C"), state.equiv=list(c("C","D"))))
seqindic(sx, indic=c("volat","binary"), ipos.args=list(pos.states=c("A","B")))
seqindic(sx, indic=c("basic","integr"), ipos.args=list(pos.states="D"))
</code></pre>


</div>