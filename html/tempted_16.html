<div class="container">

<table style="width: 100%;"><tr>
<td>tempted_all</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run all major functions of tempted</h2>

<h3>Description</h3>

<p>This function wraps functions <code>format_tempted</code>, <code>svd_centralize</code>, <code>tempted</code>,
<code>ratio_feature</code>, \
and <code>aggregate_feature</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tempted_all(
  featuretable,
  timepoint,
  subjectID,
  threshold = 0.95,
  pseudo = NULL,
  transform = "clr",
  r = 3,
  smooth = 1e-06,
  interval = NULL,
  resolution = 51,
  maxiter = 20,
  epsilon = 1e-04,
  r_svd = 1,
  do_ratio = TRUE,
  pct_ratio = 0.05,
  absolute = FALSE,
  pct_aggregate = 1,
  contrast = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>featuretable</code></td>
<td>
<p>A sample by feature matrix. It is an input for <code>format_tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>timepoint</code></td>
<td>
<p>The time stamp of each sample, matched with the rows of <code>featuretable</code>. It is an input for <code>format_tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subjectID</code></td>
<td>
<p>The subject ID of each sample, matched with the rows of <code>featuretable</code>. It is an input for <code>format_tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threshold</code></td>
<td>
<p>A threshold for feature filtering for microbiome data.
Features with zero value percentage &gt;= threshold will be excluded. Default is 0.95.
It is an input for <code>format_tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudo</code></td>
<td>
<p>A small number to add to all the counts before
normalizing into proportions and log transformation.
Default is 1/2 of the smallest non-zero value that is specific for each sample.
This pseudo count is added for <code>transform=c("logcomp", "clr", "logit")</code>.
It is an input for <code>format_tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transform</code></td>
<td>
<p>The transformation applied to the data.
<code>"logcomp"</code> for log of compositions.
<code>"comp"</code> for compositions.
<code>"ast"</code> for arcsine squared transformation.
<code>"clr"</code> for central log ratio transformation.
<code>"logit"</code> for logit transformation.
<code>"none"</code> for no transformation.
Default <code>transform="clr"</code> is recommended for microbiome data.
For data that are already transformed, use <code>transform="none"</code>.
It is an input for <code>format_tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r</code></td>
<td>
<p>Number of components to decompose into, i.e. rank of the CP type decomposition.
Default is set to 3.
It is an input for <code>tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>smooth</code></td>
<td>
<p>Smoothing parameter for RKHS norm.
Larger means smoother temporal loading functions. Default is set to be 1e-8.
Value can be adjusted depending on the dataset by checking the smoothness of the estimated temporal loading function in plot.
It is an input for <code>tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>interval</code></td>
<td>
<p>The range of time points to ran the decomposition for.
Default is set to be the range of all observed time points.
User can set it to be a shorter interval than the observed range.
It is an input for <code>tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>resolution</code></td>
<td>
<p>Number of time points to evaluate the value of the temporal loading function.
Default is set to 101. It does not affect the subject or feature loadings. It is an input for <code>tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxiter</code></td>
<td>
<p>Maximum number of iteration. Default is 20. It is an input for <code>tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Convergence criteria for difference between iterations. Default is 1e-4. It is an input for <code>tempted</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>r_svd</code></td>
<td>
<p>The number of ranks in the mean structure. Default is 1. It is an input for <code>svd_centralize</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>do_ratio</code></td>
<td>
<p>Whether to calculate the log ratio of features.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pct_ratio</code></td>
<td>
<p>The percent of features to sum up. Default is 0.05, i.e. 5%.
It is an input for <code>ratio_feature</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>absolute</code></td>
<td>
<p><code>absolute = TRUE</code> means features are ranked by the absolute value of feature loadings,
and the top <code>pct_ratio</code> percent of features are picked.
<code>absolute = FALSE</code> means features are ranked by the original value of feature loadings,
and the top and bottom <code>pct_ratio</code> percent of features are picked.
Then ratio is taken as the abundance of the features with positive loading
over the abundance of the features with negative loading.
It is an input for <code>ratio_feature</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pct_aggregate</code></td>
<td>
<p>The percent of features to aggregate,
features ranked by absolute value of the feature loading of each component.
Default is 1, which means 100% of features are aggregated.
Setting <code>pct_aggregate=0.01</code> means top 1% of features is aggregated,
where features are ranked in absolute value of feature loading of each component.
It is an input for <code>aggregate_feature</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>contrast</code></td>
<td>
<p>A matrix choosing how components are combined,
each column is a contrast of length r and used to calculate the linear combination of
the feature loadings of r components.
It is an input for <code>ratio_feature</code> and It is an input for <code>aggregate_feature</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list including all the input and output of functions <code>format_tempted</code>, <code>svd_centralize</code>, <code>tempted</code>,
<code>ratio_feature</code>, and <code>aggregate_feature</code>.
</p>

<dl>
<dt>input</dt>
<dd>
<p>All the input options of function <code>tempted_all</code>.</p>
</dd>
<dt>datalist_raw</dt>
<dd>
<p>Output of <code>format_tempted</code> with option <code>transform="none"</code>.</p>
</dd>
<dt>datlist</dt>
<dd>
<p>Output of <code>format_tempted</code>.</p>
</dd>
<dt>mean_svd</dt>
<dd>
<p>Output of <code>svd_centralize</code>.</p>
</dd>
<dt>A_hat</dt>
<dd>
<p>Subject loading, a subject by r matrix.</p>
</dd>
<dt>B_hat</dt>
<dd>
<p>Feature loading, a feature by r matrix.</p>
</dd>
<dt>Phi_hat</dt>
<dd>
<p>Temporal loading function, a resolution by r matrix.</p>
</dd>
<dt>time_Phi</dt>
<dd>
<p>The time points where the temporal loading function is evaluated.</p>
</dd>
<dt>Lambda</dt>
<dd>
<p>Eigen value, a length r vector.</p>
</dd>
<dt>r_square</dt>
<dd>
<p>Variance explained by each component. This is the R-squared of the linear regression of the vectorized temporal tensor against the vectorized low-rank reconstruction using individual components.</p>
</dd>
<dt>accum_r_square</dt>
<dd>
<p>Variance explained by the first few components accumulated. This is the R-squared of the linear regression of the vectorized temporal tensor against the vectorized low-rank reconstruction using the first few components.</p>
</dd>
<dt>metafeature_ratio</dt>
<dd>
<p>The log ratio abundance of the top over bottom ranking features. It is a data.frame with five columns: "value" for the log ratio values, "subID" for the subject ID, and "timepoint" for the time points, and "PC" indicating which component was used to construct the meta feature.</p>
</dd>
<dt>toppct_ratio</dt>
<dd>
<p>A matrix of TRUE/FALSE indicating which features are ranked top in each component (and contrast) and used as the numerator of the log ratio.</p>
</dd>
<dt>bottompct_ratio</dt>
<dd>
<p>A matrix of TRUE/FALSE indicating which features are ranked bottom in each component (and contrast) and used as the denominator of the log ratio.</p>
</dd>
<dt>metafeature_aggregate</dt>
<dd>
<p>The meta feature obtained by aggregating the observed temporal tensor. It is a data.frame with four columns: "value" for the meta feature values, "subID" for the subject ID, "timepoint" for the time points, and "PC" indicating which component was used to construct the meta feature.</p>
</dd>
<dt>toppct_aggregate</dt>
<dd>
<p>A matrix of TRUE/FALSE indicating which features are aggregated in each component and contrast.</p>
</dd>
<dt>contrast</dt>
<dd>
<p>The contrast used to linearly combine the components from input.</p>
</dd>
</dl>
<h3>References</h3>

<p>Shi P, Martino C, Han R, Janssen S, Buck G, Serrano M, Owzar K, Knight R, Shenhav L, Zhang AR. (2023) <em>Time-Informed Dimensionality Reduction for Longitudinal Microbiome Studies</em>. bioRxiv. doi: 10.1101/550749. <a href="https://www.biorxiv.org/content/10.1101/550749">https://www.biorxiv.org/content/10.1101/550749</a>.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Take a subset of the samples so the example runs faster

# Here we are taking samples from the odd months
sub_sample &lt;- rownames(meta_table)[(meta_table$day_of_life%/%12)%%2==1]
count_table_sub &lt;- count_table[sub_sample,]
processed_table_sub &lt;- processed_table[sub_sample,]
meta_table_sub &lt;- meta_table[sub_sample,]

# for preprocessed data that do not need to be transformed


res.processed &lt;- tempted_all(processed_table_sub,
                             meta_table_sub$day_of_life,
                            meta_table_sub$studyid,
                             threshold=1,
                             transform="none",
                             r=2,
                             smooth=1e-5,
                             do_ratio=FALSE)

# for count data that will have pseudo added and clr transformed

res.count &lt;- tempted_all(count_table_sub,
                         meta_table_sub$day_of_life,
                         meta_table_sub$studyid,
                         threshold=0.95,
                         transform="clr",
                         pseudo=0.5,
                         r=2,
                         smooth=1e-5,
                         pct_ratio=0.1,
                         pct_aggregate=1)

# for proportional data that will have pseudo added and clr transformed

res.proportion &lt;- tempted_all(count_table_sub/rowSums(count_table_sub),
                              meta_table_sub$day_of_life,
                              meta_table_sub$studyid,
                              threshold=0.95,
                              transform="clr",
                              pseudo=NULL,
                              r=2,
                              smooth=1e-5,
                              pct_ratio=0.1,
                              pct_aggregate=1)

# plot the temporal loading and subject trajectories grouped by delivery mode

plot_time_loading(res.proportion, r=2)

group &lt;- unique(meta_table[,c("studyid", "delivery")])

# plot the aggregated features

plot_metafeature(res.proportion$metafeature_aggregate, group, bws=30)

</code></pre>


</div>