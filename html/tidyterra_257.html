<div class="container">

<table style="width: 100%;"><tr>
<td>slice.Spat</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subset cells/rows/columns/geometries using their positions</h2>

<h3>Description</h3>

<p><code>slice()</code> methods lets you index cells/rows/columns/geometries by their
(integer) locations. It allows you to select, remove, and duplicate those
dimensions of a <code style="white-space: pre;">⁠Spat*⁠</code> object.
</p>
<p><strong>If you want to slice your <code>SpatRaster</code> by geographic coordinates</strong> use
<code>filter.SpatRaster()</code> method.
</p>
<p>It is accompanied by a number of helpers for common use cases:
</p>

<ul>
<li> <p><code>slice_head()</code> and <code>slice_tail()</code> select the first or last
cells/geometries.
</p>
</li>
<li> <p><code>slice_sample()</code> randomly selects cells/geometries.
</p>
</li>
<li> <p><code>slice_rows()</code> and <code>slice_cols()</code> allow to subset entire rows or columns,
of a <code>SpatRaster</code>.
</p>
</li>
<li> <p><code>slice_colrows()</code> subsets regions of the <code>SpatRaster</code> by row and column
position of a <code>SpatRaster</code>.
</p>
</li>
</ul>
<p>You can get a skeleton of your <code>SpatRaster</code> with the cell, column and row
index with <code>as_coordinates()</code>.
</p>
<p>See <strong>Methods</strong> for details.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'SpatRaster'
slice(.data, ..., .preserve = FALSE, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice(.data, ..., .preserve = FALSE)

## S3 method for class 'SpatRaster'
slice_head(.data, ..., n, prop, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice_head(.data, ..., n, prop)

## S3 method for class 'SpatRaster'
slice_tail(.data, ..., n, prop, .keep_extent = FALSE)

## S3 method for class 'SpatVector'
slice_tail(.data, ..., n, prop)

## S3 method for class 'SpatRaster'
slice_min(
  .data,
  order_by,
  ...,
  n,
  prop,
  with_ties = TRUE,
  .keep_extent = FALSE,
  na.rm = TRUE
)

## S3 method for class 'SpatVector'
slice_min(.data, order_by, ..., n, prop, with_ties = TRUE, na_rm = FALSE)

## S3 method for class 'SpatRaster'
slice_max(
  .data,
  order_by,
  ...,
  n,
  prop,
  with_ties = TRUE,
  .keep_extent = FALSE,
  na.rm = TRUE
)

## S3 method for class 'SpatVector'
slice_max(.data, order_by, ..., n, prop, with_ties = TRUE, na_rm = FALSE)

## S3 method for class 'SpatRaster'
slice_sample(
  .data,
  ...,
  n,
  prop,
  weight_by = NULL,
  replace = FALSE,
  .keep_extent = FALSE
)

## S3 method for class 'SpatVector'
slice_sample(.data, ..., n, prop, weight_by = NULL, replace = FALSE)

slice_rows(.data, ...)

## S3 method for class 'SpatRaster'
slice_rows(.data, ..., .keep_extent = FALSE)

slice_cols(.data, ...)

## S3 method for class 'SpatRaster'
slice_cols(.data, ..., .keep_extent = FALSE)

slice_colrows(.data, ...)

## S3 method for class 'SpatRaster'
slice_colrows(.data, ..., cols, rows, .keep_extent = FALSE, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>A <code>SpatRaster</code> created with <code>terra::rast()</code> or a <code>SpatVector</code>
created with <code>terra::vect()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>&lt;<code>data-masking</code>&gt; Integer row values.
Provide either positive values to keep, or negative values to drop.
</p>
<p>The values provided must be either all positive or all negative. Indices
beyond the number of rows in the input are silently ignored. See
<strong>Methods</strong>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.preserve</code></td>
<td>
<p>Ignored for <code style="white-space: pre;">⁠Spat*⁠</code> objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.keep_extent</code></td>
<td>
<p>Should the extent of the resulting <code>SpatRaster</code> be kept?
See also <code>terra::trim()</code>, <code>terra::extend()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n, prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used. If <code>n</code> is greater than the number of rows in the group
(or <code>prop &gt; 1</code>), the result will be silently truncated to the group size.
<code>prop</code> will be rounded towards zero to generate an integer number of
rows.
</p>
<p>A negative value of <code>n</code> or <code>prop</code> will be subtracted from the group
size. For example, <code>n = -2</code> with a group of 5 rows will select 5 - 2 = 3
rows; <code>prop = -0.25</code> with 8 rows will select 8 * (1 - 0.25) = 6 rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>order_by</code></td>
<td>
<p>&lt;<code>data-masking</code>&gt; Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>,
may return more rows than you request. Use <code>FALSE</code> to ignore ties,
and return the first <code>n</code> rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>Logical, should cells that present a value of <code>NA</code> removed when
computing <code>slice_min()/slice_max()</code>?. The default is <code>TRUE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>Should missing values in <code>order_by</code> be removed from the result?
If <code>FALSE</code>, <code>NA</code> values are sorted to the end (like in <code>arrange()</code>), so
they will only be included if there are insufficient non-missing values to
reach <code>n</code>/<code>prop</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_by</code></td>
<td>
<p>&lt;<code>data-masking</code>&gt; Sampling
weights. This must evaluate to a vector of non-negative numbers the same
length as the input. Weights are automatically standardised to sum to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols, rows</code></td>
<td>
<p>Integer col/row values of the <code>SpatRaster</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inverse</code></td>
<td>
<p>If <code>TRUE</code>, <code>.data</code> is inverse-masked to the given selection.
See <code>terra::mask()</code>.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A <code style="white-space: pre;">⁠Spat*⁠</code> object  of the same class than <code>.data</code>. See <strong>Methods</strong>.
</p>


<h3>
<a href="https://CRAN.R-project.org/package=terra"><span class="pkg">terra</span></a> equivalent</h3>

<p><code>terra::subset()</code>, <code>terra::spatSample()</code>
</p>


<h3>Methods</h3>

<p>Implementation of the <strong>generic</strong> <code>dplyr::slice()</code> function.
</p>


<h4><code>SpatRaster</code></h4>

<p>The result is a <code>SpatRaster</code> with the crs and resolution of the input and
where cell values of the selected cells/columns/rows are preserved.
</p>
<p>Use <code>.keep_extent = TRUE</code> to preserve the extent of <code>.data</code> on the output.
The non-selected cells would present a value of <code>NA</code>.
</p>



<h4><code>SpatVector</code></h4>

<p>The result is a <code>SpatVector</code> where the attributes of the selected
geometries are preserved. If <code>.data</code> is a
grouped <code>SpatVector</code>, the operation will be
performed on each group, so that (e.g.) <code>slice_head(df, n = 5)</code> will select
the first five rows in each group.
</p>



<h3>See Also</h3>

<p><code>dplyr::slice()</code>, <code>terra::spatSample()</code>.
</p>
<p>You can get a skeleton of your <code>SpatRaster</code> with the cell, column and row
index with <code>as_coordinates()</code>.
</p>
<p>If you want to slice by geographic coordinates use <code>filter.SpatRaster()</code>.
</p>
<p>Other single table verbs: 
<code>arrange.SpatVector()</code>,
<code>filter.Spat</code>,
<code>mutate.Spat</code>,
<code>rename.Spat</code>,
<code>select.Spat</code>,
<code>summarise.SpatVector()</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> verbs that operate on rows:
<code>arrange.SpatVector()</code>,
<code>distinct.SpatVector()</code>,
<code>filter.Spat</code>
</p>
<p>Other <a href="https://CRAN.R-project.org/package=dplyr"><span class="pkg">dplyr</span></a> methods:
<code>arrange.SpatVector()</code>,
<code>bind_cols.SpatVector</code>,
<code>bind_rows.SpatVector</code>,
<code>count.SpatVector()</code>,
<code>distinct.SpatVector()</code>,
<code>filter-joins.SpatVector</code>,
<code>filter.Spat</code>,
<code>glimpse.Spat</code>,
<code>group-by.SpatVector</code>,
<code>mutate-joins.SpatVector</code>,
<code>mutate.Spat</code>,
<code>pull.Spat</code>,
<code>relocate.Spat</code>,
<code>rename.Spat</code>,
<code>rowwise.SpatVector()</code>,
<code>select.Spat</code>,
<code>summarise.SpatVector()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">

library(terra)

f &lt;- system.file("extdata/cyl_temp.tif", package = "tidyterra")
r &lt;- rast(f)

# Slice first 100 cells
r %&gt;%
  slice(1:100) %&gt;%
  plot()

# Rows
r %&gt;%
  slice_rows(1:30) %&gt;%
  plot()

# Cols
r %&gt;%
  slice_cols(-(20:50)) %&gt;%
  plot()

# Spatial sample
r %&gt;%
  slice_sample(prop = 0.2) %&gt;%
  plot()


# Slice regions
r %&gt;%
  slice_colrows(
    cols = c(20:40, 60:80),
    rows = -c(1:20, 30:50)
  ) %&gt;%
  plot()

# Group wise operation with SpatVectors--------------------------------------
v &lt;- terra::vect(system.file("ex/lux.shp", package = "terra"))


glimpse(v) %&gt;% autoplot(aes(fill = NAME_1))

gv &lt;- v %&gt;% group_by(NAME_1)
# All slice helpers operate per group, silently truncating to the group size
gv %&gt;%
  slice_head(n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_tail(n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_min(AREA, n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))
gv %&gt;%
  slice_max(AREA, n = 1) %&gt;%
  glimpse() %&gt;%
  autoplot(aes(fill = NAME_1))

</code></pre>


</div>