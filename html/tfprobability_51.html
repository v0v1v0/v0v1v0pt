<div class="container">

<table style="width: 100%;"><tr>
<td>mcmc_uncalibrated_hamiltonian_monte_carlo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Runs one step of Uncalibrated Hamiltonian Monte Carlo</h2>

<h3>Description</h3>

<p>Warning: this kernel will not result in a chain which converges to the
<code>target_log_prob</code>. To get a convergent MCMC, use <code>mcmc_hamiltonian_monte_carlo(...)</code>
or <code>mcmc_metropolis_hastings(mcmc_uncalibrated_hamiltonian_monte_carlo(...))</code>.
For more details on <code>UncalibratedHamiltonianMonteCarlo</code>, see <code>HamiltonianMonteCarlo</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcmc_uncalibrated_hamiltonian_monte_carlo(
  target_log_prob_fn,
  step_size,
  num_leapfrog_steps,
  state_gradients_are_stopped = FALSE,
  seed = NULL,
  store_parameters_in_results = FALSE,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>target_log_prob_fn</code></td>
<td>
<p>Function which takes an argument like
<code>current_state</code> (if it's a list <code>current_state</code> will be unpacked) and returns its
(possibly unnormalized) log-density under the target distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>step_size</code></td>
<td>
<p><code>Tensor</code> or <code>list</code> of <code>Tensor</code>s representing the step
size for the leapfrog integrator. Must broadcast with the shape of
<code>current_state</code>. Larger step sizes lead to faster progress, but
too-large step sizes make rejection exponentially more likely. When
possible, it's often helpful to match per-variable step sizes to the
standard deviations of the target distribution in each variable.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>num_leapfrog_steps</code></td>
<td>
<p>Integer number of steps to run the leapfrog integrator
for. Total progress per HMC step is roughly proportional to
<code>step_size * num_leapfrog_steps</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>state_gradients_are_stopped</code></td>
<td>
<p><code>logical</code> indicating that the proposed
new state be run through <code>tf$stop_gradient</code>. This is particularly useful
when combining optimization over samples from the HMC chain.
Default value: <code>FALSE</code> (i.e., do not apply <code>stop_gradient</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer to seed the random number generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>store_parameters_in_results</code></td>
<td>
<p>If <code>TRUE</code>, then <code>step_size</code> and
<code>num_leapfrog_steps</code> are written to and read from eponymous fields in
the kernel results objects returned from <code>one_step</code> and
<code>bootstrap_results</code>. This allows wrapper kernels to adjust those
parameters on the fly. This is incompatible with <code>step_size_update_fn</code>,
which must be set to <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>string prefixed to Ops created by this function.
Default value: <code>NULL</code> (i.e., 'hmc_kernel').</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>a Monte Carlo sampling kernel
</p>


<h3>See Also</h3>

<p>Other mcmc_kernels: 
<code>mcmc_dual_averaging_step_size_adaptation()</code>,
<code>mcmc_hamiltonian_monte_carlo()</code>,
<code>mcmc_metropolis_adjusted_langevin_algorithm()</code>,
<code>mcmc_metropolis_hastings()</code>,
<code>mcmc_no_u_turn_sampler()</code>,
<code>mcmc_random_walk_metropolis()</code>,
<code>mcmc_replica_exchange_mc()</code>,
<code>mcmc_simple_step_size_adaptation()</code>,
<code>mcmc_slice_sampler()</code>,
<code>mcmc_transformed_transition_kernel()</code>,
<code>mcmc_uncalibrated_langevin()</code>,
<code>mcmc_uncalibrated_random_walk()</code>
</p>


</div>