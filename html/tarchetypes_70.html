<div class="container">

<table style="width: 100%;"><tr>
<td>tar_hook_outer</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Hook to wrap commands</h2>

<h3>Description</h3>

<p>Wrap the command of each target in an arbitrary R expression.
<code>tar_hook_outer()</code> expects unevaluated expressions for the <code>hook</code> and
<code>names</code> arguments, whereas <code>tar_hook_outer_raw()</code> expects
evaluated expression objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R">tar_hook_outer(
  targets,
  hook,
  names = NULL,
  set_deps = TRUE,
  envir = parent.frame()
)

tar_hook_outer_raw(
  targets,
  hook,
  names = NULL,
  set_deps = TRUE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>targets</code></td>
<td>
<p>A list of target objects. The input target list
can be arbitrarily nested, but it must consist entirely of target
objects. In addition, the return value is a simple list
where each element is a target object.
All hook functions remove the nested structure of the input target list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hook</code></td>
<td>
<p>R code to wrap each target's command.
The hook must contain the special placeholder symbol <code>.x</code>
so <code>tar_hook_outer()</code> knows where to insert the original command
of the target.
</p>
<p><code>tar_hook_outer()</code> expects unevaluated expressions for the <code>hook</code> and
<code>names</code> arguments, whereas <code>tar_hook_outer_raw()</code> expects
evaluated expression objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>names</code></td>
<td>
<p>Name of targets in the target list
to apply the hook. Supplied using <code>tidyselect</code> helpers like
<code>starts_with()</code>, as in <code>names = starts_with("your_prefix_")</code>.
Set to <code>NULL</code> to include all targets supplied to the <code>targets</code> argument.
Targets not included in <code>names</code> still remain in the target list,
but they are not modified because the hook does not apply to them.
</p>
<p>The regular hook functions expects unevaluated expressions for the <code>hook</code>
and <code>names</code> arguments, whereas the <code>"_raw"</code> versions expect
evaluated expression objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>set_deps</code></td>
<td>
<p>Logical of length 1, whether to refresh the dependencies
of each modified target by scanning the newly generated
target commands for dependencies. If <code>FALSE</code>, then the target will
keep the original set of dependencies it had before the hook.
Set to <code>NULL</code> to include all targets supplied to the <code>targets</code> argument.
<code>TRUE</code> is recommended for nearly all situations. Only use <code>FALSE</code>
if you have a specialized use case and you know what you are doing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>envir</code></td>
<td>
<p>Optional environment to construct the quosure for the <code>names</code>
argument to select names.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The expression you supply to <code>hook</code>
must contain the special placeholder symbol <code>.x</code>
so <code>tar_hook_outer()</code> knows where to insert the original command
of the target.
</p>


<h3>Value</h3>

<p>A flattened list of target objects with the hooks applied.
Even if the input target list had a nested structure,
the return value is a simple list where each element is a target object.
All hook functions remove the nested structure of the input target list.
</p>


<h3>Target objects</h3>

<p>Most <code>tarchetypes</code> functions are target factories,
which means they return target objects
or lists of target objects.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other hooks: 
<code>tar_hook_before()</code>,
<code>tar_hook_inner()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">if (identical(Sys.getenv("TAR_LONG_EXAMPLES"), "true")) {
targets::tar_dir({ # tar_dir() runs code from a temporary directory.
targets::tar_script({
  targets &lt;- list(
    # Nested target lists work with hooks.
    list(
      targets::tar_target(x1, task1()),
      targets::tar_target(x2, task2(x1))
    ),
    targets::tar_target(x3, task3(x2)),
    targets::tar_target(y1, task4(x3))
  )
  tarchetypes::tar_hook_outer(
    targets = targets,
    hook = postprocess(.x, arg = "value"),
    names = starts_with("x")
  )
})
targets::tar_manifest(fields = command)
# Using tar_hook_outer_raw():
targets::tar_script({
  targets &lt;- list(
    # Nested target lists work with hooks.
    list(
      targets::tar_target(x1, task1()),
      targets::tar_target(x2, task2(x1))
    ),
    targets::tar_target(x3, task3(x2)),
    targets::tar_target(y1, task4(x3))
  )
  tarchetypes::tar_hook_outer_raw(
    targets = targets,
    hook = quote(postprocess(.x, arg = "value")),
    names = quote(starts_with("x"))
  )
})
})
}
</code></pre>


</div>