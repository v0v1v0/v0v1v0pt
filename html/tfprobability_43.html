<div class="container">

<table style="width: 100%;"><tr>
<td>mcmc_random_walk_metropolis</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Runs one step of the RWM algorithm with symmetric proposal.</h2>

<h3>Description</h3>

<p>Random Walk Metropolis is a gradient-free Markov chain Monte Carlo
(MCMC) algorithm. The algorithm involves a proposal generating step
<code>proposal_state = current_state + perturb</code> by a random
perturbation, followed by Metropolis-Hastings accept/reject step. For more
details see Section 2.1 of Roberts and Rosenthal (2004).
</p>


<h3>Usage</h3>

<pre><code class="language-R">mcmc_random_walk_metropolis(
  target_log_prob_fn,
  new_state_fn = NULL,
  seed = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>target_log_prob_fn</code></td>
<td>
<p>Function which takes an argument like
<code>current_state</code> ((if it's a list <code>current_state</code> will be unpacked) and returns its
(possibly unnormalized) log-density under the target distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>new_state_fn</code></td>
<td>
<p>Function which takes a list of state parts and a
seed; returns a same-type <code>list</code> of <code>Tensor</code>s, each being a perturbation
of the input state parts. The perturbation distribution is assumed to be
a symmetric distribution centered at the input state part.
Default value: <code>NULL</code> which is mapped to <code>tfp$mcmc$random_walk_normal_fn()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>integer to seed the random number generator.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>name</code></td>
<td>
<p>String name prefixed to Ops created by this function.
Default value: <code>NULL</code> (i.e., 'rwm_kernel').</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The current class implements RWM for normal and uniform proposals. Alternatively,
the user can supply any custom proposal generating function.
The function <code>one_step</code> can update multiple chains in parallel. It assumes
that all leftmost dimensions of <code>current_state</code> index independent chain states
(and are therefore updated independently). The output of
<code>target_log_prob_fn(current_state)</code> should sum log-probabilities across all
event dimensions. Slices along the rightmost dimensions may have different
target distributions; for example, <code style="white-space: pre;">⁠current_state[0, :]⁠</code> could have a
different target distribution from <code style="white-space: pre;">⁠current_state[1, :]⁠</code>. These semantics
are governed by <code>target_log_prob_fn(current_state)</code>. (The number of
independent chains is <code>tf$size(target_log_prob_fn(current_state))</code>.)
</p>


<h3>Value</h3>

<p>a Monte Carlo sampling kernel
</p>


<h3>See Also</h3>

<p>Other mcmc_kernels: 
<code>mcmc_dual_averaging_step_size_adaptation()</code>,
<code>mcmc_hamiltonian_monte_carlo()</code>,
<code>mcmc_metropolis_adjusted_langevin_algorithm()</code>,
<code>mcmc_metropolis_hastings()</code>,
<code>mcmc_no_u_turn_sampler()</code>,
<code>mcmc_replica_exchange_mc()</code>,
<code>mcmc_simple_step_size_adaptation()</code>,
<code>mcmc_slice_sampler()</code>,
<code>mcmc_transformed_transition_kernel()</code>,
<code>mcmc_uncalibrated_hamiltonian_monte_carlo()</code>,
<code>mcmc_uncalibrated_langevin()</code>,
<code>mcmc_uncalibrated_random_walk()</code>
</p>


</div>