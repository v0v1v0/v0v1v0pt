<div class="container">

<table style="width: 100%;"><tr>
<td>nn_triplet_margin_with_distance_loss</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Triplet margin with distance loss</h2>

<h3>Description</h3>

<p>Creates a criterion that measures the triplet loss given input
tensors <code class="reqn">a</code>, <code class="reqn">p</code>, and <code class="reqn">n</code> (representing anchor,
positive, and negative examples, respectively), and a nonnegative,
real-valued function ("distance function") used to compute the relationship
between the anchor and positive example ("positive distance") and the
anchor and negative example ("negative distance").
</p>


<h3>Usage</h3>

<pre><code class="language-R">nn_triplet_margin_with_distance_loss(
  distance_function = NULL,
  margin = 1,
  swap = FALSE,
  reduction = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>distance_function</code></td>
<td>
<p>(callable, optional): A nonnegative, real-valued function that
quantifies the closeness of two tensors. If not specified,
<code>nn_pairwise_distance()</code> will be used.  Default: <code>None</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>
<p>(float, optional): A non-negative margin representing the minimum difference
between the positive and negative distances required for the loss to be 0. Larger
margins penalize cases where the negative examples are not distant enough from the
anchors, relative to the positives. Default: <code class="reqn">1</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swap</code></td>
<td>
<p>(bool, optional): Whether to use the distance swap described in the paper
<a href="https://paperswithcode.com/paper/learning-local-feature-descriptors-with">Learning shallow convolutional feature descriptors with triplet losses</a> by
V. Balntas, E. Riba et al. If TRUE, and if the positive example is closer to the
negative example than the anchor is, swaps the positive example and the anchor in
the loss computation. Default: <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p>(string, optional): Specifies the (optional) reduction to apply to the output:
<code>'none'</code> | <code>'mean'</code> | <code>'sum'</code>. <code>'none'</code>: no reduction will be applied,
<code>'mean'</code>: the sum of the output will be divided by the number of
elements in the output, <code>'sum'</code>: the output will be summed. Default: <code>'mean'</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The unreduced loss (i.e., with <code>reduction</code> set to <code>'none'</code>)
can be described as:
</p>
<p style="text-align: center;"><code class="reqn">
  \ell(a, p, n) = L = \{l_1,\dots,l_N\}^\top, \quad
l_i = \max \{d(a_i, p_i) - d(a_i, n_i) + {\rm margin}, 0\}
</code>
</p>

<p>where <code class="reqn">N</code> is the batch size; <code class="reqn">d</code> is a nonnegative, real-valued function
quantifying the closeness of two tensors, referred to as the <code>distance_function</code>;
and <code class="reqn">margin</code> is a non-negative margin representing the minimum difference
between the positive and negative distances that is required for the loss to
be 0.  The input tensors have <code class="reqn">N</code> elements each and can be of any shape
that the distance function can handle.
If <code>reduction</code> is not <code>'none'</code>
(default <code>'mean'</code>), then:
</p>
<p style="text-align: center;"><code class="reqn">
\ell(x, y) =
\begin{array}{ll}
\mbox{mean}(L), &amp;  \mbox{if reduction} = \mbox{`mean';}\\
            \mbox{sum}(L),  &amp;  \mbox{if reduction} = \mbox{`sum'.}
\end{array}
</code>
</p>

<p>See also <code>nn_triplet_margin_loss()</code>, which computes the triplet
loss for input tensors using the <code class="reqn">l_p</code> distance as the distance function.
</p>


<h3>Shape</h3>


<ul>
<li>
<p> Input: <code class="reqn">(N, *)</code> where <code class="reqn">*</code> represents any number of additional dimensions
as supported by the distance function.
</p>
</li>
<li>
<p> Output: A Tensor of shape <code class="reqn">(N)</code> if <code>reduction</code> is <code>'none'</code>, or a scalar
otherwise.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">if (torch_is_installed()) {
# Initialize embeddings
embedding &lt;- nn_embedding(1000, 128)
anchor_ids &lt;- torch_randint(1, 1000, 1, dtype = torch_long())
positive_ids &lt;- torch_randint(1, 1000, 1, dtype = torch_long())
negative_ids &lt;- torch_randint(1, 1000, 1, dtype = torch_long())
anchor &lt;- embedding(anchor_ids)
positive &lt;- embedding(positive_ids)
negative &lt;- embedding(negative_ids)

# Built-in Distance Function
triplet_loss &lt;- nn_triplet_margin_with_distance_loss(
  distance_function = nn_pairwise_distance()
)
output &lt;- triplet_loss(anchor, positive, negative)

# Custom Distance Function
l_infinity &lt;- function(x1, x2) {
  torch_max(torch_abs(x1 - x2), dim = 1)[[1]]
}

triplet_loss &lt;- nn_triplet_margin_with_distance_loss(
  distance_function = l_infinity, margin = 1.5
)
output &lt;- triplet_loss(anchor, positive, negative)

# Custom Distance Function (Lambda)
triplet_loss &lt;- nn_triplet_margin_with_distance_loss(
  distance_function = function(x, y) {
    1 - nnf_cosine_similarity(x, y)
  }
)

output &lt;- triplet_loss(anchor, positive, negative)
}
</code></pre>


</div>